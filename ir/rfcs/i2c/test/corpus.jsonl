{"_id":"doc-en-rfc7657-a56738e3257c6fde44496b708f69a5750bf03da4afa44635a702994afbb677fb","title":"","text":"Should not use different PHBs and DSCPs that allow reordering within a reliable transport protocol session (e.g., TCP connection, SCTP association). Receivers for such protocols interpret reordering as indicating loss of some of the out-of-order packets; see Section 2.4. For SCTP, this requirement applies across the entire SCTP association, and not just to individual streams within an association because SCTP's reliable transmission functionality operates on the overall association. Should use a a single PHB and DSCP for all packets in a single TCP connection, and likewise for a single STP association. See Section 2.6."}
{"_id":"doc-en-rfc7657-3e1e4bd509e55789faf83569afd968c0c9d48db0f78967741afc8f769af45796","title":"","text":"Expedited Forwarding (EF) [RFC3246] intended for inelastic traffic. Beyond the basic EF PHB, the VOICE-ADMIT PHB [RFC5865] is an admission controlled variant of the EF PHB. Both of these PHBs are based on pre-configured limited forwarding capacity; traffic that exceeds that capacity may be shaped, remarked to a different DSCP, or dropped."}
{"_id":"doc-en-rfc7657-f5462b1b92242ecaf9d1bff83e678e45fbbe37407073399d2b996ed644358dcc","title":"","text":"The RTCWEB protocol suite encompasses a number of forms of multiplexing:\n1. Individual source streams are carried in one or more individual RTP streams that can be multiplexed into a single RTP session as described in [RFC3550];\n2. RTCP (see [RFC3550]) may be multiplexed with the RTP session as described in [RFC5761];\n3. An RTP session could be multiplexed with other protocols via UDP encapsulation over a common pair of UDP ports as described in [RFC5764] as updated by [I-D.petithuguenin-avtcore-rfc5764-mux-fixes]; and\n4. The data may be further encapsulated via STUN [RFC5389] and TURN [RFC5766] for NAT (Network Address Translator) traversal."}
{"_id":"doc-en-rfc7657-f6b3f3ea794957e6b3a5475cdf90fe21cef89c7eecd6ca395b33f1038ea1b07a","title":"","text":"The resulting unidirectional UDP packet flow is identified by a 5-tuple, i.e., a combination of two IP addresses (source and destination), two UDP ports (source and destination), and the use of the UDP protocol. SDP bundle negotiation restrictions [I-D.ietf-mmusic-sdp-bundle-negotiation] limit RTCWEB to using at most a single DTLS session per UDP 5-tuple. In contrast, multiple SCTP associations can be multiplexed over a single UDP 5-tuple [RFC6951]."}
{"_id":"doc-en-rfc7657-fce26026dde59390da9b98e014b65c9143125ff570dc6b7fa3c3cea4872b87f1","title":"","text":"Section 2.1 explains how source streams can be multiplexed over RTP sessions, which can in turn be multiplexed over UDP with packets generated by other transport protocols. This section provides background on why this level of multiplexing is desirable. The rationale in this section applies both to multiplexing of source streams in RTP sessions and multiplexing of an RTP session with traffic from other transport protocols via UDP encapsulation."}
{"_id":"doc-en-rfc7657-a74e6844619d38753028ebd7df7b408a5ca008ddd1ae87dd9b55539bdf2ed394","title":"","text":"Should use a single PHB and DSCP for an RTCP session, primarily to avoid RTCP reordering (and because there is no compelling reason for use of different drop precedences). One of the PHBs and associated DSCP used for the associated RTP traffic would be an appropriate choice."}
{"_id":"doc-en-rfc7657-c6b423e294ff1359ca4d206ef93598788165ea383a83e32d6106408491dc8379","title":"","text":"3. An RTP session could be multiplexed with other protocols via UDP encapsulation over a common pair of UDP ports as described in [RFC5764] as updated by [I-D.petithuguenin-avtcore-rfc5764-mux-fixes]; and"}
{"_id":"doc-en-rfc7657-3f62242ac34d69c38bfc0e1fc3d8ca72f0d275ff9fc2a011396ec81af4ca1179","title":"","text":"This document describes the interaction between Differentiated Services (DiffServ) network quality of service (QoS) functionality and real-time network communication, including communication based on the Real-time Transport Protocol (RTP). DiffServ is based on network nodes applying different forwarding treatments to packets whose IP headers are marked with different DiffServ Code Points (DSCPs). As a result, use of different DSCPs within a single traffic stream may cause transport protocol interactions (e.g., reordering). In addition, DSCP markings may be changed or removed between the traffic source and destination. This document covers the implications of these DiffServ aspects for real-time network communication, including WEBRTC."}
{"_id":"doc-en-rfc7657-6956cff446d8e177a64291a0c6c32cf0933590962365e0d3ad1340694f3df658","title":"","text":"An RTP session could be multiplexed with other protocols via UDP encapsulation over a common pair of UDP ports as described in [RFC5764] as updated by [I-D.petithuguenin-avtcore-rfc5764-mux-fixes]; and"}
{"_id":"doc-en-rfc7657-e9c32915ac72d37d9a3bfcbf7d3c89258c27fd6b5be7013b7d1c23ae68580d6d","title":"","text":"The STUN [RFC5389] \/ ICE [RFC5245] \/ TURN [RFC5766] protocol family provides NAT\/FW traversal and port mapping for protocols (e.g., those in the RTCWEB protocol suite) via communication with a relay server. These protocols were originally designed for use of UDP, however, they have been extended to use TCP as a transport for situations in which UDP does not work [RFC6062]."}
{"_id":"doc-en-rfc7657-c7952df6eda57cfb7379f17942b530e876c57cfdc88f4e865cb7a5533969c675","title":"","text":"The DiffServ architecture [RFC2475][RFC4594] is intended to enable scalable service discrimination in the Internet without requiring each network node to store per-flow state and participate in per-flow signaling. The services may be end-to-end or within a network; they include both those that can satisfy quantitative performance requirements (e.g., peak bandwidth) and those based on relative performance (e.g., \"class\" differentiation). Services can be constructed by a combination of well-defined building blocks deployed in network nodes that:"}
{"_id":"doc-en-rfc7657-e331aa617023ac6914a0b2b5ece9851348c5a37f21a5172bd044383fd13c0eef","title":"","text":"A per-hop behavior (PHB) is a description of the externally observable forwarding behavior of a network node for network traffic marked with a DSCP that selects that PHB. In this context, \"forwarding behavior\" is a general concept - for example, if only one DSCP is used for all traffic on a link, the observable forwarding behavior (e.g., loss, delay, jitter) will often depend only on the relative loading of the link. To obtain useful behavioral differentiation, multiple traffic subsets are marked with different DSCPs for different PHBs for which node resources such as buffer space and bandwidth are allocated. PHBs provide the framework for a DiffServ network node to allocate resources to traffic subsets, with network-scope differentiated services constructed on top of this basic hop-by-hop resource allocation mechanism."}
{"_id":"doc-en-rfc7657-a2783f8b89f21d7cbd7db3071d76af445bfdad4b7b3bf98df80dec18ff5371bc","title":"","text":"A WebRTC application involves one or more RTP streams, as discussed above. In addition, it may include an SCTP-based data channel [I-D.ietf-rtcweb-data-channel] whose QoS treatment depends on the nature of the application. For example, best effort treatment of data channels is likely to suffice for messaging, shared white board, and guided browsing applications, whereas latency-sensitive games could require better QoS for their data channels."}
{"_id":"doc-en-rfc7657-f488ce19432d14b156edd7a2240f414fd1dabd56dc77e681aae8868ae9ed142b","title":"","text":"A simple example of real-time communications is a voice call placed over the Internet where an audio stream is transmitted in each direction between two users. A more complex example is an immersive videoconferencing system that has multiple video screens, multiple cameras, multiple microphones, and some means of sharing content. For such complex systems, there may be multiple media streams that may be transmitted via a single IP address and port or via multiple IP addresses and ports."}
{"_id":"doc-en-rfc7657-4819d6bda42b0d5996f7ad56adabf796d9284e33e7f20f934249f2bc8605ac2c","title":"","text":"Media encoding and packetization of a source stream results in a source RTP stream plus zero or more redundancy RTP streams that provide resilience against loss of packets from the source RTP stream [I-D.ietf-avtext-rtp-grouping-taxonomy]. Redundancy information may also be carried in the same RTP stream as the encoded source stream, e.g., see Section 7.2 of [RFC5109]. With most applications, a single media type (e.g., audio) is transmitted within a single RTP session. However, it is possible to transmit multiple, distinct source streams over the same RTP session as one or more individual RTP streams. This is referred to as RTP multiplexing. In addition, an RTP stream may contain multiple source streams that use the same reference clock (SSRC), e.g., components or programs in an MPEG Transport Stream [H.222.0]."}
{"_id":"doc-en-rfc7657-adbe371c74c5bbe4422eed6feae7abee3c6e9f4d5ca7c7f40b4eeaf2d0e9e84a","title":"","text":"RTP is usually carried over a datagram protocol, such as UDP[RFC0768], UDP-Lite [RFC3828] or DCCP [RFC4340]; UDP is most commonly used. Other transport protocols may also be used to transmit real-time data or near-real-time data. For example, SCTP [RFC4960] can be utilized to carry application sharing or whiteboarding information as part of an overall interaction that includes real time media. These additional transport protocols can be multiplexed with an RTP session via UDP encapsulation, thereby using a single pair of UDP ports."}
{"_id":"doc-en-rfc7657-ebe35d78ebd720b77659a100f53749aac0e860fbe765b5fc621ef5058a883daf","title":"","text":"The resulting unidirectional UDP packet flow is identified by a 5-tuple, i.e., a combination of two IP addresses (source and destination), two UDP ports (source and destination), and the use of the UDP protocol. SDP bundle negotiation restrictions [I-D.ietf-mmusic-sdp-bundle-negotiation] limit RTCWEB to using at most a single DTLS session per UDP 5-tuple. In contrast, multiple SCTP associations can be multiplexed over a single UDP 5-tuple [RFC6951]. penultimate paragraph in Section 2.1 RTP Background"}
{"_id":"doc-en-rfc7657-87dcf4ccaffd72761f8f852155f6af383c543d4a764fd382a18d8fecedf0844c","title":"","text":"For real-time communications, one might want to mark the audio packets using EF and the video packets as AF41. However, in a video conference receiving the audio packets ahead of the video is not useful because lip sync is necessary between audio and video. It may still be desirable to send audio with a PHB that provides better service, because early arrival of audio helps assure smooth audio rendering, which is often more important than fully faithful video rendering. There are also limits, as some devices have difficulties in synchronizing voice and video when packets that need to be rendered together arrive at significantly different times. It makes more sense to use different PHBs when the audio and video source streams do not share a strict timing relationship. For example, video content may be shared within a video conference via playback, perhaps of an unedited video clip that is intended to become part of a television advertisement. Such content sharing video does not need precise synchronization with video conference audio, and could use a different PHB, as content sharing video is more tolerant to jitter, loss, and delay."}
{"_id":"doc-en-rfc7657-0061d219345ec0c4690c0dc7ca1a8efe8d44e3f32f91f7895e12f8b0e164400e","title":"","text":"Unreliable datagram protocols (e.g., UDP, UDP-Lite, DCCP) are not sensitive to reordering in the network, because they do not provide reliable delivery or congestion control. On the other hand, when used to encapsulate other protocols (e.g., as UDP is used by RTCWEB, see Section 2.1), the reordering considerations for the encapsulated protocols apply. For the specific usage of UDP by RTCWEB, every encapsulated protocol (i.e., RTP, SCTP and TCP) is sensitive to reordering as further discussed in this document. In addition, [RFC5405] provides general guidelines for use of UDP (and UDP-Lite); the congestion control guidelines in that document apply to protocols encapsulated in UDP (or UDP-Lite). the last paragraph of Section 5.1. DiffServ, Reordering and Transport Protocols"}
{"_id":"doc-en-rfc7657-e790143ca03d2d059be5956c7a103a957a7acad9f05dbb7281dc93eb67b56c56","title":"","text":"Network packet reordering caused by use of different DSCPs has no effective upper bound, and can exceed the size of any reasonabl jitter buffer - in practice, the size of jitter buffers for replay is limited by external factors such as the amount of time that a human is willing to wait for replay to start."}
{"_id":"doc-en-rfc7657-3d7547ae851c4f3f96a574ab57806166d65ccb8ce358c2ca003e7e603c9c2a90","title":"","text":"RTCP multi-stream reporting optimizations for an RTP session [I-D.ietf-avtcore-rtp-multi-stream-optimisation] assume that the RTP streams involved experience the same packet loss behavior. This mechanism is highly inappropriate when the RTP streams involved use different PHBs, even if those PHBs differ solely in drop precedence."}
{"_id":"doc-en-rfc7657-b2b1f82f1eeb3663bd4d75e37a2ee5e6123ae39c19c22dcd1e71a1760fbad2a1","title":"","text":"The only use of multiple standardized PHBs and DSCPs that prevents network reordering among packets marked with different DSCPs is use of PHBs within a single AF class. All other uses of multiple PHBs and\/or the class selector DSCPs allow network reordering of packets that are marked with different DSCPs. Based on this and the foregoing discussion, the following requirements apply to use of DiffServ with real-time communications - applications and other traffic sources:"}
{"_id":"doc-en-rfc7657-fbf20b2b4e70e087ea02ebbd7580f72300a3a303493dc193ce63313974d7e6a9","title":"","text":"Should not use different PHBs and DSCPs that allow reordering within a single RTP stream. If this is not done, significant network reordering may overwhelm implementation assumptions about reordering limits, e.g., jitter buffer size, causing poor user experiences, see Section 5.2 above. When a common (coupled) congestion controller is used across multiple RTP streams, this recommendation against use of PHBs and DSCPs that allow reordering applies across all of the RTP streams that are within the scope of a single common (coupled) congestion controller."}
{"_id":"doc-en-rfc7657-f1f702c371cb65d1c2fd5632d850b1976a50240cb8903d4775456a3fe51204aa","title":"","text":"Guidance on transport protocol design and implementation to provide support for use of multiple PHBs and DSCPs in a transport protocol connection (e.g., DCCP) or transport protocol association (e.g., SCTP) is out of scope for this document."}
{"_id":"doc-en-rfc7657-6b071666ce29f74a2b9a9dd0b2dca9a0d699ab860dc11b781bedee127aca7908","title":"","text":"The RTCWEB protocol suite encompasses a number of forms of multiplexing:\n3. An RTP session could be multiplexed with other protocols via UDP encapsulation over a common pair of UDP ports as described in [RFC5764] as updated by [I-D.petithuguenin-avtcore-rfc5764-mux-fixes]; and\n4. The data may be further encapsulated via STUN [RFC5389] and TURN [RFC5766] for NAT (Network Address Translator) traversal."}
{"_id":"doc-en-rfc7657-0227a708bad93d9f5465b2f30cdc474c812a87d19dab1ec32269a517e20b509e","title":"","text":"Unreliable datagram protocols (e.g., UDP, UDP-Lite, DCCP) are not sensitive to reordering in the network, because they do not provide reliable delivery or congestion control. On the other hand, when used to encapsulate other protocols (e.g., as UDP is used by RTCWEB, see Section 2.1), the reordering considerations for the encapsulated protocols apply. For the specific usage of UDP by RTCWEB, every encapsulated protocol (i.e., RTP, SCTP and TCP) is sensitive to reordering as further discussed in this document. In addition, [RFC5405] provides general guidelines for use of UDP (and UDP-Lite); the congestion control guidelines in that document apply to protocols encapsulated in UDP (or UDP-Lite)."}
{"_id":"doc-en-rfc7657-2190c05a9641595037ccd1c33642fdd483396687cc117e9a5916db849291ef15","title":"","text":"Transport protocols that provide reliable delivery (e.g., TCP, SCTP) are sensitive to network reordering of traffic. When a protocol that provides reliable delivery receives a packet other than the next expected packet, the protocol usually assumes that the expected packet has been lost and respond with a retransmission request for that packet. In addition, congestion control functionality in transport protocols usually infers congestion when packets are lost, creating an additional sensitivity to significant reordering - such reordering may be (mis-)interpreted as indicating congestion-caused packet loss, causing a reduction in transmission rate. This remains true even when ECN [RFC3168] is in use, as ECN receivers are required to treat missing packets as potential indications of congestion."}
{"_id":"doc-en-rfc7657-07afc2077ef4f0b13f3dd5cbbbbc68cbb9b6eed219dccbae5505c1c54ba1f7a4","title":"","text":"Shared bottlenecks can be detected via correlations of measured metrics such as one-way delay. An alternative approach assumes that the set of packets on a single 5-tuple marked with DSCPs that do not allow reordering will utilize a common network path and common forwarding resources at each network node. Under that assumption, any bottleneck encountered by such packets is shared among all of them, making it safe to use a common (coupled) congestion controller, see [I-D.welzl-rmcat-coupled-cc]. This is not a safe assumption when the packets involved are marked with DSCP values that allow reordering because a bottleneck may not be shared among all such packets (e.g., if the DSCPs result in use of different queues at a network node, only one of which is a bottleneck)."}
{"_id":"doc-en-rfc7657-b0681704a079aae0c437cd99fd74703196c3eca291dda1d39cafbaee9f46354e","title":"","text":"o  Should use a single DSCP for all packets within a reliable\ntransport protocol session (e.g., TCP connection, SCTP\nassociation) or DCCP connection.  Receivers for such protocols\ninterpret reordering as indicating loss of some of the out-of-\norder packets; see Section 5.1 and there is no operational\nexperience with multiple PHBs and DSCPs for SCTP or DCCP, see\nSection 5.3.  For SCTP, this requirement applies across the entire\nSCTP association, and not just to individual streams within an\nassociation because SCTP's reliable transmission functionality\noperates on the overall association.  When TURN selects use of TCP\nfor NAT\/FW traversal, this guideline applies to all traffic\nmultiplexed onto that TCP connection, and multiple DSCPs are not\nappropriate, in contrast to use of UDP for NAT\/FW traversal."}
{"_id":"doc-en-rfc7657-e46fd9e54d1dfe748f3f77aff257b351ce8c21b66b7aa977614bdf2b42063ae6","title":"","text":"Should use a single DSCP for an RTCP session, primarily to avoid RTCP reordering (and because there is no compelling reason for use of different drop precedences). One of the PHBs and associated DSCP used for the associated RTP traffic would be an appropriate choice. [Editor's note: This bullet is an open technical issue.]"}
{"_id":"doc-en-rfc7657-900ec734a1c6a088dcc68bbb48094ebfe194747f7990079145cd607f7485a911","title":"","text":"In general, marking packets with different DSCPs results in different PHBs being applied at nodes in the network, making reordering possible due to use of different pools of forwarding resources for each PHB. This should not be done for current transport protocols within a single network 5-tuple, with the exception of UDP and UDP- Lite.\nWhen PHBs that allow reordering are mixed within a single network5-tuple, the effect is to mix QoS-based traffic classes within the scope of a single transport connection or association. Such QoS-based traffic classes receive different network QoS treatments and hence use different pools of network resources. Transport protocol support for multiple QoS-based traffic classes within a single network 5-tuple adds complexity to congestion-controlled transport protocols by comparison to current designs because it requires that network congestion information for each QoS-based traffic class be disambiguated so that congestion control is managed separately for each such traffic class. Traffic in different QoS-based traffic classes may use different paths through the network; this complicates path integrity checking in connection- or association-based protocols, as those paths may fail independently.\nThe primary example where usage of multiple PHBs does not allow reordering within a single network 5-tuple is use of PHBs from a single AF class (e.g., AF1x). Traffic reordering within the scope of a network 5-tuple that uses a single PHB or AF class may occur for other transient reasons (e.g., routing changes or ECMP rebalancing)."}
{"_id":"doc-en-rfc7657-8c13e48174e46c9047367f01da1bf458268bb5113603471066eebe6f656addbd","title":"","text":"The RTP Control Protocol (RTCP) [RFC3550] is used with RTP to monitor quality of service and convey information about RTP session participants. A sender of RTCP packets that also sends RTP packets (i.e., originates an RTP stream) should use the same DSCP marking for both types of packets. If an RTCP sender doesn't send any RTP packets, it should mark its RTCP packets with the DSCP that it would use if it did send RTP packets with media similar to the RTP traffic that it receives. If the RTCP sender uses or would use multiple DSCPs that differ only in drop precedence for RTP, then it should use the DSCP with the least likelihood of drop for RTCP to increase the likelihood of RTCP packet delivery.\nIf the SDP bundle extension [I-D.ietf-mmusic-sdp-bundle-negotiation] is used to negotiate sending multiple types of media in a single RTP session, then receivers will send separate RTCP reports for each type of media, using a separate SSRC for each media type; each RTCP report should be marked with the DSCP corresponding to the type of media handled by the reporting SSRC.\nThis guidance may result in different DSCP markings for RTP streams and RTCP receiver reports about those RTP streams. The resulting variation in network QoS treatment by traffic direction could result in unrepresentative round trip time (RTT) estimates that don't correspond to consistent network QoS treatment in both directions. RTCP receiver reports may be relatively infrequent (e.g., may be sent only once per video frame rendered) and hence the resulting RTT estimates are of limited utility for congestion control (although they have other important uses, see [RFC3550]). For this reason, it is not important that RTCP receiver reports receive the same network QoS treatment as the RTP stream or streams being reported on."}
{"_id":"doc-en-rfc7657-fbf84394d3f3c7aedd4d6ef6ddb880f16bd1f7cc461e691d315859a29a462fb1","title":"","text":"Should use a single DSCP for RTCP packets, which should be a DSC Pused for RTP packets that are or would be sent by that SSRC, see Section 5.4."}
{"_id":"doc-en-rfc7657-d74f02845236aeb6af9d4cab5bf325690e16043ea85065f30f075a254877c512","title":"","text":"This guidance may result in different DSCP markings for RTP streams and RTCP receiver reports about those RTP streams. The resulting variation in network QoS treatment by traffic direction could result in unrepresentative round trip time (RTT) estimates that don't correspond to consistent network QoS treatment in both directions. RTCP receiver reports may be relatively infrequent (e.g., may be sent only once per video frame rendered) and hence the resulting RTT estimates are of limited utility for congestion control (although they have other important uses, see [RFC3550]). For this reason, it is not important that RTCP receiver reports receive the same network QoS treatment as the RTP stream or streams being reported on."}
{"_id":"doc-en-rfc7657-6d5c1bf9d4abc515fafc2a9270014360d8d19f7dfa5bcdad4107ed5aa486ad7e","title":"","text":"The only use of multiple standardized PHBs and DSCPs that prevents network reordering among packets marked with different DSCPs is use of PHBs within a single AF class. All other uses of multiple PHBs and\/or the class selector DSCPs allow network reordering of packets that are marked with different DSCPs. Based on this and the foregoing discussion, the guidelines in this section apply to use of DiffServ with real-time communications."}
{"_id":"doc-en-rfc7657-e376c549d086edabc0822466047539c9cbf502f242dd7d472a1b7eed52390ec8","title":"","text":"2. Assured Forwarding (AF) [RFC2597] to provide differentiated service to elastic traffic. Each instance of the AF behavior consists of three PHBs that differ only in drop precedence, e.g., AF11, AF12 and AF13; such a set of three AF PHBs is referred to as an AF class, e.g., AF1x. There are four defined AF classes, AF1x through AF4x, with higher numbered classes intended to receive better forwarding treatment than lower numbered classes."}
{"_id":"doc-en-rfc7657-917d29063c9cf770749ef986fb997c9e14917765443f02751d1a3f78c91f3474","title":"","text":"CS1 ('001000') was subsequently designated as the recommended codepoint for the Lower Effort (LE) PHB [RFC3662]. An LE service forwards traffic with \"lower\" priority than best effort and can be \"starved\" by best effort and other \"higher\" priority traffic. Not all networks offer an LE service, hence traffic marked with the CS1 DSCP may not receive lower effort forwarding; such traffic may be forwarded with a different PHB (e.g., the Default PHB), remarked to another DSCP (e.g., CS0) and forwarded accordingly, or dropped. See [RFC3662] for further discussion of the LE PHB and service.\nOne cannot rely upon different class selector codepoints providing differentiated services or upon the presence of an LE service that is selected by the CS1 DSCP. There is no effective way for a network endpoint to determine which PHBs are selected by the class selector codepoints or whether the CS1 DSCP selects an LE service on a specific network, let alone end-to-end. Packets marked with the CS1 DSCP may be forwarded with best effort service or another \"higher\" priority service, see [RFC2474]."}
{"_id":"doc-en-rfc7657-425defb9b1981adcd61f602b9f29bd64949a5c92e13cc6c64a94831e7ef64066","title":"","text":"When PHBs that allow reordering are mixed within a single network5-tuple, the effect is to mix QoS-based traffic classes within the scope of a single transport connection or association. Such QoS-based traffic classes receive different network QoS treatments and hence use different pools of network resources. Transport protocol support for multiple QoS-based traffic classes within a single network 5-tuple adds complexity to congestion-controlled transport protocols by comparison to current designs because it requires that network congestion information for each QoS-based traffic class be disambiguated so that congestion control is managed separately for each such traffic class. Traffic in different QoS-based traffic classes may use different paths through the network; this complicates path integrity checking in connection- or association-based protocols, as those paths may fail independently."}
{"_id":"doc-en-rfc7657-d4008c23bbdfc6e4ba176ed85a40812ebff3fc964debf8c6f9fba2a8badbab58","title":"","text":"Real-time communications are also sensitive to network reordering of packets. Such reordering may lead to spurious NACK generation and unneeded transmission, as is the case for reliable delivery protocols (see Section 5.1). The degree of sensitivity depends on protocol or stream timers, in contrast to reliable delivery protocols that usually react to all reordering."}
{"_id":"doc-en-rfc8205-42286724754795cc34952158f8a7fce0f933c44e17000492b3a93508171b7036","title":"","text":"Route origin validation using Route Origin Authorizations (ROAs) [RFC6482] [RFC6811] is necessary and complements AS path attestation based on signed updates. Thus, the BGPsec design makes use of the origin validation capability facilitated by the ROAs in the RPKI. In the finalized BGPsec protocol specification [RFC8205], BGPsec is synonymous with cryptographic AS path attestation. Origin validation and BGPsec (path signatures) are the two key pieces of the SIDR WG solution for BGP security."}
{"_id":"doc-en-rfc8205-119b6f3e6aca3cfe4145b2724ce1072978d45e8f01970c3ae021a7f7cbc8141e","title":"","text":"An originating AS will sign over the Network Layer Reachability Information (NLRI) length, NLRI prefix, its own AS number (ASN), the next ASN, the signature algorithm suite ID, and a signature Expire Time (see Section 3.2) for the update. The update signatures will be carried in a new optional, non-transitive BGP attribute. The finalized BGPsec protocol specification [RFC8205] differs from the above. There is no mention in RFC 8205 of a signature Expire Time field in the BGPsec update. Further, there are some additional details concerning attributes signed by the origin AS that can be found in Figure 8 in Section 4.2 of RFC 8205 [RFC8205]. In particular, the signed data also includes the Address Family Identifier (AFI) as described in RFC 8205. By adding the AFI in the data covered by a signature, a specific security concern was alleviated; see [Mandelberg1] (post to the SIDR WG Mailing List) and the discussion thread that followed on the topic. The AFI is obtained from the MP_REACH_NLRI attribute in the BGPsec update. As stated in Section 4.1 of RFC 8205, a BGPsec update message \"MUST use the MP_REACH_NLRI attribute [RFC4760] to encode the prefix.\""}
{"_id":"doc-en-rfc8205-2e0ceda58c42a6b95777c5240cc63a4979afa5cb71c1c63918f9a3779cfc37e0","title":"","text":"In the context of BGPsec and throughout this document, an \"upstream AS\" simply refers to an AS that is further along in an AS path (the origin AS being the nearest to a prefix). In principle, an AS that is upstream from an originating AS would digitally sign the combined information, including the NLRI length, NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire Time. There are multiple choices regarding what is signed by an upstream AS, as follows: Method 1: The signature protects the combination of the NLRI length, NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire Time, Method 2: The signature protects just the combination of the previous signature (i.e., the signature of the neighbor AS who forwarded the update) and the next ASN, or Method 3: The signature protects everything that was received from the preceding AS plus the next (i.e., target) ASN; thus, ASi signs over the NLRI length, NLRI prefix, signature algorithm suite ID, Expire Time, {ASi, AS(i-1), AS(i-2), ..., AS2, AS1}, AS(i+1) (i.e., the next ASN), and {Sig(i-1), Sig(i-2), ..., Sig2, Sig1}. It was decided that Method 2 will be used. Please see [BGPsec-Initial] for additional protocol details and syntax. The finalized BGPsec protocol specification [RFC8205] essentially uses Method 3 (except for Expire Time). Additional details concerning attributes signed by an upstream AS can be found in Figure 8 in Section 4.2 of RFC 8205 [RFC8205]. The decision to go with Method 3 (with suitable additions to the data signed) was motivated by a security concern that was associated with Method 2; see [Mandelberg2] (post to the SIDR WG Mailing List) and the discussion thread that followed on the topic. Also, there is a strong rationale for the sequence of octets to be hashed (as shown in Figure 8 in Section 4.2 of RFC 8205); this sequencing of data is motivated by implementation efficiency considerations. See [Borchert] (post to the SIDR WG Mailing List) for an explanation."}
{"_id":"doc-en-rfc8205-feb4a60a25770e17144cc1203f9ff5fa433fa8827fcff1fbb417a9cfb232463d","title":"","text":"Any attributes other than those identified in Sections 2.2 and 2.3 are not signed. Examples of such attributes include the community attribute, the NO-EXPORT attribute, and Local_Pref."}
{"_id":"doc-en-rfc8205-bbfd36365adc870b311eb81646b2d4547533037fa16b229dbcf05baf8282c564","title":"","text":"The following example describes the expected router actions on receipt of a signed update. Consider an update that was originated by AS1 with NLRI prefix p and has traversed the AS path [AS(i-1) AS(i-2) ... AS2 AS1] before arriving at ASi. Let the Expire Time (inserted by AS1) for the signature in this update be denoted as Te. Let AlgID represent the ID of the signature algorithm suite that is in use. The update is to be processed at ASi and possibly forwarded to AS(i+1). Let the attestations (signatures) inserted by each router in the AS path be denoted by Sig1, Sig2, ..., Sig(i-2), and Sig(i-1) corresponding to AS1, AS2, ..., AS(i-2), and AS(i-1), respectively. The method (Method 2 in Section 2.3) selected for signing requires a receiving router in ASi to perform the following actions: Validate the route origin pair (p, AS1) by performing a ROA match. Verify that Te is greater than the clock time at the router performing these checks. Check Sig1 with inputs {NLRI length, p, AlgID, Te, AS1, AS2}. Check Sig2 with inputs {Sig1, AS3}. Check Sig3 with inputs {Sig2, AS4}. Check Sig(i-2) with inputs {Sig(i-3), AS(i-1)}. Check Sig(i-1) with inputs {Sig(i-2), ASi}. If the route that has been verified is selected as the best path (for prefix p), then generate Sig(i) with inputs {Sig(i-1), AS(i+1)}, and generate an update including Sig(i) to AS(i+1). The above description of BGPsec update validation and forwarding differs in its details from the published BGPsec protocol specification [RFC8205]. Please see Sections 4 and 5 of [RFC8205]."}
{"_id":"doc-en-rfc8205-6b477a32e4babbecb23eabc736fd4979aac45f304fcdff94d22de89cf0459379","title":"","text":"Prepending will be allowed. Prepending is defined as including more than one instance of the AS number (ASN) of the router that is signing the update. The finalized BGPsec protocol specification [RFC8205] uses a pCount field associated with each AS in the path to indicate the number of prepends for that AS (see Figure 5 in Section 3.1 of [RFC8205])."}
{"_id":"doc-en-rfc8205-b567af19480f12396f46102f79b3d63cba0631b6fc6f2227236ab6793b521bf0","title":"","text":"Concerning the inclusion of RPKI data in an update, it was decided that only the Subject Key Identifier (SKI) of the router certificate must be included in a signed update. This information identifies the router certificate, based on the SKI generation criteria defined in [RFC6487]."}
{"_id":"doc-en-rfc8205-6679c489e5ca272c40c97374cfbab324449531f232c592ea9f22a8d5752e0946","title":"","text":"Withdrawals are not signed."}
{"_id":"doc-en-rfc8205-8cd0c531a06c1bf2bdbce0b7572f99ab385ef0524eab455efbe9ad91205c5cb6","title":"","text":"Only the originating AS inserts a signature Expire Time in the update; all other ASes along an AS path do not insert Expire Times associated with their respective signatures. Further, the originating AS will re-originate a route sufficiently in advance of the Expire Time of its signature so that other ASes along an AS path will typically receive the re-originated route well ahead of the current Expire Time for that route. It is recommended that the duration of the signature Expire Time be on the order of days (preferably), but it may be on the order of hours (about 4 to 8 hours) in some cases on the basis of perceived need for extra protection from replay attacks (i.e., where extra replay protection is perceived to be critical). Each AS should stagger the Expire Time values in the routes it originates. Re-origination will be done, say, at time Tb after origination or the last re-origination, where Tb will equal a certain percentage of the Expire Time, Te (for example, Tb = 0.75 x Te). The percentage will be configurable. Additional guidance can be provided via an operational considerations document later. Further, the actual re-origination time should be jittered with a uniform random distribution over a short interval {Tb1, Tb2} centered at Tb. It is also recommended that a receiving BGPsec router detect that the only attribute change in an announcement (relative to the current best path) is the Expire Time (besides, of course, the signatures). In that case, assuming that the update is found valid, the route processor should not re-announce the route to non-BGPsec peers. (It should sign and re-announce the route to BGPsec speakers only.)  This procedure will reduce BGP chattiness for the non-BGPsec border routers. As mentioned earlier (Section 2.2.2), the Expire Time approach to mitigation of replay attacks and withdrawal suppression was subsequently changed to an approach based on router key rollover [BGPsec-Rollover] [Replay-Protection]."}
{"_id":"doc-en-rfc8205-52ecb7e1b6a0bc9aa21d032585e0cfd8be4f50ee1999c0d96d2d3674c237bd96","title":"","text":"The idea of sending a new signature Expire Time in a special message (rather than retransmitting the entire update with signatures) was considered. However, the decision was made to not do this. Re-origination to communicate a new signature Expire Time will be done by propagating a normal update message; no special type of message will be required."}
{"_id":"doc-en-rfc8205-2b3cab213cc5777bf654921a6ed1fc1275851d5d5a1c0a77ee4a64bfc6eb0394","title":"","text":"With regard to the RFD protocol [RFC2439] [JunOS] [CiscoIOS], no differential treatment is required for Expire-Time-triggered (re-beaconed) BGPsec updates. However, it was noted that it would be preferable if these updates did not cause route churn (and perhaps did not even require any RFD-related processing), since they are identical except for the change in the Expire Time value. This can be accomplished by not assigning an RFD penalty to Expire-Time-triggered updates. If the community agrees, this could be accommodated, but a change to the BGP-RFD protocol will be required."}
{"_id":"doc-en-rfc8205-f304ab07927d2a44fd315a1e97f6772765a26006384b8e08e0de36a33535087b","title":"","text":"Initially, the Elliptic Curve Digital Signature Algorithm (ECDSA) with curve P-256 and SHA-256 will be used for generating BGPsec path signatures. One other signature algorithm, e.g., RSA-2048, will also be used during prototyping and testing. The use of a second signature algorithm is needed to verify the ability of the BGPsec implementations to change from a current algorithm to the next algorithm. The BGPsec cryptographic algorithms document [RFC8208] specifies only the ECDSA with curve P-256 and SHA-256."}
{"_id":"doc-en-rfc8205-204b98ac659a5ded3b6d9b709cb0769157c7a6d7f4444fe0c108a0779a63cda5","title":"","text":"During the transition period from one algorithm (i.e., the current algorithm) to the next (new) algorithm, the updates will carry two sets of signatures (i.e., two Signature_Blocks), one corresponding to each algorithm. Each Signature_Block will be preceded by its type-length field and an algorithm suite identifier. A BGPsec speaker that has been upgraded to handle the new algorithm should validate both Signature_Blocks and then add its corresponding signature to each Signature_Block for forwarding the update to the next AS. A BGPsec speaker that has not been upgraded to handle the new algorithm will strip off the Signature_Block of the new algorithm and then will forward the update after adding its own signature to the Signature_Block of the current algorithm. It was decided that there will be at most two Signature_Blocks per update. BGPsec path signatures are carried in the Signature_Block, which is an attribute contained in the BGPsec_PATH attribute (see Section 3.2 in [RFC8205]). The algorithm agility scheme described in the published BGPsec protocol specification is consistent with the above; see Section 6.1 of [RFC8205]."}
{"_id":"doc-en-rfc8205-e21c730bf5dd0b12667000359d795de0f2c31aa2d2e962d780d9c2f6d27f0472","title":"","text":"There is currently weak or no support for the Sequential Aggregate Signature (SAS) approach. Please see Section 4.3.2 for a brief description of what the SAS is and what its pros and cons are."}
{"_id":"doc-en-rfc8205-bc39f165cf47c5fb059bcc8c2959f7b117fda9fa5b62ad76208e437e8a0ad999","title":"","text":"There is clearly a need to specify a transition path from a current protocol specification to a new version. When changes to the processing of the BGPsec path signatures are required, a new version of BGPsec will be required. Examples of this include changes to the data that is protected by the BGPsec signatures or adoption of a signature algorithm in which the number of signatures in the signature block may not correspond to one signature per AS in the AS path (e.g., aggregate signatures). This protocol-version transition mechanism is analogous to the algorithm transition discussed in Section 4.2. During the transition period from one protocol version (i.e., the current version) to the next (new) version, updates will carry two sets of signatures (i.e., two Signature_Blocks), one corresponding to each version. A protocol-version identifier is associated with each Signature_Block. Hence, each Signature_Block will be preceded by its type-length field and a protocol-version identifier. A BGPsec speaker that has been upgraded to handle the new version should validate both Signature_Blocks and then add its corresponding signature to each Signature_Block for forwarding the update to the next AS. A BGPsec speaker that has not been upgraded to handle the new protocol version will strip off the Signature_Block of the new version and then will forward the update with an attachment of its own signature to the Signature_Block of the current version. The details of protocol extensibility (i.e., transition to a new version of BGPsec) in the published BGPsec protocol specification (see Section 6.3 in [RFC8205]) differ somewhat from the above. In particular, the protocol-version identifier is not part of the BGPsec update. Instead, it is negotiated during the BGPsec capability exchange portion of BGPsec session negotiation."}
{"_id":"doc-en-rfc8205-5f5a434f5ffe0169236a3d1ebf375cca3440e4847c5c20ce2af9791ead1fb48f","title":"","text":"Within each AS, each individual BGPsec router can have a unique pair of private and public keys [RFC8207]."}
{"_id":"doc-en-rfc8205-5aae7e97d773a80f4c0e4112b3c6e877d7da5e42676ac5f6b68e3502e5a6b04f","title":"","text":"The router certificate subject name will be the string \"ROUTER\" followed by a decimal representation of a 4-byte ASN followed by the router ID. (Note: The details are specified in Section 3.1 in [RFC8209].)"}
{"_id":"doc-en-rfc8205-4f4d9f609018201910300cf30cb77bf7dbd53b9d0045f46e9dd2753bf290ab00","title":"","text":"With traditional BGP [RFC4271], an originating BGP router normally packs multiple prefix announcements into one update if the prefixes all share the same BGP attributes. When an upstream BGP router forwards eBGP updates to its peers, it can also pack multiple prefixes (based on the shared AS path and attributes) into one update. The update propagated by the upstream BGP router may include only a subset of the prefixes that were packed in a received update. Each update contains exactly one prefix. This avoids a level of complexity that would otherwise be inevitable if the origin had packed and signed multiple prefixes in an update and an upstream AS decided to propagate an update containing only a subset of the prefixes in that update. BGPsec recommendations regarding packing and repacking may be revisited when optimizations are considered in the future."}
{"_id":"doc-en-rfc8205-2ea9f36405987ad1c14210171f8034bfae2fcb3038da809d8b1319b66f46c710","title":"","text":"The initial design calls for including exactly one prefix per update; hence, there is only one signature in each secured update (modulo algorithm transition conditions)."}
{"_id":"doc-en-rfc8205-60e80dd70023332867e27674b8191266245591e64d26ae57337c1cb7a75656a6","title":"","text":"The current BGP update message PDU size is limited to 4096 bytes [RFC4271]. The question was raised as to whether or not BGPsec would require a larger update PDU size. The current thinking is that the maximum PDU size should be increased to 64 KB [BGP-Ext-Msg] so that there is sufficient room to accommodate two Signature_Blocks (i.e., one block with a current algorithm and another block with a new signature algorithm during a future transition period) for long AS paths. RFC 8205 states the following: \"All BGPsec UPDATE messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed.\""}
{"_id":"doc-en-rfc8205-aa538f31373d53a25a584f292eb498fd65562184496843c73c94a4f226d81e98","title":"","text":"If a BGPsec-capable router needs to temporarily suspend\/defer signing and\/or validation of BGPsec updates during periods of route processor overload, the router may do so even though such suspension\/deferment is not desirable; the specification does not forbid it. Following any temporary suspension, the router should subsequently send signed updates corresponding to the updates for which validation and signing were skipped. The router also may choose to skip only validation but still sign and forward updates during periods of congestion."}
{"_id":"doc-en-rfc8205-109b5b8d556f094561b6ca3d8900fd861e18dfe8117fbee458a077ae0daad348","title":"","text":"No attempt will be made in the BGPsec design to prevent downgrade attacks, i.e., a BGPsec-capable router sending unsigned updates when it is capable of sending signed updates."}
{"_id":"doc-en-rfc8205-35843b26460f4b1c9c8845be2d2451fb84bbea8b0538f95365f37300cd83d9e4","title":"","text":"It was decided that during capability negotiation, the address family for which the BGPsec speaker is advertising support for BGPsec will be shared using the Address Family Identifier (AFI). Initially, two address families would be included, namely, IPv4 and IPv6. BGPsec for use with other address families may be specified in the future. Simultaneous use of the two (i.e., IPv4 and IPv6) address families for the same BGPsec session will require that the BGPsec speaker include two instances of this capability (one for each address family) during BGPsec capability negotiation."}
{"_id":"doc-en-rfc8205-2846db7874ed98e6b97c944eb7464dc200ee24412c20399643099acc15c2a5e1","title":"","text":"BGPsec will be incrementally deployable. BGPsec routers will use capability negotiation to agree to run BGPsec between them. If a BGPsec router's peer does not agree to run BGPsec, then the BGPsec router will run only traditional BGP with that peer, i.e., it will not send BGPsec (i.e., signed) updates to the peer. See Section 7.9 of [RFC8205] for a discussion of incremental partial-deployment considerations. Also, Section 6 of [RFC8207] describes how edge sites (stub ASes) can sign updates that they originate but can receive only unsigned updates. This facilitates a less expensive upgrade to BGPsec in resource-limited stub ASes and expedites incremental deployment."}
{"_id":"doc-en-rfc8205-b7d099c7e5e83d7e7303678f03cedab5bad8aab5ee323b2528386e0caad56966","title":"","text":"\"Partial path signing\" means that a BGPsec AS can be permitted to sign an update that was received unsigned from a downstream neighbor. That is, the AS would add its ASN to the AS path and sign the (previously unsigned) update to other neighboring (upstream) BGPsec ASes. It was decided that partial path signing in BGPsec will not be allowed. A BGPsec update must be fully signed, i.e., each AS in the AS path must sign the update. So, in a signed update, there must be a signature corresponding to each AS in the AS path."}
{"_id":"doc-en-rfc8205-bbcb5f75a86e53e86a9a5f4f6bc0bf696b743a461f27ad8bc13e4a15d94706a9","title":"","text":"The protocol permits each pair of BGPsec-capable ASes to asymmetrically negotiate the use of BGPsec. Thus, a stub AS (or downstream customer AS) can agree to perform BGPsec only in the transmit direction and speak traditional BGP in the receive direction. In this arrangement, the ISP's (upstream) AS will not send signed updates to this stub or customer AS. Thus, the stub AS can avoid the need to hardware-upgrade its route processor and RIB memory to support BGPsec update validation."}
{"_id":"doc-en-rfc8205-c5dd5eb541e8a4d31f36b0701d0311e0e1ba357ffa4f9f0124b0576294d10069","title":"","text":"An ISP's AS (or upstream AS) can proxy-sign BGP announcements for a customer (downstream) AS, provided that the customer AS obtains an RPKI (CA) certificate, issues a router certificate under that CA certificate, and passes on the private key for that certificate to its upstream provider. That ISP (i.e., the second-hop AS) would insert a signature on behalf of the customer AS using the private key provided by the customer AS. This is a private arrangement between the two ASes and is invisible to other ASes. Thus, this arrangement is not part of the BGPsec protocol specification. BGPsec will not make any special provisions for an ISP to use its own private key to proxy-sign updates for a customer's AS. This type of proxy signing is considered a bad idea."}
{"_id":"doc-en-rfc8205-312319ba082e147aab2b32d2474c03720871943271bef9417613ff7b32137773","title":"","text":"No problems are anticipated when BGPsec-capable ASes have multiple peering sessions between them (between distinct routers)."}
{"_id":"doc-en-rfc8205-33703337f183ba31c666c8d0c89223ad0b21db97cfcc4444ae41e38d11ebcdc9","title":"","text":"In traditional BGP, the idea of peer groups is used in BGP routers to save on processing when generating and sending updates. Multiple peers for whom the same policies apply can be organized into peer groups. A peer group can typically have tens of ASes (and maybe as many as 300) in it. It was decided that BGPsec updates are generated to target unique AS peers, so there is no support for peer groups in BGPsec."}
{"_id":"doc-en-rfc8205-e4a9a15b3218709162e65b54c88d28cb19380cf68cb65e454c13d648a1345394","title":"","text":"The need to provide protection in BGPsec for the community attribute was discussed. Community attribute(s) will not be included in any message that is signed in BGPsec."}
{"_id":"doc-en-rfc8205-310aa25e3da4615b1bc46060b911f0e98c600a7f578c2606600fcac2310944b3","title":"","text":"An iBGP speaker that is also an eBGP speaker and that executes BGPsec will by necessity carry BGPsec data and perform eBGPsec functions. Confederations are eBGP clouds for administrative purposes and contain multiple Member-ASes. A Member-AS is not required to sign updates sent to another Member-AS within the same confederation. However, if BGPsec signing is applied in eBGP within a confederation, i.e., each Member-AS signs to the next Member-AS in the path within the confederation, then upon egress from the confederation, the Member-AS at the boundary must remove any and all signatures applied within the confederation. The Member-AS at the boundary of the confederation will sign the update to an eBGPsec peer using the public ASN of the confederation and its private key. The BGPsec specification will not specify how to perform this process. In RFC 8205, signing a BGPsec update between Member-ASes within a confederation is required if the update were to propagate with signatures within the confederation. A Confed_Segment flag exists in each Secure_Path segment, and when set, it indicates that the corresponding signature belongs to a Member-AS. At the confederation boundary, all signatures with Confed_Segment flags set are removed from the update. RFC 8205 specifies in detail how all of this is done. Please see Figure 5 in Section 3.1 of [RFC8205], as well as Section 4.3 of [RFC8205], for details."}
{"_id":"doc-en-rfc8205-a1ddb6724f2b894851386689c0ed5e09cd6177939ce28733bfc48782dcae0445","title":"","text":"[BGPsec-Initial] made no special provisions to accommodate route servers in Internet Exchange Points (IXPs).  The above decision subsequently changed: RFC 8205 allows the accommodation of IXPs, especially for transparent route servers. The pCount (AS prepend count) field is set to zero for transparent route servers (see Section 4.2 of [RFC8205]). The operational guidance for preventing the misuse of pCount=0 is given in Section 7.2 of RFC 8205. Also, see Section 8.4 of RFC 8205 for a discussion of security considerations concerning pCount=0."}
{"_id":"doc-en-rfc8205-cb46cac261416c9c53bd1bbf622b337df887e079154e9442a1df91545540c3a7","title":"","text":"Proxy aggregation (i.e., the use of AS_SETs in the AS path) will not be supported in BGPsec. There is no provision in BGPsec to sign an update when an AS_SET is part of an AS path. If a BGPsec-capable router receives an update that contains an AS_SET and also finds that the update is signed, then the router will consider the update malformed (i.e., a protocol error). Section 5.2 of RFC 8205 specifies that a receiving BGPsec router \"MUST handle any syntactical or protocol errors in the BGPsec_PATH attribute by using the 'treat-as-withdraw' approach as defined in RFC 7606 [RFC7606].\""}
{"_id":"doc-en-rfc8205-39093d85dc35ba906255d2a778dd6a30f968d6e3909d0d3ea63e867da6fbda49","title":"","text":"Not all (currently deployed) BGP speakers are capable of dealing with 4-byte ASNs [RFC6793]. The standard mechanism used to accommodate such speakers requires a peer AS to translate each 4-byte ASN in the AS path to a reserved 2-byte ASN (23456) before forwarding the update. This mechanism is incompatible with the use of BGPsec, since the ASN translation is equivalent to a route modification attack and will cause signatures corresponding to the translated 4-byte ASNs to fail validation. BGP speakers that are BGPsec capable are required to process 4-byte ASNs."}
{"_id":"doc-en-rfc8205-e4ed2aedd3e370e6ff83faa7fa81f71b2f1de56326c8abf01edff34b1afc9631","title":"","text":"It is natural to ask in what sequence a receiver must perform BGPsec update validation so that if a failure were to occur (i.e., the update was determined to be invalid) the processor would have spent the least amount of processing or other resources. There was agreement that the following sequence of receiver operations is quite meaningful; the following steps are included in [BGPsec-Initial]. However, the ordering of these validation-processing steps is not a normative part of the BGPsec specification. Verify that the signed update is syntactically correct. For example, check to see if the number of signatures matches the number of ASes in the AS path (after duly accounting for AS prepending). Verify that the origin AS is authorized to advertise the prefix in question. This verification is based on data from ROAs and does not require any cryptographic operations. Verify that the advertisement has not yet expired. Verify that the target ASN in the signature data matches the ASN of the router that is processing the advertisement. Note that the target-ASN check is also a non-cryptographic operation and is fast. Validate the signature data starting from the most recent AS to the origin. Locate the public key for the router from which the advertisement was received, using the SKI from the signature data. Hash the data covered by the signature algorithm. Invoke the signature validation algorithm on the following three inputs: the locally computed hash, the received signature, and the public key. There will be one output: valid or invalid. Repeat steps 5 and 6 for each preceding signature in the Signature_Block until (a) the signature data for the origin AS is encountered and processed or (b) either of these steps fails. Significant refinements to the above list occurred in the progress towards RFC 8205. The detailed syntactic-error checklist is presented and explained in Section 5.2 of [RFC8205]. Also, a logical sequence of steps to be followed in the validation of Signature_Blocks is described in Section 5.2 of [RFC8205]."}
{"_id":"doc-en-rfc8205-30e5fb93b9d386109bffe5c0bee1ec98155cec0dab6d17887ec7cd976e4a83fd","title":"","text":"A BGPsec router should sign and forward a signed update to upstream peers if it selected the update as the best path, regardless of whether the update passed or failed validation (at this router)."}
{"_id":"doc-en-rfc8205-31c2f96cdcd55a016da9962ce74c9646bc6fbf507edc9c8e0bcce2216522d18d","title":"","text":"Enumeration of error conditions and the recommendations for how to react to them are still under discussion. TBD. Also, please see Section 8.5 for the decision and discussion specifically related to syntactic errors in signatures. Section 5.2 of RFC 8205 describes the detection of syntactic and protocol errors in BGPsec updates as well as how the updates with such errors are to be handled."}
{"_id":"doc-en-rfc8205-9ba086bba097e0800efb9ad00a5e6cb2314948a9580a20a2b648b90c9a3297d3","title":"","text":"An update may come in unsigned from an eBGP peer or internally (e.g., as an iBGP update). In the latter case, the route is being originated from within the AS in question. If an unsigned route is received from an eBGP peer and if it is selected, then the route will be forwarded unsigned to other eBGP peers -- even BGPsec-capable peers. If the route originated in this AS (IGP or iBGP) and is unsigned, then it should be signed and announced to external BGPsec-capable peers."}
{"_id":"doc-en-rfc8205-35ade60e646cfb52fbfe967a724b1423aaead77e951e6fcfff52ba1cc72ba1b6","title":"","text":"The contents of this subsection (i.e., Section 8.5) differ substantially from the recommendations in RFC 8205 regarding the handling of syntactic errors and protocol errors. Hence, the reader may skip this subsection and instead read Section 5.2 of [RFC8205]. This subsection (Section 8.5) is kept here for the sake of archival value concerning design discussions. Different types of error conditions were discussed in Section 8.3. Here, the focus is only on syntactic-error conditions in signatures. If there are syntactic-error conditions such as (A) AS_SET and BGPsec_PATH both appearing in an update, (B) the number of signatures not matching the number of ASes (after accounting for any AS prepending), or (C) a parsing issue occurring with the BGPsec_PATH attribute, then the update (with the signatures stripped) will still be considered in the best-path-selection algorithm. (**Note: This is not true in RFC 8205**.)  If the update is selected as the best path, then the update will be propagated unsigned. The error condition will be logged locally. A BGPsec router will follow whatever the current IETF (IDR WG) recommendations are for notifying a peer that it is sending malformed messages. In the case when there are two Signature_Blocks in an update, and one or more syntactic errors are found to occur within one of them but the other one is free of any syntactic errors, then the update will still be considered in the best-path-selection algorithm after the syntactically bad Signature_Block has been removed. (**Note: This is not true in RFC 8205**.)  If the update is selected as the best path, then the update will be propagated with only one (i.e., the error-free) Signature_Block. The error condition will be logged locally."}
{"_id":"doc-en-rfc8205-a9c95893faac9a56a3a76529e762abddcc15f6bedd1effbe67e586333170c1b9","title":"","text":"Various validation conditions are possible that can be mapped to validation states for possible input to the BGPsec decision process. These conditions can be related to whether an update is signed, Expire Time is checked, route origin validation is checked against a ROA, signature verification passed, etc. It was decided that BGPsec validation outcomes will be mapped to one of only two validation states: (1) Valid -- passed all validation checks (i.e., Expire Time check, route origin and Signature_Block validation) and (2) Invalid -- all other possibilities. \"Invalid\" would include situations such as the following: Due to a lack of RPKI data or insufficient RPKI data, validation was not performed. The signature Expire Time check failed. Route origin validation failed. Signature checks were performed, and one or more of them failed. Expire Time is obsolete (see the notes in Sections 2.2.1 and 2.2.2). RFC 8205 uses the states \"Valid\" and \"Not Valid\", but only with respect to AS path validation (i.e., not including the result of origin validation); see Section 5.1 of [RFC8205]. \"Not Valid\" includes all conditions in which path validation was attempted but a \"Valid\" result could not be reached. (Note: Path validation is not attempted in the case of syntactic or protocol errors in a BGPsec update; see Section 5.2 of [RFC8205].)  Each Relying Party (RP) is expected to devise its own policy to suitably factor the results of origin validation [RFC6811] and path validation [RFC8205] into its path-selection decision."}
{"_id":"doc-en-rfc8205-098b1914e7dcb2311c29f3abbe66e727c1afbf831b17b05f4eb018d4d9b7cff4","title":"","text":"BGPsec validation need be performed only at eBGP edges. The validation status of a BGP signed\/unsigned update may be conveyed via iBGP from an ingress edge router to an egress edge router. Local policy in the AS will determine how the validation status is conveyed internally, using various preexisting mechanisms, e.g., setting a BGP community, or modifying a metric value such as Local_Pref or MED. A signed update that cannot be validated (except those with syntax errors) should be forwarded with signatures from the ingress router to the egress router, where it is signed when propagated towards other eBGPsec speakers in neighboring ASes. Based entirely on local policy settings, an egress router may trust the validation status conveyed by an ingress router, or it may perform its own validation. The latter approach may be used at an operator's discretion, under circumstances when RPKI skew is known to happen at different routers within an AS.  An extended community for carrying the origin validation state in iBGP has been specified in RFC 8097 [RFC8097]."}
{"_id":"doc-en-rfc8205-ded6ee6aeb85fca04f69a128f99367871aa05964dd1e441f554566b637510198","title":"","text":"BGP Graceful Restart (BGP-GR) [RFC4724] is a mechanism currently used to facilitate nonstop packet forwarding when the control plane is recovering from a fault (i.e., the BGP session is restarted) but the data plane is functioning. Two questions were raised: Are there any special concerns about how BGP-GR works while BGPsec is operational? Also, what happens if the BGP router operation transitions from traditional BGP operation to BGP-GR to BGPsec, in that order? No decision was made relative to this issue (at the time that [BGPsec-Initial] was written). See Section 7.7 of [RFC8205] for comments concerning the operation of BGP-GR with BGPsec. They are consistent with the discussion below."}
{"_id":"doc-en-rfc8205-a68a89f9ca782d300706ef58b2e9c8515e362a86770661924ec3b7e6f706d5fc","title":"","text":"Work related to this topic is still in progress."}
{"_id":"doc-en-rfc8205-9ac49b4adb47d7692370e3f0e88be8fb68131a7f2e210ab143dfe4c6feecb6e7","title":"","text":"Update signature validation and signing can be outsourced to an off-board server or processor."}
{"_id":"doc-en-rfc8205-323b1a85358284f195bf946c6538bd6e1f0331b3e3542a73fa980b1a57fc357e","title":"","text":"It is assumed that BGPsec routers (Provider Edge (PE) routers and route reflectors) will require significantly upgraded hardware -- much more memory for RIBs and hardware cryptographic assistance. However, stub ASes would not need to make such upgrades because they can negotiate asymmetric BGPsec capability with their upstream ASes, i.e., they sign updates to the upstream AS but receive only unsigned BGP updates (see Section 6.5)."}
{"_id":"doc-en-rfc8205-614647ef5620fa22dd72e01dd606e6d67390ea8ad900da98a2068eb61124c5c4","title":"","text":"The idea of signed BGP peering registrations (for the purpose of path validation) was rejected."}
{"_id":"doc-en-rfc8335-d4b148c6941928f4a4ba16567933683f0a1f062fcadef0f929e61372be5a5e3d","title":"","text":"When a network operator renumbers an interface, replacing a more widely-scoped address with a less widely-scope address, the operator also reduces the number of nodes from which ping can probe the interface. Furthermore, when a network operator removes all addresses from an interface, leaving it unnumbered, the operator makes that interface totally inaccessible to ping. Therefore, many network operators who rely on ping remain dependant upon widely-scoped interface addressing."}
{"_id":"doc-en-rfc8335-cf3ba2e5a63b6dfd2b4a237f56310b5d77f481fa8ada5ce1b9421d5f9db1e6bf","title":"","text":"Because the Extended Echo message makes a distinction between the destination and probed interfaces, eping can probe every interface on a node if it can reach any node on the node. In many cases, this allows network operators to decrease their dependence on widely-scoped interface addressing."}
{"_id":"doc-en-rfc8335-d2efdefac532f32ea7ce4eb94556c4d5f00bab5dad47b1928add5afc6a4668cb","title":"","text":"If the probed interface is identified by address, its address family does not need to be the same as that of the destination address. For example, the probed interface can be identified by its Ethernet address while the destination address is identified by an IPv4 address."}
{"_id":"doc-en-rfc8335-668eb711d9d2cf606d9b5750a8d98e9e72a0186eb24a5a54096c6a35ffbbc64c","title":"","text":"Likewise, the ability to probe by if ifIndex may enable certain information to be disclosed to attackers. Therefore, by default, implementations SHOULD NOT support probing by ifIndex. However, probing by ifIndex can be enabled through configuration."}
{"_id":"doc-en-rfc8335-5f55d58504636b8d9ddab2e9902b417a38f1f1f103bed4cc5657f788dd78646f","title":"","text":"PROBE MUST NOT leak information about one Virtual Private Network\n(VPN) into another.  Therefore, when a node receives an ICMP Extended\nEcho Request and the proxy interface is in a different VPN than the\nprobed interface, the node MUST return an ICMP Extended Echo Reply\nwith error code equal to (2) No Such Interface."}
{"_id":"doc-en-rfc8335-6866ccfbe8411eef995ae95e23db4d10263fc3b34e89c82594147a484aebdab9","title":"","text":"For each enabled query type, define the prefixes from which ICMP\nExtended Echo Request messages are permitted"}
{"_id":"doc-en-rfc8335-00364bba7794df9ecf3d2f1383ba509e363d1367b8fa0890a3540e1387f3b44b","title":"","text":"If the Interface Identification Object identifies the probed interface by name, the object payload contains the human-readable interface name. The interface name SHOULD be the full MIB-II ifName, if less than 255 octets, or the first 255 octets of the ifName, if the ifName is longer. The interface name MAY be some other human-meaningful name of the interface. The interface name MUST be represented in the UTF-8 charset [RFC3629] using the Default Language [RFC2277]."}
{"_id":"doc-en-rfc8335-2249d0fde2911939d2cac5c2986e947d41386b69be95f17973ab60f839dad364","title":"","text":"If the Interface Identification Object identifies the probed interface by name, the object payload contains the human-readable interface name. The interface name SHOULD be the full MIB-II ifName, if less than 255 octets, or the first 255 octets of the ifName, if the ifName is longer."}
{"_id":"doc-en-rfc8335-9e845e48267dc97c46b71478ea2d1ffa7c250526f5f69363a841afe42c1f2774","title":"","text":"If the probed interface resides on a node that is directly connected to the probed node, PROBE reports that the interface is up if it appears in the IPv4 Address Resolution Protocol (ARP) table or the IPv6 Neighbor Cache. Otherwise, it reports that the interface does not exist."}
{"_id":"doc-en-rfc8335-a636c551a7b4feba0ab99e1f781612dce259105f277b95096feaedd1cf72e983","title":"","text":"Set the Code field as described Section 4.1\nIf the Code Field is equal to No Error (0) and the L-bit is clear, set the A-Bit.\nIf the Code Field is equal to No Error (0) and the L-bit is set and the probed interface is active, set the A-bit."}
{"_id":"doc-en-rfc8335-306a2463940fc7c292e0bc19d65268f30fd8559c5611cfacfc9d640aa7b5cf0e","title":"","text":"If the Code Field is equal to No Error (0) and the L-bit is clear, set the A-Bit.\nIf the Code Field is equal to No Error (0) and the L-bit is set and the probed interface is active, set the A-bit."}
{"_id":"doc-en-rfc8335-b1db69d2b363f104fe872064a09e8e43d4155aec0dbf95f56dae1811b7938bb6","title":"","text":"Section 7 of [RFC4884] defines the ICMP Extension Structure.  As per\nRFC 4884, the Extension Structure contains exactly one Extension\nHeader followed by one or more objects.  When applied to the ICMP\nExtended Echo Request message, the ICMP Extension Structure MUST\ncontain one or two instances of the Interface Identification Object  (Section 2.1)."}
{"_id":"doc-en-rfc8335-99f78b9532b2335b8ed7239790db23b6dc343e54ef97508276253c1b7709dcd1","title":"","text":"If the Interface Identification Object identifies the probed interface by index, the length is equal to 8 and the payload contains the MIB-II ifIndex [RFC2863]."}
{"_id":"doc-en-rfc8335-fadc9a28aa874240e8c6d155182d5f5364831f5c0da27c66d919ccab833a4626","title":"","text":"If the Interface Identification Object identifies the probed  interface by name, the object payload MUST be the MIB-II [RFC2863] ifName.  If the object payload would not otherwise terminate on a\n32-bit boundary, it MUST be padded with ASCII NULL characters."}
{"_id":"doc-en-rfc8335-70f5da6ab8fdacd4a0a20ab03270eb98e64884ac395b8abc88081e879787edcf","title":"","text":"If the probed interface resides on the probed node, PROBE determines\nthe status of the probed interface as it would determine its MIB-II\n[RFC2863] ifOperStatus.  If ifOperStatus is equal to up (1), PROBE\nreports that the probed interface is active.  Otherwise, PROBE\nreports that the probed interface is inactive."}
{"_id":"doc-en-rfc8335-89bb2689d50a3521e5d651bd53420f3c0acdb08b4714ab89a8d62724f32ca698","title":"","text":"E (Ethernet) - The E-bit is set if the A-bit is also set and Ethernet is running on the probed interface. Otherwise, the E-bit is clear."}
{"_id":"doc-en-rfc8335-7a23d5ae26ca5e652c2bb312a1bdadd14334daf7e68e8716f3151783b3ddeb22","title":"","text":"This document describes a network diagnostic tool called PROBE. PROBE is similar to PING, in that it can be used to test the status of a probed interface. It differs from PING in that it does not require bidirectional connectivity between the probing and probed interfaces. Alternatively, PROBE requires bidirectional connectivity between the probing interface and a proxy interface. The proxy interface can reside on the same node as the probed interface or it can reside on a node to which the probed interface is directly connected. This document updates RFC 4884."}
{"_id":"doc-en-rfc8335-ae07f5f0c61a0e57351de8f26868391e52b76d4428f008e3e7dddae9fd0db0a4","title":"","text":"Like PING, PROBE executes on a probing node. It sends an ICMP Extended Echo message from a local interface, called the probing interface, to a proxy interface. The proxy interface resides on a probed node."}
{"_id":"doc-en-rfc8335-eb8043823ab2005573cde2a10c88fee03e7252b53bfc99ea7fb8e817566443cb","title":"","text":"L (local) - The L-bit is set if the probed interface resides on the probed node. The L-bit is clear if the probed interface is directly connected to the probed node."}
{"_id":"doc-en-rfc8335-c114f56f6ef56a72c91db5a3bb2187286b2d07b8210a5ac1ff8d5add7ef30b92","title":"","text":"Code: (0) No Error, (1) Malformed Query, (2) No Such Interface,\n(3) Multiple Interfaces Satisfy Query"}
{"_id":"doc-en-rfc8335-4f8f8ac30bd830490986409e341d1bffb5875dc533eef502685e049ec1c807b8","title":"","text":"F (IPv4) - The F-bit is set if the A-bit is also set and IPv4 is running on the probed interface. Otherwise, the F-bit is clear.\nS (IPv6) - The S-bit is set if the A-bit is also set and IPv6 is running on the probed interface. Otherwise, the S-bit is clear."}
{"_id":"doc-en-rfc8335-7c0281f9a2c4268fb110df18ddb3a50411ea3094cb084a5dc2c5f8987f22e1e5","title":"","text":"E (Ethernet) - The E-bit is set if the A-bit is also set and IPv4 is running on the probed interface. Otherwise, the E-bit is clear."}
{"_id":"doc-en-rfc8335-fa6f1042aef0dcb0dd7ceb1599a8812964c1f9ad419cbc9933cdc1c9427e6478","title":"","text":"All codes mentioned above are assigned on a First Come First Serve (FCFS) basis with a range of 0 -255."}
{"_id":"doc-en-rfc8335-137fb643df92642a8260415d564e8151bdc806fda14303a42dd954dd18ac0216","title":"","text":"The L-bit is set and the ICMP Extension Structure does not identify any local interfaces\nThe L-bit is clear and the address or addresses found in the Interface Identification object appear in neither the IPv4 Address Resolution Protocol (ARP) Table nor the IPv6 Neighbor Cache"}
{"_id":"doc-en-rfc8335-13b2c609b2ca16ad1c389cd5eb9ce49f86fda23854e98fc79174fe82b3be4cee","title":"","text":"If the probed interface resides on a node that is directly connected to the probed node, PROBE reports that the interface is up if it appears in the IPv4 Address Resolution Protocol (ARP) table [RFC0826] or IPv6 Neighbor Cache [RFC4861]. Otherwise, it reports that the table entry does not exist."}
{"_id":"doc-en-rfc8335-8b43291223682309b65b9ff9e0069a9380ce7e797cb747c4f609c925c4560c25","title":"","text":"Code: 0"}
{"_id":"doc-en-rfc8335-65f2ae30b2d748164b297d6006de2366684fc01aea30cbe0fc5a468bea93ebc2","title":"","text":"Identifier: An identifier to aid in matching Extended Echo Replies to Extended Echo Requests. May be zero.\nSequence Number: A sequence number to aid in matching Extended Echo Replies to Extended Echo Requests. May be zero."}
{"_id":"doc-en-rfc8335-7281ae3f11e532c2c0860b927c1caad1f5abf2a7cfd1912686c59e83402cc517","title":"","text":"PROBE MUST NOT leak information about one Virtual Private Network (VPN) into another. Therefore, when a node receives an ICMP Extended Echo Request and the proxy interface is in a different VPN than the probed interface, the node MUST return an ICMP Extended Echo Reply with error code equal to (2) No Such Interface."}
{"_id":"doc-en-rfc8335-9a29c9f06276362b8e5768ab12e0679d8d20f455e0639a213e9f2eb461508e78","title":"","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119]."}
{"_id":"doc-en-rfc8335-95e021aaa783aa756cbec6a1892c728bf04499894cc0916d468512aeee348bfe","title":"","text":"If the Code Field is equal to No Error (0) and the L-bit is clear,\nset the A-bit."}
