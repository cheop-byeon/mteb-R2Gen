{"_id":"q-en-rfc8205-42286724754795cc34952158f8a7fce0f933c44e17000492b3a93508171b7036","text":"Route origin validation using Route Origin Authorizations (ROAs) [RFC6482] [RFC6811] is necessary and complements AS path attestation based on signed updates. Thus, the BGPsec design makes use of the origin validation capability facilitated by the ROAs in the RPKI. In the finalized BGPsec protocol specification [RFC8205], BGPsec is synonymous with cryptographic AS path attestation. Origin validation and BGPsec (path signatures) are the two key pieces of the SIDR WG solution for BGP security."}
{"_id":"q-en-rfc8205-119b6f3e6aca3cfe4145b2724ce1072978d45e8f01970c3ae021a7f7cbc8141e","text":"An originating AS will sign over the Network Layer Reachability Information (NLRI) length, NLRI prefix, its own AS number (ASN), the next ASN, the signature algorithm suite ID, and a signature Expire Time (see Section 3.2) for the update. The update signatures will be carried in a new optional, non-transitive BGP attribute. The finalized BGPsec protocol specification [RFC8205] differs from the above. There is no mention in RFC 8205 of a signature Expire Time field in the BGPsec update. Further, there are some additional details concerning attributes signed by the origin AS that can be found in Figure 8 in Section 4.2 of RFC 8205 [RFC8205]. In particular, the signed data also includes the Address Family Identifier (AFI) as described in RFC 8205. By adding the AFI in the data covered by a signature, a specific security concern was alleviated; see [Mandelberg1] (post to the SIDR WG Mailing List) and the discussion thread that followed on the topic. The AFI is obtained from the MP_REACH_NLRI attribute in the BGPsec update. As stated in Section 4.1 of RFC 8205, a BGPsec update message \"MUST use the MP_REACH_NLRI attribute [RFC4760] to encode the prefix.\""}
{"_id":"q-en-rfc8205-2e0ceda58c42a6b95777c5240cc63a4979afa5cb71c1c63918f9a3779cfc37e0","text":"In the context of BGPsec and throughout this document, an \"upstream AS\" simply refers to an AS that is further along in an AS path (the origin AS being the nearest to a prefix). In principle, an AS that is upstream from an originating AS would digitally sign the combined information, including the NLRI length, NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire Time. There are multiple choices regarding what is signed by an upstream AS, as follows: Method 1: The signature protects the combination of the NLRI length, NLRI prefix, AS path, next ASN, signature algorithm suite ID, and Expire Time, Method 2: The signature protects just the combination of the previous signature (i.e., the signature of the neighbor AS who forwarded the update) and the next ASN, or Method 3: The signature protects everything that was received from the preceding AS plus the next (i.e., target) ASN; thus, ASi signs over the NLRI length, NLRI prefix, signature algorithm suite ID, Expire Time, {ASi, AS(i-1), AS(i-2), ..., AS2, AS1}, AS(i+1) (i.e., the next ASN), and {Sig(i-1), Sig(i-2), ..., Sig2, Sig1}. It was decided that Method 2 will be used. Please see [BGPsec-Initial] for additional protocol details and syntax. The finalized BGPsec protocol specification [RFC8205] essentially uses Method 3 (except for Expire Time). Additional details concerning attributes signed by an upstream AS can be found in Figure 8 in Section 4.2 of RFC 8205 [RFC8205]. The decision to go with Method 3 (with suitable additions to the data signed) was motivated by a security concern that was associated with Method 2; see [Mandelberg2] (post to the SIDR WG Mailing List) and the discussion thread that followed on the topic. Also, there is a strong rationale for the sequence of octets to be hashed (as shown in Figure 8 in Section 4.2 of RFC 8205); this sequencing of data is motivated by implementation efficiency considerations. See [Borchert] (post to the SIDR WG Mailing List) for an explanation."}
{"_id":"q-en-rfc8205-feb4a60a25770e17144cc1203f9ff5fa433fa8827fcff1fbb417a9cfb232463d","text":"Any attributes other than those identified in Sections 2.2 and 2.3 are not signed. Examples of such attributes include the community attribute, the NO-EXPORT attribute, and Local_Pref."}
{"_id":"q-en-rfc8205-bbfd36365adc870b311eb81646b2d4547533037fa16b229dbcf05baf8282c564","text":"The following example describes the expected router actions on receipt of a signed update. Consider an update that was originated by AS1 with NLRI prefix p and has traversed the AS path [AS(i-1) AS(i-2) ... AS2 AS1] before arriving at ASi. Let the Expire Time (inserted by AS1) for the signature in this update be denoted as Te. Let AlgID represent the ID of the signature algorithm suite that is in use. The update is to be processed at ASi and possibly forwarded to AS(i+1). Let the attestations (signatures) inserted by each router in the AS path be denoted by Sig1, Sig2, ..., Sig(i-2), and Sig(i-1) corresponding to AS1, AS2, ..., AS(i-2), and AS(i-1), respectively. The method (Method 2 in Section 2.3) selected for signing requires a receiving router in ASi to perform the following actions: Validate the route origin pair (p, AS1) by performing a ROA match. Verify that Te is greater than the clock time at the router performing these checks. Check Sig1 with inputs {NLRI length, p, AlgID, Te, AS1, AS2}. Check Sig2 with inputs {Sig1, AS3}. Check Sig3 with inputs {Sig2, AS4}. Check Sig(i-2) with inputs {Sig(i-3), AS(i-1)}. Check Sig(i-1) with inputs {Sig(i-2), ASi}. If the route that has been verified is selected as the best path (for prefix p), then generate Sig(i) with inputs {Sig(i-1), AS(i+1)}, and generate an update including Sig(i) to AS(i+1). The above description of BGPsec update validation and forwarding differs in its details from the published BGPsec protocol specification [RFC8205]. Please see Sections 4 and 5 of [RFC8205]."}
{"_id":"q-en-rfc8205-6b477a32e4babbecb23eabc736fd4979aac45f304fcdff94d22de89cf0459379","text":"Prepending will be allowed. Prepending is defined as including more than one instance of the AS number (ASN) of the router that is signing the update. The finalized BGPsec protocol specification [RFC8205] uses a pCount field associated with each AS in the path to indicate the number of prepends for that AS (see Figure 5 in Section 3.1 of [RFC8205])."}
{"_id":"q-en-rfc8205-b567af19480f12396f46102f79b3d63cba0631b6fc6f2227236ab6793b521bf0","text":"Concerning the inclusion of RPKI data in an update, it was decided that only the Subject Key Identifier (SKI) of the router certificate must be included in a signed update. This information identifies the router certificate, based on the SKI generation criteria defined in [RFC6487]."}
{"_id":"q-en-rfc8205-6679c489e5ca272c40c97374cfbab324449531f232c592ea9f22a8d5752e0946","text":"Withdrawals are not signed."}
{"_id":"q-en-rfc8205-8cd0c531a06c1bf2bdbce0b7572f99ab385ef0524eab455efbe9ad91205c5cb6","text":"Only the originating AS inserts a signature Expire Time in the update; all other ASes along an AS path do not insert Expire Times associated with their respective signatures. Further, the originating AS will re-originate a route sufficiently in advance of the Expire Time of its signature so that other ASes along an AS path will typically receive the re-originated route well ahead of the current Expire Time for that route. It is recommended that the duration of the signature Expire Time be on the order of days (preferably), but it may be on the order of hours (about 4 to 8 hours) in some cases on the basis of perceived need for extra protection from replay attacks (i.e., where extra replay protection is perceived to be critical). Each AS should stagger the Expire Time values in the routes it originates. Re-origination will be done, say, at time Tb after origination or the last re-origination, where Tb will equal a certain percentage of the Expire Time, Te (for example, Tb = 0.75 x Te). The percentage will be configurable. Additional guidance can be provided via an operational considerations document later. Further, the actual re-origination time should be jittered with a uniform random distribution over a short interval {Tb1, Tb2} centered at Tb. It is also recommended that a receiving BGPsec router detect that the only attribute change in an announcement (relative to the current best path) is the Expire Time (besides, of course, the signatures). In that case, assuming that the update is found valid, the route processor should not re-announce the route to non-BGPsec peers. (It should sign and re-announce the route to BGPsec speakers only.)  This procedure will reduce BGP chattiness for the non-BGPsec border routers. As mentioned earlier (Section 2.2.2), the Expire Time approach to mitigation of replay attacks and withdrawal suppression was subsequently changed to an approach based on router key rollover [BGPsec-Rollover] [Replay-Protection]."}
{"_id":"q-en-rfc8205-52ecb7e1b6a0bc9aa21d032585e0cfd8be4f50ee1999c0d96d2d3674c237bd96","text":"The idea of sending a new signature Expire Time in a special message (rather than retransmitting the entire update with signatures) was considered. However, the decision was made to not do this. Re-origination to communicate a new signature Expire Time will be done by propagating a normal update message; no special type of message will be required."}
{"_id":"q-en-rfc8205-2b3cab213cc5777bf654921a6ed1fc1275851d5d5a1c0a77ee4a64bfc6eb0394","text":"With regard to the RFD protocol [RFC2439] [JunOS] [CiscoIOS], no differential treatment is required for Expire-Time-triggered (re-beaconed) BGPsec updates. However, it was noted that it would be preferable if these updates did not cause route churn (and perhaps did not even require any RFD-related processing), since they are identical except for the change in the Expire Time value. This can be accomplished by not assigning an RFD penalty to Expire-Time-triggered updates. If the community agrees, this could be accommodated, but a change to the BGP-RFD protocol will be required."}
{"_id":"q-en-rfc8205-f304ab07927d2a44fd315a1e97f6772765a26006384b8e08e0de36a33535087b","text":"Initially, the Elliptic Curve Digital Signature Algorithm (ECDSA) with curve P-256 and SHA-256 will be used for generating BGPsec path signatures. One other signature algorithm, e.g., RSA-2048, will also be used during prototyping and testing. The use of a second signature algorithm is needed to verify the ability of the BGPsec implementations to change from a current algorithm to the next algorithm. The BGPsec cryptographic algorithms document [RFC8208] specifies only the ECDSA with curve P-256 and SHA-256."}
{"_id":"q-en-rfc8205-204b98ac659a5ded3b6d9b709cb0769157c7a6d7f4444fe0c108a0779a63cda5","text":"During the transition period from one algorithm (i.e., the current algorithm) to the next (new) algorithm, the updates will carry two sets of signatures (i.e., two Signature_Blocks), one corresponding to each algorithm. Each Signature_Block will be preceded by its type-length field and an algorithm suite identifier. A BGPsec speaker that has been upgraded to handle the new algorithm should validate both Signature_Blocks and then add its corresponding signature to each Signature_Block for forwarding the update to the next AS. A BGPsec speaker that has not been upgraded to handle the new algorithm will strip off the Signature_Block of the new algorithm and then will forward the update after adding its own signature to the Signature_Block of the current algorithm. It was decided that there will be at most two Signature_Blocks per update. BGPsec path signatures are carried in the Signature_Block, which is an attribute contained in the BGPsec_PATH attribute (see Section 3.2 in [RFC8205]). The algorithm agility scheme described in the published BGPsec protocol specification is consistent with the above; see Section 6.1 of [RFC8205]."}
{"_id":"q-en-rfc8205-e21c730bf5dd0b12667000359d795de0f2c31aa2d2e962d780d9c2f6d27f0472","text":"There is currently weak or no support for the Sequential Aggregate Signature (SAS) approach. Please see Section 4.3.2 for a brief description of what the SAS is and what its pros and cons are."}
{"_id":"q-en-rfc8205-bc39f165cf47c5fb059bcc8c2959f7b117fda9fa5b62ad76208e437e8a0ad999","text":"There is clearly a need to specify a transition path from a current protocol specification to a new version. When changes to the processing of the BGPsec path signatures are required, a new version of BGPsec will be required. Examples of this include changes to the data that is protected by the BGPsec signatures or adoption of a signature algorithm in which the number of signatures in the signature block may not correspond to one signature per AS in the AS path (e.g., aggregate signatures). This protocol-version transition mechanism is analogous to the algorithm transition discussed in Section 4.2. During the transition period from one protocol version (i.e., the current version) to the next (new) version, updates will carry two sets of signatures (i.e., two Signature_Blocks), one corresponding to each version. A protocol-version identifier is associated with each Signature_Block. Hence, each Signature_Block will be preceded by its type-length field and a protocol-version identifier. A BGPsec speaker that has been upgraded to handle the new version should validate both Signature_Blocks and then add its corresponding signature to each Signature_Block for forwarding the update to the next AS. A BGPsec speaker that has not been upgraded to handle the new protocol version will strip off the Signature_Block of the new version and then will forward the update with an attachment of its own signature to the Signature_Block of the current version. The details of protocol extensibility (i.e., transition to a new version of BGPsec) in the published BGPsec protocol specification (see Section 6.3 in [RFC8205]) differ somewhat from the above. In particular, the protocol-version identifier is not part of the BGPsec update. Instead, it is negotiated during the BGPsec capability exchange portion of BGPsec session negotiation."}
{"_id":"q-en-rfc8205-5f5a434f5ffe0169236a3d1ebf375cca3440e4847c5c20ce2af9791ead1fb48f","text":"Within each AS, each individual BGPsec router can have a unique pair of private and public keys [RFC8207]."}
{"_id":"q-en-rfc8205-5aae7e97d773a80f4c0e4112b3c6e877d7da5e42676ac5f6b68e3502e5a6b04f","text":"The router certificate subject name will be the string \"ROUTER\" followed by a decimal representation of a 4-byte ASN followed by the router ID. (Note: The details are specified in Section 3.1 in [RFC8209].)"}
{"_id":"q-en-rfc8205-4f4d9f609018201910300cf30cb77bf7dbd53b9d0045f46e9dd2753bf290ab00","text":"With traditional BGP [RFC4271], an originating BGP router normally packs multiple prefix announcements into one update if the prefixes all share the same BGP attributes. When an upstream BGP router forwards eBGP updates to its peers, it can also pack multiple prefixes (based on the shared AS path and attributes) into one update. The update propagated by the upstream BGP router may include only a subset of the prefixes that were packed in a received update. Each update contains exactly one prefix. This avoids a level of complexity that would otherwise be inevitable if the origin had packed and signed multiple prefixes in an update and an upstream AS decided to propagate an update containing only a subset of the prefixes in that update. BGPsec recommendations regarding packing and repacking may be revisited when optimizations are considered in the future."}
{"_id":"q-en-rfc8205-2ea9f36405987ad1c14210171f8034bfae2fcb3038da809d8b1319b66f46c710","text":"The initial design calls for including exactly one prefix per update; hence, there is only one signature in each secured update (modulo algorithm transition conditions)."}
{"_id":"q-en-rfc8205-60e80dd70023332867e27674b8191266245591e64d26ae57337c1cb7a75656a6","text":"The current BGP update message PDU size is limited to 4096 bytes [RFC4271]. The question was raised as to whether or not BGPsec would require a larger update PDU size. The current thinking is that the maximum PDU size should be increased to 64 KB [BGP-Ext-Msg] so that there is sufficient room to accommodate two Signature_Blocks (i.e., one block with a current algorithm and another block with a new signature algorithm during a future transition period) for long AS paths. RFC 8205 states the following: \"All BGPsec UPDATE messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed.\""}
{"_id":"q-en-rfc8205-aa538f31373d53a25a584f292eb498fd65562184496843c73c94a4f226d81e98","text":"If a BGPsec-capable router needs to temporarily suspend\/defer signing and\/or validation of BGPsec updates during periods of route processor overload, the router may do so even though such suspension\/deferment is not desirable; the specification does not forbid it. Following any temporary suspension, the router should subsequently send signed updates corresponding to the updates for which validation and signing were skipped. The router also may choose to skip only validation but still sign and forward updates during periods of congestion."}
{"_id":"q-en-rfc8205-109b5b8d556f094561b6ca3d8900fd861e18dfe8117fbee458a077ae0daad348","text":"No attempt will be made in the BGPsec design to prevent downgrade attacks, i.e., a BGPsec-capable router sending unsigned updates when it is capable of sending signed updates."}
{"_id":"q-en-rfc8205-35843b26460f4b1c9c8845be2d2451fb84bbea8b0538f95365f37300cd83d9e4","text":"It was decided that during capability negotiation, the address family for which the BGPsec speaker is advertising support for BGPsec will be shared using the Address Family Identifier (AFI). Initially, two address families would be included, namely, IPv4 and IPv6. BGPsec for use with other address families may be specified in the future. Simultaneous use of the two (i.e., IPv4 and IPv6) address families for the same BGPsec session will require that the BGPsec speaker include two instances of this capability (one for each address family) during BGPsec capability negotiation."}
{"_id":"q-en-rfc8205-2846db7874ed98e6b97c944eb7464dc200ee24412c20399643099acc15c2a5e1","text":"BGPsec will be incrementally deployable. BGPsec routers will use capability negotiation to agree to run BGPsec between them. If a BGPsec router's peer does not agree to run BGPsec, then the BGPsec router will run only traditional BGP with that peer, i.e., it will not send BGPsec (i.e., signed) updates to the peer. See Section 7.9 of [RFC8205] for a discussion of incremental partial-deployment considerations. Also, Section 6 of [RFC8207] describes how edge sites (stub ASes) can sign updates that they originate but can receive only unsigned updates. This facilitates a less expensive upgrade to BGPsec in resource-limited stub ASes and expedites incremental deployment."}
{"_id":"q-en-rfc8205-b7d099c7e5e83d7e7303678f03cedab5bad8aab5ee323b2528386e0caad56966","text":"\"Partial path signing\" means that a BGPsec AS can be permitted to sign an update that was received unsigned from a downstream neighbor. That is, the AS would add its ASN to the AS path and sign the (previously unsigned) update to other neighboring (upstream) BGPsec ASes. It was decided that partial path signing in BGPsec will not be allowed. A BGPsec update must be fully signed, i.e., each AS in the AS path must sign the update. So, in a signed update, there must be a signature corresponding to each AS in the AS path."}
{"_id":"q-en-rfc8205-bbcb5f75a86e53e86a9a5f4f6bc0bf696b743a461f27ad8bc13e4a15d94706a9","text":"The protocol permits each pair of BGPsec-capable ASes to asymmetrically negotiate the use of BGPsec. Thus, a stub AS (or downstream customer AS) can agree to perform BGPsec only in the transmit direction and speak traditional BGP in the receive direction. In this arrangement, the ISP's (upstream) AS will not send signed updates to this stub or customer AS. Thus, the stub AS can avoid the need to hardware-upgrade its route processor and RIB memory to support BGPsec update validation."}
{"_id":"q-en-rfc8205-c5dd5eb541e8a4d31f36b0701d0311e0e1ba357ffa4f9f0124b0576294d10069","text":"An ISP's AS (or upstream AS) can proxy-sign BGP announcements for a customer (downstream) AS, provided that the customer AS obtains an RPKI (CA) certificate, issues a router certificate under that CA certificate, and passes on the private key for that certificate to its upstream provider. That ISP (i.e., the second-hop AS) would insert a signature on behalf of the customer AS using the private key provided by the customer AS. This is a private arrangement between the two ASes and is invisible to other ASes. Thus, this arrangement is not part of the BGPsec protocol specification. BGPsec will not make any special provisions for an ISP to use its own private key to proxy-sign updates for a customer's AS. This type of proxy signing is considered a bad idea."}
{"_id":"q-en-rfc8205-312319ba082e147aab2b32d2474c03720871943271bef9417613ff7b32137773","text":"No problems are anticipated when BGPsec-capable ASes have multiple peering sessions between them (between distinct routers)."}
{"_id":"q-en-rfc8205-33703337f183ba31c666c8d0c89223ad0b21db97cfcc4444ae41e38d11ebcdc9","text":"In traditional BGP, the idea of peer groups is used in BGP routers to save on processing when generating and sending updates. Multiple peers for whom the same policies apply can be organized into peer groups. A peer group can typically have tens of ASes (and maybe as many as 300) in it. It was decided that BGPsec updates are generated to target unique AS peers, so there is no support for peer groups in BGPsec."}
{"_id":"q-en-rfc8205-e4a9a15b3218709162e65b54c88d28cb19380cf68cb65e454c13d648a1345394","text":"The need to provide protection in BGPsec for the community attribute was discussed. Community attribute(s) will not be included in any message that is signed in BGPsec."}
{"_id":"q-en-rfc8205-310aa25e3da4615b1bc46060b911f0e98c600a7f578c2606600fcac2310944b3","text":"An iBGP speaker that is also an eBGP speaker and that executes BGPsec will by necessity carry BGPsec data and perform eBGPsec functions. Confederations are eBGP clouds for administrative purposes and contain multiple Member-ASes. A Member-AS is not required to sign updates sent to another Member-AS within the same confederation. However, if BGPsec signing is applied in eBGP within a confederation, i.e., each Member-AS signs to the next Member-AS in the path within the confederation, then upon egress from the confederation, the Member-AS at the boundary must remove any and all signatures applied within the confederation. The Member-AS at the boundary of the confederation will sign the update to an eBGPsec peer using the public ASN of the confederation and its private key. The BGPsec specification will not specify how to perform this process. In RFC 8205, signing a BGPsec update between Member-ASes within a confederation is required if the update were to propagate with signatures within the confederation. A Confed_Segment flag exists in each Secure_Path segment, and when set, it indicates that the corresponding signature belongs to a Member-AS. At the confederation boundary, all signatures with Confed_Segment flags set are removed from the update. RFC 8205 specifies in detail how all of this is done. Please see Figure 5 in Section 3.1 of [RFC8205], as well as Section 4.3 of [RFC8205], for details."}
{"_id":"q-en-rfc8205-a1ddb6724f2b894851386689c0ed5e09cd6177939ce28733bfc48782dcae0445","text":"[BGPsec-Initial] made no special provisions to accommodate route servers in Internet Exchange Points (IXPs).  The above decision subsequently changed: RFC 8205 allows the accommodation of IXPs, especially for transparent route servers. The pCount (AS prepend count) field is set to zero for transparent route servers (see Section 4.2 of [RFC8205]). The operational guidance for preventing the misuse of pCount=0 is given in Section 7.2 of RFC 8205. Also, see Section 8.4 of RFC 8205 for a discussion of security considerations concerning pCount=0."}
{"_id":"q-en-rfc8205-cb46cac261416c9c53bd1bbf622b337df887e079154e9442a1df91545540c3a7","text":"Proxy aggregation (i.e., the use of AS_SETs in the AS path) will not be supported in BGPsec. There is no provision in BGPsec to sign an update when an AS_SET is part of an AS path. If a BGPsec-capable router receives an update that contains an AS_SET and also finds that the update is signed, then the router will consider the update malformed (i.e., a protocol error). Section 5.2 of RFC 8205 specifies that a receiving BGPsec router \"MUST handle any syntactical or protocol errors in the BGPsec_PATH attribute by using the 'treat-as-withdraw' approach as defined in RFC 7606 [RFC7606].\""}
{"_id":"q-en-rfc8205-39093d85dc35ba906255d2a778dd6a30f968d6e3909d0d3ea63e867da6fbda49","text":"Not all (currently deployed) BGP speakers are capable of dealing with 4-byte ASNs [RFC6793]. The standard mechanism used to accommodate such speakers requires a peer AS to translate each 4-byte ASN in the AS path to a reserved 2-byte ASN (23456) before forwarding the update. This mechanism is incompatible with the use of BGPsec, since the ASN translation is equivalent to a route modification attack and will cause signatures corresponding to the translated 4-byte ASNs to fail validation. BGP speakers that are BGPsec capable are required to process 4-byte ASNs."}
{"_id":"q-en-rfc8205-e4ed2aedd3e370e6ff83faa7fa81f71b2f1de56326c8abf01edff34b1afc9631","text":"It is natural to ask in what sequence a receiver must perform BGPsec update validation so that if a failure were to occur (i.e., the update was determined to be invalid) the processor would have spent the least amount of processing or other resources. There was agreement that the following sequence of receiver operations is quite meaningful; the following steps are included in [BGPsec-Initial]. However, the ordering of these validation-processing steps is not a normative part of the BGPsec specification. Verify that the signed update is syntactically correct. For example, check to see if the number of signatures matches the number of ASes in the AS path (after duly accounting for AS prepending). Verify that the origin AS is authorized to advertise the prefix in question. This verification is based on data from ROAs and does not require any cryptographic operations. Verify that the advertisement has not yet expired. Verify that the target ASN in the signature data matches the ASN of the router that is processing the advertisement. Note that the target-ASN check is also a non-cryptographic operation and is fast. Validate the signature data starting from the most recent AS to the origin. Locate the public key for the router from which the advertisement was received, using the SKI from the signature data. Hash the data covered by the signature algorithm. Invoke the signature validation algorithm on the following three inputs: the locally computed hash, the received signature, and the public key. There will be one output: valid or invalid. Repeat steps 5 and 6 for each preceding signature in the Signature_Block until (a) the signature data for the origin AS is encountered and processed or (b) either of these steps fails. Significant refinements to the above list occurred in the progress towards RFC 8205. The detailed syntactic-error checklist is presented and explained in Section 5.2 of [RFC8205]. Also, a logical sequence of steps to be followed in the validation of Signature_Blocks is described in Section 5.2 of [RFC8205]."}
{"_id":"q-en-rfc8205-30e5fb93b9d386109bffe5c0bee1ec98155cec0dab6d17887ec7cd976e4a83fd","text":"A BGPsec router should sign and forward a signed update to upstream peers if it selected the update as the best path, regardless of whether the update passed or failed validation (at this router)."}
{"_id":"q-en-rfc8205-31c2f96cdcd55a016da9962ce74c9646bc6fbf507edc9c8e0bcce2216522d18d","text":"Enumeration of error conditions and the recommendations for how to react to them are still under discussion. TBD. Also, please see Section 8.5 for the decision and discussion specifically related to syntactic errors in signatures. Section 5.2 of RFC 8205 describes the detection of syntactic and protocol errors in BGPsec updates as well as how the updates with such errors are to be handled."}
{"_id":"q-en-rfc8205-9ba086bba097e0800efb9ad00a5e6cb2314948a9580a20a2b648b90c9a3297d3","text":"An update may come in unsigned from an eBGP peer or internally (e.g., as an iBGP update). In the latter case, the route is being originated from within the AS in question. If an unsigned route is received from an eBGP peer and if it is selected, then the route will be forwarded unsigned to other eBGP peers -- even BGPsec-capable peers. If the route originated in this AS (IGP or iBGP) and is unsigned, then it should be signed and announced to external BGPsec-capable peers."}
{"_id":"q-en-rfc8205-35ade60e646cfb52fbfe967a724b1423aaead77e951e6fcfff52ba1cc72ba1b6","text":"The contents of this subsection (i.e., Section 8.5) differ substantially from the recommendations in RFC 8205 regarding the handling of syntactic errors and protocol errors. Hence, the reader may skip this subsection and instead read Section 5.2 of [RFC8205]. This subsection (Section 8.5) is kept here for the sake of archival value concerning design discussions. Different types of error conditions were discussed in Section 8.3. Here, the focus is only on syntactic-error conditions in signatures. If there are syntactic-error conditions such as (A) AS_SET and BGPsec_PATH both appearing in an update, (B) the number of signatures not matching the number of ASes (after accounting for any AS prepending), or (C) a parsing issue occurring with the BGPsec_PATH attribute, then the update (with the signatures stripped) will still be considered in the best-path-selection algorithm. (**Note: This is not true in RFC 8205**.)  If the update is selected as the best path, then the update will be propagated unsigned. The error condition will be logged locally. A BGPsec router will follow whatever the current IETF (IDR WG) recommendations are for notifying a peer that it is sending malformed messages. In the case when there are two Signature_Blocks in an update, and one or more syntactic errors are found to occur within one of them but the other one is free of any syntactic errors, then the update will still be considered in the best-path-selection algorithm after the syntactically bad Signature_Block has been removed. (**Note: This is not true in RFC 8205**.)  If the update is selected as the best path, then the update will be propagated with only one (i.e., the error-free) Signature_Block. The error condition will be logged locally."}
{"_id":"q-en-rfc8205-a9c95893faac9a56a3a76529e762abddcc15f6bedd1effbe67e586333170c1b9","text":"Various validation conditions are possible that can be mapped to validation states for possible input to the BGPsec decision process. These conditions can be related to whether an update is signed, Expire Time is checked, route origin validation is checked against a ROA, signature verification passed, etc. It was decided that BGPsec validation outcomes will be mapped to one of only two validation states: (1) Valid -- passed all validation checks (i.e., Expire Time check, route origin and Signature_Block validation) and (2) Invalid -- all other possibilities. \"Invalid\" would include situations such as the following: Due to a lack of RPKI data or insufficient RPKI data, validation was not performed. The signature Expire Time check failed. Route origin validation failed. Signature checks were performed, and one or more of them failed. Expire Time is obsolete (see the notes in Sections 2.2.1 and 2.2.2). RFC 8205 uses the states \"Valid\" and \"Not Valid\", but only with respect to AS path validation (i.e., not including the result of origin validation); see Section 5.1 of [RFC8205]. \"Not Valid\" includes all conditions in which path validation was attempted but a \"Valid\" result could not be reached. (Note: Path validation is not attempted in the case of syntactic or protocol errors in a BGPsec update; see Section 5.2 of [RFC8205].)  Each Relying Party (RP) is expected to devise its own policy to suitably factor the results of origin validation [RFC6811] and path validation [RFC8205] into its path-selection decision."}
{"_id":"q-en-rfc8205-098b1914e7dcb2311c29f3abbe66e727c1afbf831b17b05f4eb018d4d9b7cff4","text":"BGPsec validation need be performed only at eBGP edges. The validation status of a BGP signed\/unsigned update may be conveyed via iBGP from an ingress edge router to an egress edge router. Local policy in the AS will determine how the validation status is conveyed internally, using various preexisting mechanisms, e.g., setting a BGP community, or modifying a metric value such as Local_Pref or MED. A signed update that cannot be validated (except those with syntax errors) should be forwarded with signatures from the ingress router to the egress router, where it is signed when propagated towards other eBGPsec speakers in neighboring ASes. Based entirely on local policy settings, an egress router may trust the validation status conveyed by an ingress router, or it may perform its own validation. The latter approach may be used at an operator's discretion, under circumstances when RPKI skew is known to happen at different routers within an AS.  An extended community for carrying the origin validation state in iBGP has been specified in RFC 8097 [RFC8097]."}
{"_id":"q-en-rfc8205-ded6ee6aeb85fca04f69a128f99367871aa05964dd1e441f554566b637510198","text":"BGP Graceful Restart (BGP-GR) [RFC4724] is a mechanism currently used to facilitate nonstop packet forwarding when the control plane is recovering from a fault (i.e., the BGP session is restarted) but the data plane is functioning. Two questions were raised: Are there any special concerns about how BGP-GR works while BGPsec is operational? Also, what happens if the BGP router operation transitions from traditional BGP operation to BGP-GR to BGPsec, in that order? No decision was made relative to this issue (at the time that [BGPsec-Initial] was written). See Section 7.7 of [RFC8205] for comments concerning the operation of BGP-GR with BGPsec. They are consistent with the discussion below."}
{"_id":"q-en-rfc8205-a68a89f9ca782d300706ef58b2e9c8515e362a86770661924ec3b7e6f706d5fc","text":"Work related to this topic is still in progress."}
{"_id":"q-en-rfc8205-9ac49b4adb47d7692370e3f0e88be8fb68131a7f2e210ab143dfe4c6feecb6e7","text":"Update signature validation and signing can be outsourced to an off-board server or processor."}
{"_id":"q-en-rfc8205-323b1a85358284f195bf946c6538bd6e1f0331b3e3542a73fa980b1a57fc357e","text":"It is assumed that BGPsec routers (Provider Edge (PE) routers and route reflectors) will require significantly upgraded hardware -- much more memory for RIBs and hardware cryptographic assistance. However, stub ASes would not need to make such upgrades because they can negotiate asymmetric BGPsec capability with their upstream ASes, i.e., they sign updates to the upstream AS but receive only unsigned BGP updates (see Section 6.5)."}
{"_id":"q-en-rfc8205-614647ef5620fa22dd72e01dd606e6d67390ea8ad900da98a2068eb61124c5c4","text":"The idea of signed BGP peering registrations (for the purpose of path validation) was rejected."}
