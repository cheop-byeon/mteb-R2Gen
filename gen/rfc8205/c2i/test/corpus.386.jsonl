{"_id":"doc-en-sidr-1Pm--Ef10uR7eOI_JVDDsMdsN5A","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nHi, Alvaro, A new version (-05) has been submitted for you to review. The draft is updated based on the comments from you and Sriram. And it places a more strict limit on the slurmVersion JOSN member compared to the previous version by saying: “Future additions to the specifications in this document MUST use an incremented value for the “slurmVersion” member.\" Di 在 2018年1月31日，23:39，Alvaro Retana <aretana.ietf@gmail.com> 写道： Di: Hi! Thanks for your prompt reply. I look forward to an updated draft. Alvaro. Hi, Alvaro, Thanks for your comments. Please see my responses in lines. 在 2018年1月30日，02:21，Alvaro Retana <aretana.ietf@gmail.com> 写道： Dear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? We authors think MUST is better than SHOULD. And we would like to update section 3.1 saying: \"This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST not be used in SLURM Files and additional top-level members MUST be defined in RFCs that update this document. Relying parties MUST ignore unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.” Here is the consideration: The current document describes local exceptions with regards to ROAs and Router Certificates, which are significant to local control of routing. The thought here was that we would leave an option for future other ’top-level’ elements to describe local exceptions with regards to other (future) RPKI objects as long as they have fundamental effect in routing control , while maintaining backward compatibility. But this is not explicit in the document as written. The risk here, as written, is that implementations can just add stuff at will for their own purpose and we can end up with the same member name being re-used. M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. Yes. You are making sense here. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. Agreed. We are going to add: \"Yet the mechanism to update SLURM file to guarantee authentication and integrity is out of the scope of this document. \" Besides, we need to change ‘source’ to ‘sources’ :-) M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Agreed. Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it’s out of scope, then there shouldn't be any Normative language. s\/MAY\/may Agreed. P2. “Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". We authors are going to change 4.1 and 4.2 to say “Locally Added Assertions” because we refer to the elements. The lower case “locally adding assertions” in 3.2 is fine, because it describes an action. Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Agreed. Di _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-y57fFCkn0p5knDBS_22pVOjKUNc","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nDear Alvaro, all, I have an addition to Di’s reply to the comments on section 3.1 (The use of JSON). Sorry for the confusion on this. I was the author insisting on this, but I have come to realise that there is no good cause for treating top-level JSON members different from lower level members. The initial idea was that we could have backwards compatible future additions to this spec. But as it is, such updates would most likely require changes deep in the structure as well. Therefore I now propose that the JSON structure is locked down: This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST NOT be used in SLURM Files. Relying Parties MUST consider any deviations from the specification an error. Future additions to the specifications in this document MUST use an incremented value for the “slurmVersion” member. We will post an updated draft shortly. Tim On 31 Jan 2018, at 16:39, Alvaro Retana <aretana.ietf@gmail.com> wrote: Di: Hi! Thanks for your prompt reply. I look forward to an updated draft. Alvaro. Hi, Alvaro, Thanks for your comments. Please see my responses in lines. 在 2018年1月30日，02:21，Alvaro Retana <aretana.ietf@gmail.com> 写道： Dear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? We authors think MUST is better than SHOULD. And we would like to update section 3.1 saying: \"This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST not be used in SLURM Files and additional top-level members MUST be defined in RFCs that update this document. Relying parties MUST ignore unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.” Here is the consideration: The current document describes local exceptions with regards to ROAs and Router Certificates, which are significant to local control of routing. The thought here was that we would leave an option for future other ’top-level’ elements to describe local exceptions with regards to other (future) RPKI objects as long as they have fundamental effect in routing control , while maintaining backward compatibility. But this is not explicit in the document as written. The risk here, as written, is that implementations can just add stuff at will for their own purpose and we can end up with the same member name being re-used. M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. Yes. You are making sense here. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. Agreed. We are going to add: \"Yet the mechanism to update SLURM file to guarantee authentication and integrity is out of the scope of this document. \" Besides, we need to change ‘source’ to ‘sources’ :-) M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Agreed. Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it’s out of scope, then there shouldn't be any Normative language. s\/MAY\/may Agreed. P2. “Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". We authors are going to change 4.1 and 4.2 to say “Locally Added Assertions” because we refer to the elements. The lower case “locally adding assertions” in 3.2 is fine, because it describes an action. Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Agreed. Di _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-VpfB7B0e8cbplRfU5EzwisZUap0","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nDi: Hi! Thanks for your prompt reply. I look forward to an updated draft. Alvaro. On January 31, 2018 at 10:18:57 AM, Di Ma (madi@zdns.cn) wrote: Hi, Alvaro, Thanks for your comments. Please see my responses in lines. 在 2018年1月30日，02:21，Alvaro Retana <aretana.ietf@gmail.com> 写道： Dear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? We authors think MUST is better than SHOULD. And we would like to update section 3.1 saying: \"This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST not be used in SLURM Files and additional top-level members MUST be defined in RFCs that update this document. Relying parties MUST ignore unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.” Here is the consideration: The current document describes local exceptions with regards to ROAs and Router Certificates, which are significant to local control of routing. The thought here was that we would leave an option for future other ’top-level’ elements to describe local exceptions with regards to other (future) RPKI objects as long as they have fundamental effect in routing control , while maintaining backward compatibility. But this is not explicit in the document as written. The risk here, as written, is that implementations can just add stuff at will for their own purpose and we can end up with the same member name being re-used. M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. Yes. You are making sense here. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. Agreed. We are going to add: \"Yet the mechanism to update SLURM file to guarantee authentication and integrity is out of the scope of this document. \" Besides, we need to change ‘source’ to ‘sources’ :-) M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Agreed. Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it’s out of scope, then there shouldn't be any Normative language. s\/MAY\/may Agreed. P2. “Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". We authors are going to change 4.1 and 4.2 to say “Locally Added Assertions” because we refer to the elements. The lower case “locally adding assertions” in 3.2 is fine, because it describes an action. Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Agreed. Di Di:Hi!Thanks for your prompt reply. I look forward to an updated draft.Alvaro. Hi, Alvaro, Thanks for your comments. Please see my responses in lines. 在 2018年1月30日，02:21，Alvaro Retana <aretana.ietf@gmail.com> 写道： Dear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? We authors think MUST is better than SHOULD. And we would like to update section 3.1 saying: \"This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST not be used in SLURM Files and additional top-level members MUST be defined in RFCs that update this document. Relying parties MUST ignore unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.” Here is the consideration: The current document describes local exceptions with regards to ROAs and Router Certificates, which are significant to local control of routing. The thought here was that we would leave an option for future other ’top-level’ elements to describe local exceptions with regards to other (future) RPKI objects as long as they have fundamental effect in routing control , while maintaining backward compatibility. But this is not explicit in the document as written. The risk here, as written, is that implementations can just add stuff at will for their own purpose and we can end up with the same member name being re-used. M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. Yes. You are making sense here. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. Agreed. We are going to add: \"Yet the mechanism to update SLURM file to guarantee authentication and integrity is out of the scope of this document. \" Besides, we need to change ‘source’ to ‘sources’ :-) M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Agreed. Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it’s out of scope, then there shouldn't be any Normative language. s\/MAY\/may Agreed. P2. “Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". We authors are going to change 4.1 and 4.2 to say “Locally Added Assertions” because we refer to the elements. The lower case “locally adding assertions” in 3.2 is fine, because it describes an action. Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Agreed. Di"}
{"_id":"doc-en-sidr-PrUQhvaQni4t4R_EM9rbo4di_xE","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nSriram, Thanks again for your comments. 在 2018年1月30日，04:36，Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> 写道： David, Di, Tim: These are minor comments in alignment with Alvaro’s. Alvaro wrote: M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt With regard to updating the references, I noticed that the draft references [I-D.ietf-sidr-bgpsec-overview] in two places where it should reference BGPsec Protocol Specification [RFC 8205]. For example, on page 3: (Validation of the origin of a route is described in [RFC6483], and validation of the path of a route is described in [I-D.ietf-sidr-bgpsec-overview].) For “validation of the path of a route” the pointer should be Section 5 of RFC 8205. Yes. We should make the change. AFAIK, [I-D.ietf-sidr-bgpsec-overview] is expired and there are no plans to publish it. I would also suggest that both RFCs 6483 and 6811 can be referenced when talking about “Validation of the origin of a route.” RFC 6811 is Standards Track while 6483 is Informational. Agreed. RFC 6811 is more competent to talk about Validation of the origin of a route. Di Thanks. Sriram _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-N05MoMaupJ3cJAwmnJx5efeVxLM","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nHi, Alvaro, Thanks for your comments. Please see my responses in lines. 在 2018年1月30日，02:21，Alvaro Retana <aretana.ietf@gmail.com> 写道： Dear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? We authors think MUST is better than SHOULD. And we would like to update section 3.1 saying: \"This document describes responses in the JSON [RFC7159] format. JSON members that are not defined here MUST not be used in SLURM Files and additional top-level members MUST be defined in RFCs that update this document. Relying parties MUST ignore unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.” Here is the consideration: The current document describes local exceptions with regards to ROAs and Router Certificates, which are significant to local control of routing. The thought here was that we would leave an option for future other ’top-level’ elements to describe local exceptions with regards to other (future) RPKI objects as long as they have fundamental effect in routing control , while maintaining backward compatibility. But this is not explicit in the document as written. The risk here, as written, is that implementations can just add stuff at will for their own purpose and we can end up with the same member name being re-used. M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. Yes. You are making sense here. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. Agreed. We are going to add: \"Yet the mechanism to update SLURM file to guarantee authentication and integrity is out of the scope of this document. \" Besides, we need to change ‘source’ to ‘sources’ :-) M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Agreed. Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it’s out of scope, then there shouldn't be any Normative language. s\/MAY\/may Agreed. P2. “Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". We authors are going to change 4.1 and 4.2 to say “Locally Added Assertions” because we refer to the elements. The lower case “locally adding assertions” in 3.2 is fine, because it describes an action. Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Agreed. Di"}
{"_id":"doc-en-sidr-88k01MPbpSz43dpBG5NH5X-9sPU","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nSriram, Thanks for your comments. We authors will update the draft, in response to your suggestions and comments from the AD. Di 在 2018年1月30日，04:36，Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> 写道： David, Di, Tim: These are minor comments in alignment with Alvaro’s. Alvaro wrote: M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt With regard to updating the references, I noticed that the draft references [I-D.ietf-sidr-bgpsec-overview] in two places where it should reference BGPsec Protocol Specification [RFC 8205]. For example, on page 3: (Validation of the origin of a route is described in [RFC6483], and validation of the path of a route is described in [I-D.ietf-sidr-bgpsec-overview].) For “validation of the path of a route” the pointer should be Section 5 of RFC 8205. AFAIK, [I-D.ietf-sidr-bgpsec-overview] is expired and there are no plans to publish it. I would also suggest that both RFCs 6483 and 6811 can be referenced when talking about “Validation of the origin of a route.” RFC 6811 is Standards Track while 6483 is Informational. Thanks. Sriram _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-ZMhdrnn2tpJsmPUkBMxQ_BBo7Bg","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-slurm-04\nDavid, Di, Tim: These are minor comments in alignment with Alvaro’s. Alvaro wrote: M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt<https:\/\/na01.safelinks.protection.outlook.com\/?url=https%3A%2F%2Ftools.ietf.org%2Fidnits%3Furl%3Dhttps%3A%2F%2Ftools.ietf.org%2Fid%2Fdraft-ietf-sidr-slurm-04.txt&data=02%7C01%7Ckotikalapudi.sriram%40nist.gov%7Cc59432d1b20b4ceb46a508d567451e8e%7C2ab5d82fd8fa4797a93e054655c61dec%7C1%7C0%7C636528468933957141&sdata=5QbjZdDuSy9CgDHN4gKAPsJ5EpRwJbFIVpn6Lh7d7D0%3D&reserved=0> With regard to updating the references, I noticed that the draft references [I-D.ietf-sidr-bgpsec-overview] in two places where it should reference BGPsec Protocol Specification [RFC 8205]. For example, on page 3: (Validation of the origin of a route is described in [RFC6483], and validation of the path of a route is described in [I-D.ietf-sidr-bgpsec-overview].) For “validation of the path of a route” the pointer should be Section 5 of RFC 8205. AFAIK, [I-D.ietf-sidr-bgpsec-overview] is expired and there are no plans to publish it. I would also suggest that both RFCs 6483 and 6811 can be referenced when talking about “Validation of the origin of a route.” RFC 6811 is Standards Track while 6483 is Informational. Thanks. Sriram David, Di, Tim: These are minor comments in alignment with Alvaro’s. Alvaro wrote: M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt With regard to updating the references, I noticed that the draft references [I-D.ietf-sidr-bgpsec-overview] in two places where it should reference BGPsec Protocol Specification [RFC 8205]. For example, on page 3: (Validation of the origin of a route is described in [RFC6483], and validation of the path of a route is described in [I-D.ietf-sidr-bgpsec-overview].) For “validation of the path of a route” the pointer should be Section 5 of RFC 8205. AFAIK, [I-D.ietf-sidr-bgpsec-overview] is expired and there are no plans to publish it. I would also suggest that both RFCs 6483 and 6811 can be referenced when talking about “Validation of the origin of a route.” RFC 6811 is Standards Track while 6483 is Informational. Thanks. Sriram"}
{"_id":"doc-en-sidr-K7y1URe1tkh78vjHhZHAIJJ6L4M","title":"","text":"[sidr] AD Review of draft-ietf-sidr-slurm-04\nDear authors: I just finished reading this document. I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483. Thanks! Alvaro. Major: M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST? M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST. M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document. M4. References: M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative. M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159. M4.3. [minor] Please update the references according to the Nits [1]. [1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Minor: P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it's out of scope, then there shouldn't be any Normative language. s\/MAY\/may P2. \"Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\". Nits: N1. s\/control make use of RPKI data\/control use of RPKI data Dear authors:I just finished reading this document.I have some comments (below) that should be easy to address — please take a look. I need you to address the References before I start the IETF Last Call because of the DownRef to rfc6483.Thanks!Alvaro.Major:M1. Section 3.1: I'm not sure what the Normative result is form this piece of text: \"JSON members that are not defined here MUST not be used in SLURM Files, however Relying Parties SHOULD ignore such unrecognized JSON members at the top level, while any deviations from the specification at lower levels MUST be considered an error.\" (s\/MUST not\/MUST NOT) If the not defined members MUST NOT be used, when would the RPs not ignore (or even better, treat as errors) them? IOW, why use SHOULD instead of MUST?M2. Section 4.2: \"Before an RP configures SLURM files from different source it MUST make sure there is no internal conflict among the INR assertions in these SLURM files. To do so, the RP SHOULD check the entries of SLURM file...\" I think there's a Normative mismatch: \"MUST make sure...no...conflict\" vs \"SHOULD check the entries\"; the SHOULD leaves the door open to not always checking -- are there cases when the entries wouldn't be checked *and* the MUST can still be guaranteed? It seems to me like both keywords should be MUST.M3. Section 6: \"...but if the RP updates its SLURM file over the network, it MUST verify the authenticity and integrity of the updated SLURM file.\" Please indicate that the mechanism to update files, and the authentication\/integrity verification are outside the scope of this document.M4. References:M4.1. s\/I-D.ietf-sidr-bgpsec-overview\/rfc8205 ...and should be Normative.M4.2. I believe the following references should also be Normative: ietf-sidr-rpki-rtr-rfc6810-bis\/rfc8210, rfc6483, rfc6810, rfc6811 and rfc7159.M4.3. [minor] Please update the references according to the Nits [1].[1] https:\/\/tools.ietf.org\/idnits?url=https:\/\/tools.ietf.org\/id\/draft-ietf-sidr-slurm-04.txt Minor:P1. \"Relying party software MAY modify other forms of output in comparable ways, but that is outside the scope of this document.\" If it's out of scope, then there shouldn't be any Normative language. s\/MAY\/mayP2. \"Locally Added Assertions\" are sometimes called \"Locally Adding Assertions\".Nits:N1. s\/control make use of RPKI data\/control use of RPKI data"}
{"_id":"doc-en-sidr-kB71ZxVeZdZgGwU8frbis_J_uV8","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017\n - Oct 16, 2017\nok terrific, On Thu, Oct 19, 2017 at 7:46 AM, Sriram, Kotikalapudi (Fed) < kotikalapudi.sriram@nist.gov> wrote: Chris, I think you should wait for Sean to upload version-14. He sent it to me and Oliver but not uploaded yet. Sriram ________________________________________ From: Christopher Morrow <christopher.morrow@gmail.com> Sent: Wednesday, October 18, 2017 3:07 PM To: Sriram, Kotikalapudi (Fed) Cc: Sean Turner; Borchert, Oliver (Fed); sidr@ietf.org; sidr-chairs@ietf.org; sidr-ads@ietf.org; draft-ietf-sidr-rtr-keying@ ietf.org Subject: Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017 - Oct 16, 2017 great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? On Tue, Oct 17, 2017 at 4:42 PM, Sriram, Kotikalapudi (Fed) < kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram ok terrific,On Thu, Oct 19, 2017 at 7:46 AM, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> wrote:Chris, I think you should wait for Sean to upload version-14. He sent it to me and Oliver but not uploaded yet. Sriram ________________________________________ From: Christopher Morrow <christopher.morrow@gmail.com> Sent: Wednesday, October 18, 2017 3:07 PM To: Sriram, Kotikalapudi (Fed) Cc: Sean Turner; Borchert, Oliver (Fed); sidr@ietf.org; sidr-chairs@ietf.org; sidr-ads@ietf.org; draft-ietf-sidr-rtr-keying@ietf.org Subject: Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017 - Oct 16, 2017 great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram"}
{"_id":"doc-en-sidr-C7Sz9leQmpJtnSssn1ocCXjyMKc","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017\n - Oct 16, 2017\nChris, I think you should wait for Sean to upload version-14. He sent it to me and Oliver but not uploaded yet. Sriram ________________________________________ From: Christopher Morrow <christopher.morrow@gmail.com> Sent: Wednesday, October 18, 2017 3:07 PM To: Sriram, Kotikalapudi (Fed) Cc: Sean Turner; Borchert, Oliver (Fed); sidr@ietf.org; sidr-chairs@ietf.org; sidr-ads@ietf.org; draft-ietf-sidr-rtr-keying@ietf.org Subject: Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017 - Oct 16, 2017 great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram"}
{"_id":"doc-en-sidr-mXH5PSbqH3_W0wEOHka4u82MJEU","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017\n - Oct 16, 2017\nYes, fine with me, ship it, Oliver From: Christopher Morrow [mailto:christopher.morrow@gmail.com] Sent: Wednesday, October 18, 2017 3:07 PM To: Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> Cc: Sean Turner <sean@sn3rd.com>; Borchert, Oliver (Fed) <oliver.borchert@nist.gov>; sidr@ietf.org; sidr-chairs@ietf.org; sidr-ads@ietf.org; draft-ietf-sidr-rtr-keying@ietf.org Subject: Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017 - Oct 16, 2017 great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? On Tue, Oct 17, 2017 at 4:42 PM, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram Yes, fine with me, ship it, Oliver From: Christopher Morrow [mailto:christopher.morrow@gmail.com] Sent: Wednesday, October 18, 2017 3:07 PM To: Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> Cc: Sean Turner <sean@sn3rd.com>; Borchert, Oliver (Fed) <oliver.borchert@nist.gov>; sidr@ietf.org; sidr-chairs@ietf.org; sidr-ads@ietf.org; draft-ietf-sidr-rtr-keying@ietf.org Subject: Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017 - Oct 16, 2017 great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram"}
{"_id":"doc-en-sidr-56GWMfomFF9Rd5Ks03XkoZlbX5Y","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017\n - Oct 16, 2017\ngreat, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg? On Tue, Oct 17, 2017 at 4:42 PM, Sriram, Kotikalapudi (Fed) < kotikalapudi.sriram@nist.gov> wrote: Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram great, so .. if everyone agrees that commentsa re dealt with I'll send this forward to iesg?>Thanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram"}
{"_id":"doc-en-sidr-WmivvTqYj7160IVTqFbODNeMxOI","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-rtr-keying - finishes - 10\/16\/2017\n - Oct 16, 2017\nThanks for addressing our concerns. With the new changes in place I believe it is ready to advance, “ship it” +1 Yes, thank you, Sean. As Oliver mentioned, the comments you received from him were combined comments from the two us. I have looked over the new version you sent us. Looks good to me. When you upload an updated version, please consider including this editorial suggestion: s\/[RFC8205] describes gritty details,\/[RFC8205] describes the details of the BGPsec protocol,\/ Thanks. Sriram"}
{"_id":"doc-en-sidr-aEUVaPfeDh3ghl8URxDPBB7sVeI","title":"","text":"[sidr] RFC 8205 on BGPsec Protocol Specification\nA new Request for Comments is now available in online RFC libraries. RFC 8205 Title: BGPsec Protocol Specification Author: M. Lepinski, Ed., K. Sriram, Ed. Status: Standards Track Stream: IETF Date: September 2017 Mailbox: mlepinski@ncf.edu, kotikalapudi.sriram@nist.gov Pages: 45 Characters: 115900 Updates\/Obsoletes\/SeeAlso: None I-D Tag: draft-ietf-sidr-bgpsec-protocol-23.txt URL: https:\/\/www.rfc-editor.org\/info\/rfc8205 DOI: 10.17487\/RFC8205 This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of Autonomous Systems (ASes) through which a BGP UPDATE message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each AS that propagates the UPDATE message. The digital signatures provide confidence that every AS on the path of ASes listed in the UPDATE message has explicitly authorized the advertisement of the route. This document is a product of the Secure Inter-Domain Routing Working Group of the IETF. This is now a Proposed Standard. STANDARDS TRACK: This document specifies an Internet Standards Track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the Official Internet Protocol Standards (https:\/\/www.rfc-editor.org\/standards) for the standardization state and status of this protocol. Distribution of this memo is unlimited. This announcement is sent to the IETF-Announce and rfc-dist lists. To subscribe or unsubscribe, see https:\/\/www.ietf.org\/mailman\/listinfo\/ietf-announce https:\/\/mailman.rfc-editor.org\/mailman\/listinfo\/rfc-dist For searching the RFC series, see https:\/\/www.rfc-editor.org\/search For downloading RFCs, see https:\/\/www.rfc-editor.org\/retrieve\/bulk Requests for special distribution should be addressed to either the author of the RFC in question, or to rfc-editor@rfc-editor.org. Unless specifically noted otherwise on the RFC itself, all RFCs are for unlimited distribution. The RFC Editor Team Association Management Solutions, LLC"}
{"_id":"doc-en-sidr-zRYF5AZcBVzoVkmgF3Y2_Ynz1Co","title":"","text":"[sidr] FW: New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-23.txt\nThis new version is the “- publish an updated draft” step in the process that Alvaro outlined (see his email attached below). It also incorporates of a few editorial changes. Sriram -----Original Message----- From: internet-drafts@ietf.org [mailto:internet-drafts@ietf.org] Sent: Thursday, April 27, 2017 12:02 PM To: Matthew Lepinski <mlepinski@ncf.edu>; Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-23.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-23.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 23 Title: BGPsec Protocol Specification Document date: 2017-04-27 Group: sidr Pages: 44 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-23.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-23 Htmlized: https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-sidr-bgpsec-protocol-23 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. From: Alvaro Retana (aretana) [mailto:aretana@cisco.com] Sent: Wednesday, April 12, 2017 1:51 PM To: sidr@ietf.org Cc: sidr-chairs@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; sidrops@ietf.org; idr@ietf.org Subject: Re: BGPsec without Extended Messages (draft-ietf-sidr-bgpsec-protocol) Hi! Thanks to everyone who made comments in support for the modified text. I am now proceeding with the rest of the process (below). Will cc the WG as needed. Thanks!! Alvaro. On 4\/4\/17, 12:15 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com<mailto:aretana@cisco.com>> wrote: Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org)<mailto:ietf@ietf.org)> of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. This new version is the “- publish an updated draft” step in the process that Alvaro outlined (see his email attached below). It also incorporates of a few editorial changes. Sriram -----Original Message----- From: internet-drafts@ietf.org [mailto:internet-drafts@ietf.org] Sent: Thursday, April 27, 2017 12:02 PM To: Matthew Lepinski <mlepinski@ncf.edu>; Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-23.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-23.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 23 Title: BGPsec Protocol Specification Document date: 2017-04-27 Group: sidr Pages: 44 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-23.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-23 Htmlized: https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-sidr-bgpsec-protocol-23 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. From: Alvaro Retana (aretana) [mailto:aretana@cisco.com] Sent: Wednesday, April 12, 2017 1:51 PM To: sidr@ietf.org Cc: sidr-chairs@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; sidrops@ietf.org; idr@ietf.org Subject: Re: BGPsec without Extended Messages (draft-ietf-sidr-bgpsec-protocol) Hi! Thanks to everyone who made comments in support for the modified text. I am now proceeding with the rest of the process (below). Will cc the WG as needed. Thanks!! Alvaro. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org) of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan."}
{"_id":"doc-en-sidr-UTuUh7FpRwQT0P4ONIPmd0RF41I","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-23.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-23.txt Pages : 44 Date : 2017-04-27 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There are also htmlized versions available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-23 https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-sidr-bgpsec-protocol-23 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-23 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-RbguquhdChzEk9YjPSRMmW7mCeE","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nHi! Thanks to everyone who made comments in support for the modified text. I am now proceeding with the rest of the process (below). Will cc the WG as needed. Thanks!! Alvaro. On 4\/4\/17, 12:15 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com<mailto:aretana@cisco.com>> wrote: Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org)<mailto:ietf@ietf.org)> of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. Hi! Thanks to everyone who made comments in support for the modified text. I am now proceeding with the rest of the process (below). Will cc the WG as needed. Thanks!! Alvaro. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org) of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan."}
{"_id":"doc-en-sidr-BJ4PewfEQiDfoLMjDbiUaGnLUa8","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\n<individual contributor, RFC4271 co-author> Seems reasonable to me. Sue Hares -----Original Message----- From: sidr [mailto:sidr-bounces@ietf.org] On Behalf Of Sean Turner Sent: Wednesday, April 5, 2017 10:49 AM To: Alvaro Retana (aretana) Cc: idr@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; sidrops@ietf.org; Matthew Lepinski; sidr-chairs@ietf.org; sidr@ietf.org Subject: Re: [sidr] BGPsec without Extended Messages (draft-ietf-sidr-bgpsec-protocol) To me, the main purpose of changing the BGPsec spec is to depend on whatever BGP does, and not on a future extension that may or may not be in the form it is today. However, if we keep the reference to the known standard (rfc4271), then we should not have to update this document because we would just inherit whatever BGP does. This sound reasonable to me. spt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-MKZWEfTPnmiKqetYqr5lZe5Nv-I","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nTo me, the main purpose of changing the BGPsec spec is to depend on whatever BGP does, and not on a future extension that may or may not be in the form it is today. However, if we keep the reference to the known standard (rfc4271), then we should not have to update this document because we would just inherit whatever BGP does. This sound reasonable to me. spt"}
{"_id":"doc-en-sidr-ygOMsW-kZqkw1-b2woFUjqeELgg","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nAlvaro, Thanks a lot. That makes perfect sense. I support this change. - Matt Lepinski On Apr 4, 2017 1:18 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com> wrote: On 4\/4\/17, 12:44 PM, \"Matthew Lepinski\" <mlepinski@ncf.edu> wrote: Matt: Hi! The proposed changes seem reasonable, but I want to make sure that I understand the path forward clearly. My understanding is that if we were to reach a future where draft-ietf-idr-bgp-extended-messages is widely deployed, then the BGP speaker's maximum message size will just be larger (than it is today) and as a result we avoid reaching the point where Section 9.2 (of 4271) guidance is needed. Is my understanding correct? Not exactly. The text in 9.2\/rfc4271 is generic, it doesn’t apply to a specific message size; the maximum size is defined elsewhere. The current text of draft-ietf-idr-bgp-extended-messages changes the size of the messages in Section 4 (of rfc4271), which is the same place where 9.2 points to. IOW, the text in 9.2 would not change and still be applicable, the limit would just be reached later. (I want to make sure that future implementers will find our text clear and we won't need to revise this spec to add clarity if extended messages ends up in widespread use.) To me, the main purpose of changing the BGPsec spec is to depend on whatever BGP does, and not on a future extension that may or may not be in the form it is today. However, if we keep the reference to the known standard (rfc4271), then we should not have to update this document because we would just inherit whatever BGP does. Thanks! Alvaro. Alvaro,Thanks a lot. That makes perfect sense.I support this change.- Matt LepinskiOn Apr 4, 2017 1:18 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com> wrote: Matt: Hi! The proposed changes seem reasonable, but I want to make sure that I understand the path forward clearly. My understanding is that if we were to reach a future where draft-ietf-idr-bgp-extended-messages is widely deployed, then the BGP speaker's maximum message size will just be larger (than it is today) and as a result we avoid reaching the point where Section 9.2 (of 4271) guidance is needed. Is my understanding correct? Not exactly. The text in 9.2\/rfc4271 is generic, it doesn’t apply to a specific message size; the maximum size is defined elsewhere. The current text of draft-ietf-idr-bgp-extended-messages changes the size of the messages in Section 4 (of rfc4271), which is the same place where 9.2 points to. IOW, the text in 9.2 would not change and still be applicable, the limit would just be reached later. (I want to make sure that future implementers will find our text clear and we won't need to revise this spec to add clarity if extended messages ends up in widespread use.) To me, the main purpose of changing the BGPsec spec is to depend on whatever BGP does, and not on a future extension that may or may not be in the form it is today. However, if we keep the reference to the known standard (rfc4271), then we should not have to update this document because we would just inherit whatever BGP does. Thanks! Alvaro."}
{"_id":"doc-en-sidr-j5LBk_MOcC9-mq6ndZd197Kgmyk","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nMatt: Hi! The proposed changes seem reasonable, but I want to make sure that I understand the path forward clearly. My understanding is that if we were to reach a future where draft-ietf-idr-bgp-extended-messages is widely deployed, then the BGP speaker's maximum message size will just be larger (than it is today) and as a result we avoid reaching the point where Section 9.2 (of 4271) guidance is needed. Is my understanding correct? Not exactly. The text in 9.2\/rfc4271 is generic, it doesn’t apply to a specific message size; the maximum size is defined elsewhere. The current text of draft-ietf-idr-bgp-extended-messages changes the size of the messages in Section 4 (of rfc4271), which is the same place where 9.2 points to. IOW, the text in 9.2 would not change and still be applicable, the limit would just be reached later. (I want to make sure that future implementers will find our text clear and we won't need to revise this spec to add clarity if extended messages ends up in widespread use.) To me, the main purpose of changing the BGPsec spec is to depend on whatever BGP does, and not on a future extension that may or may not be in the form it is today. However, if we keep the reference to the known standard (rfc4271), then we should not have to update this document because we would just inherit whatever BGP does. Thanks! Alvaro."}
{"_id":"doc-en-sidr-02PydFC3w6umoaIXfGmMhAVNC-c","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nHi Matt, I think slide 4 of this presentation (SIDROPS, IETF 98) addresses your questions\/concerns: https:\/\/www.ietf.org\/proceedings\/98\/slides\/slides-98-sidrops-decoupling-bgpsec-documents-and-extended-messages-draft-00.pdf Please take a look at slide 3 also (BGP & BGPsec update sizes). Also, Alvaro's post from March 15 should be helpful: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08506.html Sriram -----Original Message----- From: Matthew Lepinski [mailto:mlepinski@ncf.edu] Sent: Tuesday, April 04, 2017 12:45 PM To: Alvaro Retana (aretana) <aretana@cisco.com> Cc: sidr@ietf.org; sidr-chairs@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; sidrops@ietf.org; idr@ietf.org Subject: Re: BGPsec without Extended Messages (draft-ietf-sidr-bgpsec-protocol) Alvaro, The proposed changes seem reasonable, but I want to make sure that I understand the path forward clearly. My understanding is that if we were to reach a future where draft-ietf-idr-bgp-extended-messages is widely deployed, then the BGP speaker's maximum message size will just be larger (than it is today) and as a result we avoid reaching the point where Section 9.2 (of 4271) guidance is needed. Is my understanding correct? (I want to make sure that future implementers will find our text clear and we won't need to revise this spec to add clarity if extended messages ends up in widespread use.) - Matt Lepinski Dear sidr WG: As has been discussed in the mailing list and at the sidrops meeting last week in Chicago, there is interest to not have the BGPsec document (draft-ietf-sidr-bgpsec-protocol) depend normatively on the Extended Messages work (draft-ietf-idr-bgp-extended-messages). Based on that discussion, Sriram and I have come up with proposed diffs – please see the attachment (-23 has not been posted yet). To summarize, the changes are: (1) remove mention\/references of\/to draft-ietf-idr-bgp-extended-messages, and (2) add the following text in Section 4.1. (General Guidance): All BGPsec update messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed. [For easier reference, I put the relevant text from 9.2 below.] The result is then that draft-ietf-sidr-bgpsec-protocol doesn’t depend on draft-ietf-idr-bgp-extended-messages. Instead, when referring to the size of the messages, it depends on rfc4271. Please let me know if you have any concerns. I will wait a week before proceeding. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org) of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. Thanks!! Alvaro. https:\/\/tools.ietf.org\/html\/rfc4271#section-9.2 9.2. Update-Send Process … If, due to the limits on the maximum size of an UPDATE message (see Section 4), a single route doesn't fit into the message, the BGP speaker MUST not advertise the route to its peers and MAY choose to log an error locally."}
{"_id":"doc-en-sidr-crwjOBarz0X37ic3ziRpuPfBgJI","title":"","text":"Re: [sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nAlvaro, The proposed changes seem reasonable, but I want to make sure that I understand the path forward clearly. My understanding is that if we were to reach a future where draft-ietf-idr-bgp-extended-messages is widely deployed, then the BGP speaker's maximum message size will just be larger (than it is today) and as a result we avoid reaching the point where Section 9.2 (of 4271) guidance is needed. Is my understanding correct? (I want to make sure that future implementers will find our text clear and we won't need to revise this spec to add clarity if extended messages ends up in widespread use.) - Matt Lepinski Dear sidr WG: As has been discussed in the mailing list and at the sidrops meeting last week in Chicago, there is interest to not have the BGPsec document (draft-ietf-sidr-bgpsec-protocol) depend normatively on the Extended Messages work (draft-ietf-idr-bgp-extended-messages). Based on that discussion, Sriram and I have come up with proposed diffs – please see the attachment (-23 has not been posted yet). To summarize, the changes are: (1) remove mention\/references of\/to draft-ietf-idr-bgp-extended-messages, and (2) add the following text in Section 4.1. (General Guidance): All BGPsec update messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed. [For easier reference, I put the relevant text from 9.2 below.] The result is then that draft-ietf-sidr-bgpsec-protocol doesn’t depend on draft-ietf-idr-bgp-extended-messages. Instead, when referring to the size of the messages, it depends on rfc4271. Please let me know if you have any concerns. I will wait a week before proceeding. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org) of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. Thanks!! Alvaro. https:\/\/tools.ietf.org\/html\/rfc4271#section-9.2 9.2. Update-Send Process … If, due to the limits on the maximum size of an UPDATE message (see Section 4), a single route doesn't fit into the message, the BGP speaker MUST not advertise the route to its peers and MAY choose to log an error locally."}
{"_id":"doc-en-sidr-6mlQGSRn9tfBLD8nGyOToIe562s","title":"","text":"[sidr] BGPsec without Extended Messages\n (draft-ietf-sidr-bgpsec-protocol)\nDear sidr WG: As has been discussed in the mailing list and at the sidrops meeting last week in Chicago, there is interest to not have the BGPsec document (draft-ietf-sidr-bgpsec-protocol) depend normatively on the Extended Messages work (draft-ietf-idr-bgp-extended-messages). Based on that discussion, Sriram and I have come up with proposed diffs – please see the attachment (-23 has not been posted yet). To summarize, the changes are: (1) remove mention\/references of\/to draft-ietf-idr-bgp-extended-messages, and (2) add the following text in Section 4.1. (General Guidance): All BGPsec update messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed. [For easier reference, I put the relevant text from 9.2 below.] The result is then that draft-ietf-sidr-bgpsec-protocol doesn’t depend on draft-ietf-idr-bgp-extended-messages. Instead, when referring to the size of the messages, it depends on rfc4271. Please let me know if you have any concerns. I will wait a week before proceeding. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org)<mailto:ietf@ietf.org)> of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. Thanks!! Alvaro. https:\/\/tools.ietf.org\/html\/rfc4271#section-9.2 9.2. Update-Send Process … If, due to the limits on the maximum size of an UPDATE message (see Section 4), a single route doesn't fit into the message, the BGP speaker MUST not advertise the route to its peers and MAY choose to log an error locally. Dear sidr WG: As has been discussed in the mailing list and at the sidrops meeting last week in Chicago, there is interest to not have the BGPsec document (draft-ietf-sidr-bgpsec-protocol) depend normatively on the Extended Messages work (draft-ietf-idr-bgp-extended-messages). Based on that discussion, Sriram and I have come up with proposed diffs – please see the attachment (-23 has not been posted yet). To summarize, the changes are: (1) remove mention\/references of\/to draft-ietf-idr-bgp-extended-messages, and (2) add the following text in Section 4.1. (General Guidance): All BGPsec update messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed. [For easier reference, I put the relevant text from 9.2 below.] The result is then that draft-ietf-sidr-bgpsec-protocol doesn’t depend on draft-ietf-idr-bgp-extended-messages. Instead, when referring to the size of the messages, it depends on rfc4271. Please let me know if you have any concerns. I will wait a week before proceeding. Given that this document has already been approved by the IESG, the process going forward is: - consult the WG (this thread) - inform the IESG of the intent - inform the IETF (ietf@ietf.org) of the changes - publish an updated draft - continue the publication process Each step may, obviously, require additional discussion and could result in changes to the current plan. Thanks!! Alvaro. https:\/\/tools.ietf.org\/html\/rfc4271#section-9.2 9.2. Update-Send Process … If, due to the limits on the maximum size of an UPDATE message (see Section 4), a single route doesn't fit into the message, the BGP speaker MUST not advertise the route to its peers and MAY choose to log an error locally. Diff: draft-ietf-sidr-bgpsec-protocol-22-download.txt - draft-ietf-sidr-bgpsec-protocol-23.txt < draft-ietf-sidr-bgpsec-protocol-22-download.txt draft-ietf-sidr-bgpsec-protocol-23.txt > Network Working Group M. Lepinski, Ed. Network Working Group M. Lepinski, Ed. Internet-Draft NCF Internet-Draft NCF Intended status: Standards Track K. Sriram, Ed. Intended status: Standards Track K. Sriram, Ed. Expires: July 20, 2017 NIST Expires: October 5, 2017 NIST January 16, 2017 April 3, 2017 BGPsec Protocol Specification BGPsec Protocol Specification draft-ietf-sidr-bgpsec-protocol-22 draft-ietf-sidr-bgpsec-protocol-23 Abstract Abstract This document describes BGPsec, an extension to the Border Gateway This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update confidence that every AS on the path of ASes listed in the update skipping to change at page 1, line 38 ¶ skipping to change at page 1, line 38 ¶ Internet-Drafts are working documents of the Internet Engineering Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet- working documents as Internet-Drafts. The list of current Internet- Drafts is at http:\/\/datatracker.ietf.org\/drafts\/current\/. Drafts is at http:\/\/datatracker.ietf.org\/drafts\/current\/. Internet-Drafts are draft documents valid for a maximum of six months Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\" material or to cite them other than as \"work in progress.\" This Internet-Draft will expire on July 20, 2017. This Internet-Draft will expire on October 5, 2017. Copyright Notice Copyright Notice Copyright (c) 2017 IETF Trust and the persons identified as the Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved. document authors. All rights reserved. This document is subject to BCP 78 and the IETF Trust's Legal This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents Provisions Relating to IETF Documents (http:\/\/trustee.ietf.org\/license-info) in effect on the date of (http:\/\/trustee.ietf.org\/license-info) in effect on the date of publication of this document. Please review these documents publication of this document. Please review these documents skipping to change at page 2, line 21 ¶ skipping to change at page 2, line 21 ¶ 1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . 2 1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . 2 1.1. Requirements Language . . . . . . . . . . . . . . . . . . 3 1.1. Requirements Language . . . . . . . . . . . . . . . . . . 3 2. BGPsec Negotiation . . . . . . . . . . . . . . . . . . . . . 3 2. BGPsec Negotiation . . . . . . . . . . . . . . . . . . . . . 3 2.1. The BGPsec Capability . . . . . . . . . . . . . . . . . . 3 2.1. The BGPsec Capability . . . . . . . . . . . . . . . . . . 3 2.2. Negotiating BGPsec Support . . . . . . . . . . . . . . . 4 2.2. Negotiating BGPsec Support . . . . . . . . . . . . . . . 4 3. The BGPsec_Path Attribute . . . . . . . . . . . . . . . . . . 6 3. The BGPsec_Path Attribute . . . . . . . . . . . . . . . . . . 6 3.1. Secure_Path . . . . . . . . . . . . . . . . . . . . . . . 8 3.1. Secure_Path . . . . . . . . . . . . . . . . . . . . . . . 8 3.2. Signature_Block . . . . . . . . . . . . . . . . . . . . . 10 3.2. Signature_Block . . . . . . . . . . . . . . . . . . . . . 10 4. BGPsec Update Messages . . . . . . . . . . . . . . . . . . . 11 4. BGPsec Update Messages . . . . . . . . . . . . . . . . . . . 11 4.1. General Guidance . . . . . . . . . . . . . . . . . . . . 11 4.1. General Guidance . . . . . . . . . . . . . . . . . . . . 11 4.2. Constructing the BGPsec_Path Attribute . . . . . . . . . 13 4.2. Constructing the BGPsec_Path Attribute . . . . . . . . . 14 4.3. Processing Instructions for Confederation Members . . . . 18 4.3. Processing Instructions for Confederation Members . . . . 18 4.4. Reconstructing the AS_PATH Attribute . . . . . . . . . . 19 4.4. Reconstructing the AS_PATH Attribute . . . . . . . . . . 19 5. Processing a Received BGPsec Update . . . . . . . . . . . . . 21 5. Processing a Received BGPsec Update . . . . . . . . . . . . . 21 5.1. Overview of BGPsec Validation . . . . . . . . . . . . . . 22 5.1. Overview of BGPsec Validation . . . . . . . . . . . . . . 22 5.2. Validation Algorithm . . . . . . . . . . . . . . . . . . 23 5.2. Validation Algorithm . . . . . . . . . . . . . . . . . . 23 6. Algorithms and Extensibility . . . . . . . . . . . . . . . . 27 6. Algorithms and Extensibility . . . . . . . . . . . . . . . . 27 6.1. Algorithm Suite Considerations . . . . . . . . . . . . . 27 6.1. Algorithm Suite Considerations . . . . . . . . . . . . . 27 6.2. Considerations for the SKI Size . . . . . . . . . . . . . 28 6.2. Considerations for the SKI Size . . . . . . . . . . . . . 28 6.3. Extensibility Considerations . . . . . . . . . . . . . . 28 6.3. Extensibility Considerations . . . . . . . . . . . . . . 28 7. Operations and Management Considerations . . . . . . . . . . 29 7. Operations and Management Considerations . . . . . . . . . . 29 8. Security Considerations . . . . . . . . . . . . . . . . . . . 33 8. Security Considerations . . . . . . . . . . . . . . . . . . . 32 8.1. Security Guarantees . . . . . . . . . . . . . . . . . . . 33 8.1. Security Guarantees . . . . . . . . . . . . . . . . . . . 33 8.2. On the Removal of BGPsec Signatures . . . . . . . . . . . 34 8.2. On the Removal of BGPsec Signatures . . . . . . . . . . . 33 8.3. Mitigation of Denial of Service Attacks . . . . . . . . . 35 8.3. Mitigation of Denial of Service Attacks . . . . . . . . . 35 8.4. Additional Security Considerations . . . . . . . . . . . 36 8.4. Additional Security Considerations . . . . . . . . . . . 36 9. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 37 9. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 37 10. Contributors . . . . . . . . . . . . . . . . . . . . . . . . 39 10. Contributors . . . . . . . . . . . . . . . . . . . . . . . . 39 10.1. Authors . . . . . . . . . . . . . . . . . . . . . . . . 39 10.1. Authors . . . . . . . . . . . . . . . . . . . . . . . . 39 10.2. Acknowledgements . . . . . . . . . . . . . . . . . . . . 40 10.2. Acknowledgements . . . . . . . . . . . . . . . . . . . . 40 11. References . . . . . . . . . . . . . . . . . . . . . . . . . 40 11. References . . . . . . . . . . . . . . . . . . . . . . . . . 40 11.1. Normative References . . . . . . . . . . . . . . . . . . 40 11.1. Normative References . . . . . . . . . . . . . . . . . . 40 11.2. Informative References . . . . . . . . . . . . . . . . . 42 11.2. Informative References . . . . . . . . . . . . . . . . . 41 Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . 44 Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . 43 1. Introduction 1. Introduction This document describes BGPsec, a mechanism for providing path This document describes BGPsec, a mechanism for providing path security for Border Gateway Protocol (BGP) [RFC4271] route security for Border Gateway Protocol (BGP) [RFC4271] route advertisements. That is, a BGP speaker who receives a valid BGPsec advertisements. That is, a BGP speaker who receives a valid BGPsec update has cryptographic assurance that the advertised route has the update has cryptographic assurance that the advertised route has the following property: Every AS on the path of ASes listed in the update following property: Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to message has explicitly authorized the advertisement of the route to the subsequent AS in the path. the subsequent AS in the path. skipping to change at page 5, line 50 ¶ skipping to change at page 6, line 5 ¶ case that support for multiple versions is negotiated. case that support for multiple versions is negotiated. BGPsec cannot provide meaningful security guarantees without support BGPsec cannot provide meaningful security guarantees without support for four-byte AS numbers. Therefore, any BGP speaker that announces for four-byte AS numbers. Therefore, any BGP speaker that announces the BGPsec capability, MUST also announce the capability for four- the BGPsec capability, MUST also announce the capability for four- byte AS support [RFC6793]. If a BGP speaker sends the BGPsec byte AS support [RFC6793]. If a BGP speaker sends the BGPsec capability but not the four-byte AS support capability then BGPsec capability but not the four-byte AS support capability then BGPsec has not been successfully negotiated, and update messages containing has not been successfully negotiated, and update messages containing the BGPsec_Path attribute MUST NOT be sent within such a session. the BGPsec_Path attribute MUST NOT be sent within such a session. Note that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. Please see related operational guidance in Section 7. 3. The BGPsec_Path Attribute 3. The BGPsec_Path Attribute The BGPsec_Path attribute is an optional non-transitive BGP path The BGPsec_Path attribute is an optional non-transitive BGP path attribute. attribute. This document registers an attribute type code for this attribute: This document registers an attribute type code for this attribute: BGPsec_Path (see Section 9). BGPsec_Path (see Section 9). The BGPsec_Path attribute carries the secured information regarding The BGPsec_Path attribute carries the secured information regarding the path of ASes through which an update message passes. This the path of ASes through which an update message passes. This skipping to change at page 13, line 45 ¶ skipping to change at page 13, line 45 ¶ attribute SHOULD NOT be removed, unless the peer doesn't support attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec. In the case when an iBGP peer doesn't support BGPsec, then a BGPsec. In the case when an iBGP peer doesn't support BGPsec, then a BGP update with AS_PATH is reconstructed from the BGPsec update and BGP update with AS_PATH is reconstructed from the BGPsec update and then forwarded (see Section 4.4). In particular, when forwarding to then forwarded (see Section 4.4). In particular, when forwarding to a BGPsec-capable iBGP (or eBGP) peer, the BGPsec_Path attribute a BGPsec-capable iBGP (or eBGP) peer, the BGPsec_Path attribute SHOULD NOT be removed even in the case where the BGPsec update SHOULD NOT be removed even in the case where the BGPsec update message has not been successfully validated. (See Section 5 for more message has not been successfully validated. (See Section 5 for more information on validation, and Section 8 for the security information on validation, and Section 8 for the security ramifications of removing BGPsec signatures.) ramifications of removing BGPsec signatures.) All BGPsec update messages MUST conform to BGP's maximum message size. If the resulting message exceeds the maximum message size, then the guidelines in Section 9.2 of RFC 4271 [RFC4271] MUST be followed. 4.2. Constructing the BGPsec_Path Attribute 4.2. Constructing the BGPsec_Path Attribute When a BGPsec speaker receives a BGPsec update message containing a When a BGPsec speaker receives a BGPsec update message containing a BGPsec_Path attribute (with one or more signatures) from an (internal BGPsec_Path attribute (with one or more signatures) from an (internal or external) peer, it may choose to propagate the route advertisement or external) peer, it may choose to propagate the route advertisement by sending it to its other (internal or external) peers. When by sending it to its other (internal or external) peers. When sending the route advertisement to an internal BGPsec-speaking peer, sending the route advertisement to an internal BGPsec-speaking peer, the BGPsec_Path attribute SHALL NOT be modified. When sending the the BGPsec_Path attribute SHALL NOT be modified. When sending the route advertisement to an external BGPsec-speaking peer, the route advertisement to an external BGPsec-speaking peer, the following procedures are used to form or update the BGPsec_Path following procedures are used to form or update the BGPsec_Path skipping to change at page 30, line 36 ¶ skipping to change at page 30, line 36 ¶ and later receives a second BGPsec update message from the same peer and later receives a second BGPsec update message from the same peer for the same prefix with the same Secure_Path and SKIs, the second for the same prefix with the same Secure_Path and SKIs, the second update MAY differ from the first update in the signature fields (for update MAY differ from the first update in the signature fields (for a non-deterministic signature algorithm). However, the two sets of a non-deterministic signature algorithm). However, the two sets of signature fields will not differ if the sender caches and reuses the signature fields will not differ if the sender caches and reuses the previous signature. For a deterministic signature algorithm, the previous signature. For a deterministic signature algorithm, the signature fields MUST be identical between the two updates. On the signature fields MUST be identical between the two updates. On the basis of these observations, an implementation MAY incorporate basis of these observations, an implementation MAY incorporate optimizations in update validation processing. optimizations in update validation processing. In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. It is possible that a stub customer of an ISP employs a private AS It is possible that a stub customer of an ISP employs a private AS number. Such a stub customer cannot publish a ROA in the global RPKI number. Such a stub customer cannot publish a ROA in the global RPKI for the private AS number and the prefixes that they use. Also, the for the private AS number and the prefixes that they use. Also, the global RPKI cannot support private AS numbers (i.e. BGPsec speakers global RPKI cannot support private AS numbers (i.e. BGPsec speakers in private ASes cannot be issued router certificates in the global in private ASes cannot be issued router certificates in the global RPKI). For interactions between the stub customer and the ISP, the RPKI). For interactions between the stub customer and the ISP, the following two scenarios are possible: following two scenarios are possible: 1. The stub customer sends an unsigned BGP update for a prefix to 1. The stub customer sends an unsigned BGP update for a prefix to the ISP's AS. An edge BGPsec speaker in the ISP's AS may choose the ISP's AS. An edge BGPsec speaker in the ISP's AS may choose skipping to change at page 38, line 9 ¶ skipping to change at page 38, line 9 ¶ protocol). protocol). IANA is requested to define the \"BGPsec Capability\" registry in the IANA is requested to define the \"BGPsec Capability\" registry in the Resource Public Key Infrastructure (RPKI) group. The registry is as Resource Public Key Infrastructure (RPKI) group. The registry is as shown in Figure 10 with values assigned from Section 2.1: shown in Figure 10 with values assigned from Section 2.1: +------+------------------------------------+------------+ +------+------------------------------------+------------+ | Bits | Field | Reference | | Bits | Field | Reference | +------+------------------------------------+------------+ +------+------------------------------------+------------+ | 0-3 | Version | [This RFC] | | 0-3 | Version | [This RFC] | | +------------------------------------+------------+ | | Value = 0x0 | | | | Value = 0x0 | [This RFC] | +------+------------------------------------+------------+ +------+------------------------------------+------------+ | 4 | Direction | [This RFC] | | 4 | Direction | [This RFC] | | +------------------------------------+------------+ | |(Both possible values 0 and 1 are | | | |(Both possible values 0 and 1 are | [This RFC] | | | fully specified by this RFC) | | | | fully specified by this RFC) | | +------+------------------------------------+------------+ +------+------------------------------------+------------+ | 5-7 | Unassigned | [This RFC] | | 5-7 | Unassigned | [This RFC] | | +------------------------------------+------------+ | | Value = 000 (in binary) | | | | Value = 000 (in binary) | [This RFC] | +------+------------------------------------+------------+ +------+------------------------------------+------------+ Figure 10: IANA registry for BGPsec Capability. Figure 10: IANA registry for BGPsec Capability. The Direction bit (4th bit) has value either 0 or 1, and both values The Direction bit (4th bit) has value either 0 or 1, and both values are fully specified by this document (i.e. the RFC that replaces are fully specified by this document (i.e. the RFC that replaces draft-ietf-sidr-bgpsec-protocol). Future Version values and future draft-ietf-sidr-bgpsec-protocol). Future Version values and future values of the Unassigned bits are assigned using the \"Standards values of the Unassigned bits are assigned using the \"Standards Action\" registration procedures defined in RFC 5226 [RFC5226]. Action\" registration procedures defined in RFC 5226 [RFC5226]. IANA is requested to define the \"BGPsec_Path Flags\" registry in the IANA is requested to define the \"BGPsec_Path Flags\" registry in the RPKI group. The registry is as shown in Figure 11 with one value RPKI group. The registry is as shown in Figure 11 with one value assigned from Section 3.1: assigned from Section 3.1: +------+-------------------------------------------+------------+ +------+-------------------------------------------+------------+ | Flag | Description | Reference | | Flag | Description | Reference | +------+-------------------------------------------+------------+ +------+-------------------------------------------+------------+ | 0 | Confed_Segment | [This RFC] | | 0 | Confed_Segment | [This RFC] | +------+-------------------------------------------+------------+ | | Bit value = 1 means Flag set | | | | Bit value = 1 means Flag set | [This RFC] | | | (indicates Confed_Segment) | | | | (indicates Confed_Segment) | | | | Bit value = 0 is default | | | | Bit value = 0 is default | | +------+-------------------------------------------+------------+ +------+-------------------------------------------+------------+ | 1-7 | Unassigned | [This RFC] | | 1-7 | Unassigned | [This RFC] | | +-------------------------------------------+------------+ | | Value: All 7 bits set to zero | | | | Value: All 7 bits set to zero | [This RFC] | +------+-------------------------------------------+------------+ +------+-------------------------------------------+------------+ Figure 11: IANA registry for BGPsec_Path Flags field. Figure 11: IANA registry for BGPsec_Path Flags field. Future values of the Unassigned bits are assigned using the Future values of the Unassigned bits are assigned using the \"Standards Action\" registration procedures defined in RFC 5226 \"Standards Action\" registration procedures defined in RFC 5226 [RFC5226]. [RFC5226]. 10. Contributors 10. Contributors skipping to change at page 40, line 22 ¶ skipping to change at page 40, line 22 ¶ Mark Reynolds, Heather Schiller, Jason Schiller, Ruediger Volk, and Mark Reynolds, Heather Schiller, Jason Schiller, Ruediger Volk, and David Ward for their review, comments, and suggestions during the David Ward for their review, comments, and suggestions during the course of this work. Thanks are also due to many IESG reviewers course of this work. Thanks are also due to many IESG reviewers whose comments greatly helped improve the clarity, accuracy, and whose comments greatly helped improve the clarity, accuracy, and presentation in the document. presentation in the document. 11. References 11. References 11.1. Normative References 11.1. Normative References [I-D.ietf-idr-bgp-extended-messages] Bush, R., Patel, K., and D. Ward, \"Extended Message support for BGP\", draft-ietf-idr-bgp-extended-messages-14 (work in progress), December 2016. [I-D.ietf-sidr-bgpsec-algs] [I-D.ietf-sidr-bgpsec-algs] Turner, S., \"BGPsec Algorithms, Key Formats, & Signature Turner, S. and O. Borchert, \"BGPsec Algorithms, Key Formats\", draft-ietf-sidr-bgpsec-algs-16 (work in Formats, & Signature Formats\", draft-ietf-sidr-bgpsec- progress), November 2016. algs-18 (work in progress), April 2017. [I-D.ietf-sidr-bgpsec-pki-profiles] [I-D.ietf-sidr-bgpsec-pki-profiles] Reynolds, M., Turner, S., and S. Kent, \"A Profile for Reynolds, M., Turner, S., and S. Kent, \"A Profile for BGPsec Router Certificates, Certificate Revocation Lists, BGPsec Router Certificates, Certificate Revocation Lists, and Certification Requests\", draft-ietf-sidr-bgpsec-pki- and Certification Requests\", draft-ietf-sidr-bgpsec-pki- profiles-21 (work in progress), January 2017. profiles-21 (work in progress), January 2017. [IANA-AF] \"Address Family Numbers\", [IANA-AF] \"Address Family Numbers\", <http:\/\/www.iana.org\/assignments\/address-family-numbers\/ <http:\/\/www.iana.org\/assignments\/address-family-numbers\/ address-family-numbers.xhtml>. address-family-numbers.xhtml>. skipping to change at page 42, line 36 ¶ skipping to change at page 42, line 27 ¶ Bush, R., \"BGPsec Operational Considerations\", draft-ietf- Bush, R., \"BGPsec Operational Considerations\", draft-ietf- sidr-bgpsec-ops-16 (work in progress), January 2017. sidr-bgpsec-ops-16 (work in progress), January 2017. [I-D.ietf-sidr-bgpsec-rollover] [I-D.ietf-sidr-bgpsec-rollover] Gagliano, R., Weis, B., and K. Patel, \"BGPsec Router Gagliano, R., Weis, B., and K. Patel, \"BGPsec Router Certificate Rollover\", draft-ietf-sidr-bgpsec-rollover-06 Certificate Rollover\", draft-ietf-sidr-bgpsec-rollover-06 (work in progress), October 2016. (work in progress), October 2016. [I-D.ietf-sidr-delta-protocol] [I-D.ietf-sidr-delta-protocol] Bruijnzeels, T., Muravskiy, O., Weber, B., and R. Austein, Bruijnzeels, T., Muravskiy, O., Weber, B., and R. Austein, \"RPKI Repository Delta Protocol\", draft-ietf-sidr-delta- \"RPKI Repository Delta Protocol (RRDP)\", draft-ietf-sidr- protocol-05 (work in progress), January 2017. delta-protocol-08 (work in progress), March 2017. [I-D.ietf-sidr-publication] [I-D.ietf-sidr-publication] Weiler, S., Sonalker, A., and R. Austein, \"A Publication Weiler, S., Sonalker, A., and R. Austein, \"A Publication Protocol for the Resource Public Key Infrastructure Protocol for the Resource Public Key Infrastructure (RPKI)\", draft-ietf-sidr-publication-10 (work in (RPKI)\", draft-ietf-sidr-publication-12 (work in progress), January 2017. progress), March 2017. [I-D.ietf-sidr-rpki-rtr-rfc6810-bis] [I-D.ietf-sidr-rpki-rtr-rfc6810-bis] Bush, R. and R. Austein, \"The Resource Public Key Bush, R. and R. Austein, \"The Resource Public Key Infrastructure (RPKI) to Router Protocol\", draft-ietf- Infrastructure (RPKI) to Router Protocol, Version 1\", sidr-rpki-rtr-rfc6810-bis-08 (work in progress), January draft-ietf-sidr-rpki-rtr-rfc6810-bis-09 (work in 2017. progress), February 2017. [I-D.ietf-sidr-slurm] [I-D.ietf-sidr-slurm] Mandelberg, D. and D. Ma, \"Simplified Local internet Mandelberg, D., Ma, D., and T. Bruijnzeels, \"Simplified nUmber Resource Management with the RPKI\", draft-ietf- Local internet nUmber Resource Management with the RPKI\", sidr-slurm-02 (work in progress), August 2016. draft-ietf-sidr-slurm-04 (work in progress), March 2017. [RFC6472] Kumari, W. and K. Sriram, \"Recommendation for Not Using [RFC6472] Kumari, W. and K. Sriram, \"Recommendation for Not Using AS_SET and AS_CONFED_SET in BGP\", BCP 172, RFC 6472, AS_SET and AS_CONFED_SET in BGP\", BCP 172, RFC 6472, DOI 10.17487\/RFC6472, December 2011, DOI 10.17487\/RFC6472, December 2011, <http:\/\/www.rfc-editor.org\/info\/rfc6472>. <http:\/\/www.rfc-editor.org\/info\/rfc6472>. [RFC6480] Lepinski, M. and S. Kent, \"An Infrastructure to Support [RFC6480] Lepinski, M. and S. Kent, \"An Infrastructure to Support Secure Internet Routing\", RFC 6480, DOI 10.17487\/RFC6480, Secure Internet Routing\", RFC 6480, DOI 10.17487\/RFC6480, February 2012, <http:\/\/www.rfc-editor.org\/info\/rfc6480>. February 2012, <http:\/\/www.rfc-editor.org\/info\/rfc6480>. End of changes. 21 change blocks. 54 lines changed or deleted 32 lines changed or added This html diff was produced by rfcdiff 1.45. The latest version is available from http:\/\/tools.ietf.org\/tools\/rfcdiff\/"}
{"_id":"doc-en-sidr-3ze9FreVvdbTg7SuUseTaiDjJas","title":"","text":"[sidr] Protocol Action: 'BGPsec Algorithms, Key Formats,\n & Signature Formats' to Proposed Standard\n (draft-ietf-sidr-bgpsec-algs-17.txt)\nThe IESG has approved the following document: - 'BGPsec Algorithms, Key Formats, & Signature Formats' (draft-ietf-sidr-bgpsec-algs-17.txt) as Proposed Standard This document is the product of the Secure Inter-Domain Routing Working Group. The IESG contact persons are Alvaro Retana, Alia Atlas and Deborah Brungard. A URL of this Internet Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-algs\/ Technical Summary This document specifies the algorithms, algorithm parameters, asymmetric key formats, asymmetric key size and signature format used in BGPsec (Border Gateway Protocol Security). This document updates the Profile for Algorithms and Key Sizes for Use in the Resource Public Key Infrastructure (RFC 7935). Working Group Summary This document has had consistent interest from the working group. The document passed wglc and then waited for publication until the BGPsec protocol was mature. Document Quality There is one known implementation of the generation of certificates that use the algorithm and key format defined in this draft. There are two known implementations of BGPsec that use the algorithms defined in this draft. All are open source implementations. Personnel Document Shepherd: Sandra Murphy Responsible Area Director: Alvaro Retana RFC Editor Note This document is part of a group being considered by the IESG that normatively depend on draft-ietf-sidr-bgpsec-protocol; all documents are titled draft-ietf-sidr-bgpsec-*. Please make sure that draft-ietf-sidr-bgpsec-protocol has the lowest RFC number -- no consecutive numbers are needed in this case."}
{"_id":"doc-en-sidr-T6DCzxigv6ABV4SrbZ657m5EKP4","title":"","text":"[sidr] Protocol Action: 'BGPSec Considerations for AS Migration' to\n Proposed Standard (draft-ietf-sidr-as-migration-06.txt)\nThe IESG has approved the following document: - 'BGPSec Considerations for AS Migration' (draft-ietf-sidr-as-migration-06.txt) as Proposed Standard This document is the product of the Secure Inter-Domain Routing Working Group. The IESG contact persons are Alvaro Retana, Alia Atlas and Deborah Brungard. A URL of this Internet Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-as-migration\/ Technical Summary This draft discusses considerations and methods for supporting and securing a common method for AS-Migration within the BGPSec protocol. Working Group Summary There was considerable discussion about this document in both SIDR and IDR working groups. Document Quality There are no implementations of the mechanisms, but this document (along with the base BGPSec specification) has been reviewed by vendors and operators. The document addresses the need to secure a common AS-migration set of mechanisms used in networks today. Personnel Document Shepherd: Chris Morrow AD: Alvaro Retana RFC Editor Note This document should be published alongside draft-ietf-sidr-bgpsec-protocol and draft-ietf-sidr-bgpsec-ops so that they have consecutive RFC numbers in the following order: draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-ops"}
{"_id":"doc-en-sidr-bf-DVsYG3tZT-xY7jjba0x6r8G4","title":"","text":"[sidr] Protocol Action: 'BGPsec Protocol Specification' to Proposed\n Standard (draft-ietf-sidr-bgpsec-protocol-22.txt)\nThe IESG has approved the following document: - 'BGPsec Protocol Specification' (draft-ietf-sidr-bgpsec-protocol-22.txt) as Proposed Standard This document is the product of the Secure Inter-Domain Routing Working Group. The IESG contact persons are Alvaro Retana, Alia Atlas and Deborah Brungard. A URL of this Internet Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Technical Summary This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. Working Group Summary This document has been discussed in the working group since 2011. The WG has been asked periodically to confirm continued interest, and has each time indicated that the work is valuable and should continue. The idr WG has also provided feedback and input. Document Quality The work mentioned here is applicable to all inter-domain BGP operators. BGPsec has been implemented in BIRD and Quagga, two popular open source BGP daemons. The BIRD community explicitly agreed to integrate this extension in the main branch. Personnel Shepherd: Matthias Waehlisch Responsible AD: Alvaro Retana RFC Editor Note This document is the base of a series being considered by the IESG; most are titled draft-ietf-sidr-bgpsec-*. This document should be published with the lowest RFC number, and be followed with consecutive RFC numbers by draft-ietf-sidr-as-migration and draft-ietf-sidr-bgpsec-ops. All other related documents don't require consecutive numbers."}
{"_id":"doc-en-sidr-a2yZpAKN_ginOrb1ktBpd0OSXX8","title":"","text":"Re: [sidr] Ben Campbell's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nBen, Thank you. Please see my response inline below. - 8.4, last paragraph: The text describes a replay attack, and delegates the mitigation solution to. This is an informational reference; it draft-ietf-sidr-bgpsec-rollover seems like it should be normative. The solution for mitigation of replay attacks is out of band (in relation to the BGPsec protocol). As I see it, draft-ietf-sidr-bgpsec-rollover proposes 'a way' of replay attack mitigation. Techniques for key rollover \/ replay attack mitigation are expected to continue to evolve. There are various variants of the basic key rollover technique that are discussed in this informational draft: https:\/\/tools.ietf.org\/html\/draft-sriram-replay-protection-design-discussion-07 What needs to be pointed out in the BGPsec specification is that there are solutions available for replay attack mitigation. The above are the reasons why draft-ietf-sidr-bgpsec-rollover is included in informational references. That is a reasonable response, if you think it is realistic that people would implement solutions other than the one in the reference. It would help if the text were more clear that draft-ietf-sider-bgpsec rollover is an example of a possible solutions, and other solutions are possible. I will try to edit the text a bit to make that clear when I have the next opportunity to edit the document. Sriram"}
{"_id":"doc-en-sidr-_O-DbJfWaAIWm2cgCC4629KvV1U","title":"","text":"Re: [sidr]\n =?windows-1252?q?Mirja_K=FChlewind=27s_No_Objection_on_dra?=\n =?windows-1252?q?ft-ietf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nHi Mirja, thanks for the very clear clarification. Not sure if it’s just me or if that’s not clearly stated in the draft, but maybe it would be worth it double-checking. The draft says the following which covey it (IMO): Section 2.2, p.5 BGP update messages without the BGPsec_Path attribute MAY be sent within a session regardless of whether or not the use of BGPsec is successfully negotiated. #Sriram: BGP update messages without the BGPsec_Path attribute == Traditional BGP update message with AS_PATH (I should make that substitution in the document for clarity.) Top of Section 4.4: BGPsec update messages do not contain the AS_PATH attribute. However, the AS_PATH attribute can be reconstructed from the BGPsec_Path attribute. This is necessary in the case where a route advertisement is received via a BGPsec update message and then propagated to a peer via a non-BGPsec update message (e.g., because the latter peer does not support BGPsec). Section 7, p 32. How will migration from BGP to BGPsec look like? What are the benefits for the first adopters? Initially small groups of contiguous ASes would be doing BGPsec. There would be possibly one or more such groups in different geographic regions of the global Internet. Only the routes originated within each group and propagated within its borders would get the benefits of cryptographic AS path protection. As BGPsec adoption grows, each group grows in size and eventually they join together to form even larger BGPsec capable groups of contiguous ASes. The benefit for early adopters starts with AS path security within the contiguous-AS regions spanned by their respective groups. Over time they would see those contiguous-AS regions grow much larger. But I'll see if Alvaro's wording can be additionally folded into the document in an appropriate place. Thank you. Sriram ________________________________________ From: Mirja Kuehlewind (IETF) <ietf@kuehlewind.net> Sent: Tuesday, January 17, 2017 10:52 AM To: Alvaro Retana (aretana) Cc: Sriram, Kotikalapudi (Fed); draft-ietf-sidr-bgpsec-protocol@ietf.org; Alexey Melnikov; sidr-chairs@ietf.org; The IESG; sidr@ietf.org; Matthias Waehlisch Subject: Re: Mirja Kühlewind's No Objection on draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT) Hi Alvaro, thanks for the very clear clarification. Not sure if it’s just me or if that’s not clearly stated in the draft, but maybe it would be worth it double-checking. Mirja Am 17.01.2017 um 16:47 schrieb Alvaro Retana (aretana) <aretana@cisco.com>: Mirja: Hi! If an AS in the path doesn’t support BGPsec, then BGP goes back to “normal” mode (as in before BGPsec), and the assurance that the “update propagated via the sequence of ASes listed” is lost. In other words, from the origin AS to the AS before the one not supporting BGPsec, we can still provide the assurance, but not beyond that – so any AS including and beyond the one not supporting BGPsec won’t be able to verify anything. Alvaro. Hi Sriram, thanks for your reply. That’s all fine. I really didn’t expect any protocol changes at this late stage of the draft but wanted at least to know if these points were previously discussed. Also happy to see that some parts where discussed with Ross. One final question (related to point 4): What happens if one router on the path does not support\/understand BGPsec? Sorry, if that is a stupid question but it’s still not fully clear to me from the draft… Mirja … 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.)"}
{"_id":"doc-en-sidr-SeEgng6FxoBF98M4_hhudX4yWek","title":"","text":"Re: [sidr] Ben Campbell's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nThanks for the response. I have one remaining comment, below. I removed sections that I think are resolved. Thanks! Ben. - 8.4, last paragraph: The text describes a replay attack, and delegates the mitigation solution to. This is an informational reference; it draft-ietf-sidr-bgpsec-rollover seems like it should be normative. The solution for mitigation of replay attacks is out of band (in relation to the BGPsec protocol). As I see it, draft-ietf-sidr-bgpsec-rollover proposes 'a way' of replay attack mitigation. Techniques for key rollover \/ replay attack mitigation are expected to continue to evolve. There are various variants of the basic key rollover technique that are discussed in this informational draft: https:\/\/tools.ietf.org\/html\/draft-sriram-replay-protection-design-discussion-07 What needs to be pointed out in the BGPsec specification is that there are solutions available for replay attack mitigation. The above are the reasons why draft-ietf-sidr-bgpsec-rollover is included in informational references. That is a reasonable response, if you think it is realistic that people would implement solutions other than the one in the reference. It would help if the text were more clear that draft-ietf-sider-bgpsec rollover is an example of a possible solutions, and other solutions are possible."}
{"_id":"doc-en-sidr-WJ64R3Udi2jQlHwGmjmbx78F0Lw","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nACK On 1\/17\/17, 10:52 AM, \"Mirja Kuehlewind (IETF)\" <ietf@kuehlewind.net<mailto:ietf@kuehlewind.net>> wrote: thanks for the very clear clarification. Not sure if it’s just me or if that’s not clearly stated in the draft, but maybe it would be worth it double-checking. ACK thanks for the very clear clarification. Not sure if it’s just me or if that’s not clearly stated in the draft, but maybe it would be worth it double-checking."}
{"_id":"doc-en-sidr-K9OgDlUueDfOdVNnfC5iQ_p2vTU","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nHi Alvaro, thanks for the very clear clarification. Not sure if it’s just me or if that’s not clearly stated in the draft, but maybe it would be worth it double-checking. Mirja Am 17.01.2017 um 16:47 schrieb Alvaro Retana (aretana) <aretana@cisco.com>: Mirja: Hi! If an AS in the path doesn’t support BGPsec, then BGP goes back to “normal” mode (as in before BGPsec), and the assurance that the “update propagated via the sequence of ASes listed” is lost. In other words, from the origin AS to the AS before the one not supporting BGPsec, we can still provide the assurance, but not beyond that – so any AS including and beyond the one not supporting BGPsec won’t be able to verify anything. Alvaro. Hi Sriram, thanks for your reply. That’s all fine. I really didn’t expect any protocol changes at this late stage of the draft but wanted at least to know if these points were previously discussed. Also happy to see that some parts where discussed with Ross. One final question (related to point 4): What happens if one router on the path does not support\/understand BGPsec? Sorry, if that is a stupid question but it’s still not fully clear to me from the draft… Mirja … 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.)"}
{"_id":"doc-en-sidr-Phr0GAd61p8maDw9yP6rU9LthyE","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nSriram: Hi! Yes, I think I may have read more into Keyur’s comment than what he was asking for, so I think we’re ready to go. ☺ I’ll approve publication. Thanks!! Alvaro. On 1\/16\/17, 10:10 PM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Hi Alvaro, ... snip ... Alvaro wrote: I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. Keyur responded: #Keyur: Ack. Though I was only requesting some text clarification so that it is very clear to the implementers. So there was no change required as Keyur points out. Oliver also agreed with Keyur's observation when I ran this by him last week. Per Keyur's request, I have added the following text clarification in Section 7: During Graceful Restart (GR), restarting and receiving BGPsec speakers MUST follow the procedures specified in [RFC4724] for restarting and receiving BGP speakers, respectively. In particular, the behavior of retaining the forwarding state for the routes in the Loc-RIB [RFC4271] and marking them as stale as well as not differentiating between stale and other information during forwarding will be the same as specified in [RFC4724]. ...snip... Alvaro wrote: …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Per your suggestion, I have added the following text in Section 4.4: Finally, one special case of reconstruction of AS_PATH is when the BGPsec_Path attribute is absent. As explained in Section 4.1, when a BGPsec speaker originates a prefix and sends it to a BGPsec-capable iBGP peer, the BGPsec_Path is not attached. So when received from a BGPsec-capable iBGP peer, no BGPsec_Path attribute in a BGPsec update is equivalent to an empty AS_PATH [RFC4271]. Please let me know if you have any comments\/questions. Thank you. Sriram Sriram: Hi! Yes, I think I may have read more into Keyur’s comment than what he was asking for, so I think we’re ready to go. J I’ll approve publication. Thanks!! Alvaro. Hi Alvaro, ... snip ... Alvaro wrote: I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. Keyur responded: #Keyur: Ack. Though I was only requesting some text clarification so that it is very clear to the implementers. So there was no change required as Keyur points out. Oliver also agreed with Keyur's observation when I ran this by him last week. Per Keyur's request, I have added the following text clarification in Section 7: During Graceful Restart (GR), restarting and receiving BGPsec speakers MUST follow the procedures specified in [RFC4724] for restarting and receiving BGP speakers, respectively. In particular, the behavior of retaining the forwarding state for the routes in the Loc-RIB [RFC4271] and marking them as stale as well as not differentiating between stale and other information during forwarding will be the same as specified in [RFC4724]. ...snip... Alvaro wrote: …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Per your suggestion, I have added the following text in Section 4.4: Finally, one special case of reconstruction of AS_PATH is when the BGPsec_Path attribute is absent. As explained in Section 4.1, when a BGPsec speaker originates a prefix and sends it to a BGPsec-capable iBGP peer, the BGPsec_Path is not attached. So when received from a BGPsec-capable iBGP peer, no BGPsec_Path attribute in a BGPsec update is equivalent to an empty AS_PATH [RFC4271]. Please let me know if you have any comments\/questions. Thank you. Sriram"}
{"_id":"doc-en-sidr-_QEf209rm6oqku7LUEOiZb9IA5Q","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nMirja: Hi! If an AS in the path doesn’t support BGPsec, then BGP goes back to “normal” mode (as in before BGPsec), and the assurance that the “update propagated via the sequence of ASes listed” is lost. In other words, from the origin AS to the AS before the one not supporting BGPsec, we can still provide the assurance, but not beyond that – so any AS including and beyond the one not supporting BGPsec won’t be able to verify anything. Alvaro. On 1\/17\/17, 6:05 AM, \"Mirja Kuehlewind (IETF)\" <ietf@kuehlewind.net<mailto:ietf@kuehlewind.net>> wrote: Hi Sriram, thanks for your reply. That’s all fine. I really didn’t expect any protocol changes at this late stage of the draft but wanted at least to know if these points were previously discussed. Also happy to see that some parts where discussed with Ross. One final question (related to point 4): What happens if one router on the path does not support\/understand BGPsec? Sorry, if that is a stupid question but it’s still not fully clear to me from the draft… Mirja … 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.) Mirja: Hi! If an AS in the path doesn’t support BGPsec, then BGP goes back to “normal” mode (as in before BGPsec), and the assurance that the “update propagated via the sequence of ASes listed” is lost. In other words, from the origin AS to the AS before the one not supporting BGPsec, we can still provide the assurance, but not beyond that – so any AS including and beyond the one not supporting BGPsec won’t be able to verify anything. Alvaro. Hi Sriram, thanks for your reply. That’s all fine. I really didn’t expect any protocol changes at this late stage of the draft but wanted at least to know if these points were previously discussed. Also happy to see that some parts where discussed with Ross. One final question (related to point 4): What happens if one router on the path does not support\/understand BGPsec? Sorry, if that is a stupid question but it’s still not fully clear to me from the draft… Mirja … 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.)"}
{"_id":"doc-en-sidr-9BIFjQzWisNnHj8FjhiumS1viaw","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nHi Sriram, thanks for your reply. That’s all fine. I really didn’t expect any protocol changes at this late stage of the draft but wanted at least to know if these points were previously discussed. Also happy to see that some parts where discussed with Ross. One final question (related to point 4): What happens if one router on the path does not support\/understand BGPsec? Sorry, if that is a stupid question but it’s still not fully clear to me from the draft… Mirja Am 13.01.2017 um 22:31 schrieb Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov>: Hi Mirja, Sorry for the delay in replying. Thank you for your careful review, and the detailed and helpful comments. Please see my responses inline below marked with [Sriram]. Changes reflecting your suggestions as discussed below have been incorporated in the forthcoming version-22. First, thanks for a well written document! Thank you. A few question on the design; not to propose changes but I would like to learn the reason why the design is as it is: 1) Why do you need to send two different negotiation capabilities for each direction instead of just using two flags in the same capability? And similar why don't you just announce multiple address families in the same capability (using variable length)? [Sriram] Oliver Borchert (implementer of one of two available implementations) posted his thoughts on this earlier (responding to a similar question from Russ Housley). He had preference for the way currently it is (please see “To Comment 2” in the link below): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08130.html [Sriram] Also, Keyur and I talked about this issue in a phone call last week. He would have preferred combining those messages (in agreement with you), but thought it was a minor issue and could be left as is for now. He also suggested that if, down the road, router vendor implementers express strong preference for it, a bis can be published. Russ also thought it was minor and was also agreeable to leaving it as is. Please let me know if you still feel strongly. 2) Why are the Secure_Path elements and Signature_Block blocks not aligned but in two different lists (given there is and one to one mapping)? Wouldn't it be easier to just update one length field (at a fixed position) and attached the new information at the end? Or to ask the question differently: why is the format as shown in figure 8 not used in the message itself (->this is related to Suresh's question)? [Sriram] The short answer is that the protocol designers felt that in the bytes sent on the wire, it made sense that the whole Secure_Path should be together and the set of Signatures should be together. For instance, then it is easy to convert Secure_Path to AS_PATH if the update needs to be forwarded unsigned to a non-BGPsec peer. The Secure_Path in its entirety is also used in the checks performed in the list in Section 5.2. [Sriram] Regarding Figure 8 (format for the data to be hashed), Oliver offered the rationale for it in the following post back when we first made the switch to this format. Michael Baer (implementer of the other available implementation), Oliver, myself, and Matt Lepinski discussed\/reviewed it in detail and then we proceeded to include it in the specification. https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU [Sriram] Suresh and Alexey seemed to appreciate the rationale that was applied for the format in Figure 8 (after they read Oliver’s explanation): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08237.html Questions on operation: 1) section 5 says \"a BGPsec speaker MAY temporarily defer validation of incoming BGPsec update messages\". Does this mean it has to remember its state before applying the update message such that is can revert to this state if it later detects that die update message was not valid? Or what action is supposed to happen if the update message is detected as not valid later on [Sriram] It is left up to an implementation the mechanism for saving the state and returning to where it was left off. If the router deferred validation, it comes back later and completes the validation. If an update message is detected not valid later, the action would be similar to what is done when update validity state change occurs due to an RPKI state change, i.e. re-run best path selection – see excerpt below (Section 5, p.22): For example, when a given RPKI certificate ceases to be valid (e.g., it expires or is revoked), all update messages containing a signature whose SKI matches the SKI in the given certificate must be re- assessed to determine if they are still valid. If this reassessment determines that the validity state of an update has changed then, depending on local policy, it may be necessary to re-run best path selection. 2) sec 4.2 says \"Next, the BGPsec speaker generates one or two Signature_Blocks.\" Are you sure it's at max 2? I guess this depends on the expected update cycles of the algorithm compared to the devices. Given update cycles for devices can be very slow and updates for algorithm can be fast if any security problems are detected, I wouldn't recommend to limit this to two. [Sriram] This was discussed at an IETF SIDR meeting extensively, and the WG had consensus that two Signature_Blocks would be adequate. 3) In relation to the comment above, I'm not a big fan of the algo migration strategy in section 6.1. I understand the problem that all router on the path need to potentially support the algo. However, you do have an negotiation phase. So why don't you the advertise the signing algorithm in the negotiation capabilities? In this case the sender could at least choose to only send the one(s) that is\/are also supported by the receiver or not use BGPsec at all if there is no match. However, I also understand that it is probably to late to change anything now and if there is wg consensus, I'm fine with that... [Sriram] The WG has had consensus on this for quite some time now – that instead of negotiation upfront, the Signature_Block(s) in the update must indicate what algorithm(s) is(are) used. 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.) 5) Is it really necessary to create registries for \"BGPsec Capability\" and \"BGPsec_Path Flags\"? Given this is a really small number of bits\/flags, I think new RFCs that update this RFC are enough to define a new use for these so far unused bits. [Sriram] This came up in the Russ Housley’s review also. But later he agreed it was OK to include these. He offered some suggestions for clarifying the bits (fields) that were already fully specified in the protocol, and hence didn’t need any IANA consideration. His suggestions were incorporated in the IANA section in version 21. Further, editorial proposals: 1) I would propose to add the Confed_Segment flag in figure 5 (and call the remaining flag field 'reserved') [Sriram] Good idea. I have made the change in the forthcoming version-22. 2) Maybe explain Adj-RIB-In or give a reference to RFCrfc4271 section 1.1 [Sriram] Done. I’ve provided the reference to RFC4271. Sriram"}
{"_id":"doc-en-sidr--DSw6X21IJniwFpuY6KZ2NrEW0U","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nHi Alvaro, ... snip ... Alvaro wrote: I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. Keyur responded: #Keyur: Ack. Though I was only requesting some text clarification so that it is very clear to the implementers. So there was no change required as Keyur points out. Oliver also agreed with Keyur's observation when I ran this by him last week. Per Keyur's request, I have added the following text clarification in Section 7: During Graceful Restart (GR), restarting and receiving BGPsec speakers MUST follow the procedures specified in [RFC4724] for restarting and receiving BGP speakers, respectively. In particular, the behavior of retaining the forwarding state for the routes in the Loc-RIB [RFC4271] and marking them as stale as well as not differentiating between stale and other information during forwarding will be the same as specified in [RFC4724]. ...snip... Alvaro wrote: …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Per your suggestion, I have added the following text in Section 4.4: Finally, one special case of reconstruction of AS_PATH is when the BGPsec_Path attribute is absent. As explained in Section 4.1, when a BGPsec speaker originates a prefix and sends it to a BGPsec-capable iBGP peer, the BGPsec_Path is not attached. So when received from a BGPsec-capable iBGP peer, no BGPsec_Path attribute in a BGPsec update is equivalent to an empty AS_PATH [RFC4271]. Please let me know if you have any comments\/questions. Thank you. Sriram"}
{"_id":"doc-en-sidr-5tFEzCIxAhIy67306vSj1LWn7LU","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-22.txt\nThis revision addresses the comments from the IESG reviewers, and also the comments from Keyur (RTGDIR review) and Alvaro (some new comments in the context of Keyur’s comments). It also addresses comments from Oliver and Randy (mainly suggestions for making Sections 4.3 and 7 a bit crisper and more clear). I noticed that Stephen cleared his Discuss points after seeing this revision, and he has updated his position to Yes. Thank you, Stephen. I had responded earlier to comments from Mirja, Alissa, Suresh, Alexey, Ben, and Spencer. This revision incorporates changes based on their comments as outlined in my responses to them on the WG list. Thank you all for greatly helping steer this document towards better clarity, accuracy, and presentation. Please let me know if I have missed responding to any of your comments. Sriram ________________________________________ From: sidr <sidr-bounces@ietf.org> on behalf of internet-drafts@ietf.org <internet-drafts@ietf.org> Sent: Monday, January 16, 2017 6:11 PM To: i-d-announce@ietf.org Cc: sidr@ietf.org Subject: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-22.txt A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-22.txt Pages : 44 Date : 2017-01-16 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-22 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-22 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-uMuzhOnfKKDwcpO1zkBFCqm-qVU","title":"","text":"[sidr] Stephen Farrell's Yes on draft-ietf-sidr-bgpsec-protocol-22:\n (with COMMENT)\nStephen Farrell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-22: Yes When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- Thanks for addressing my discuss points."}
{"_id":"doc-en-sidr-nDPAI8M36GgFdRvKwtFXvyQ9UnI","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-22.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-22.txt Pages : 44 Date : 2017-01-16 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-22 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-22 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-SzU7-q56Ze2OOA_0FFRLLxh4s70","title":"","text":"Re: [sidr] Ben Campbell's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Ben, Sorry for the delay in responding. Thank you for the review and very helpful comments. Please see my responses inline below. The changes mentioned below that reflect your comments\/suggestions are already incorporated in the forthcoming version-22. -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. [Update: Oops, sorry, I meant to say draft-ietf-sidr-bgpsec-ops excludes non-capitalized versions of 2119 words. (That is to say, it treats them as their normal English equivalents.)] Thank you for pointing this out. I have gone over the whole document and wherever the standards language [RFC 2119] is applicable, I have made sure that upper case “MUST”, “SHOULD” etc. are used rather than lower case “must”, “should” etc. - 5.2, step 2: I'm almost sure I've missed something here, but if I understand correctly, previous sections talked about how a peer can propagate a BGPsec_Path attribute without modification. Will that cause a problem in this step if the immediate peer propagated an unmodified BGPsec_Path that came from a different AS? You are right in pointing this out. The key is that 5.2, step 2 check is meant to be done with eBGP peer (not iBGP). Unmodified BGPsec update is sent only to BGPsec-capable iBGP peers (internal peers). In the case of an eBGP (BGPsec capable) peer, the BGPsec update is always modified and propagated with a new Secure_Path Segment and Signature added. So I have modified the wording in 5.2, step 2 to read as follows: 2. Check that AS number in the most recently added Secure_Path Segment (i.e. the one corresponding to the eBGP peer from which the update message was received) matches the AS number of that peer as specified in the BGP OPEN message. (Note: This check is performed only at an ingress BGPsec router where the update is first received from a peer AS.) - 8.4, last paragraph: The text describes a replay attack, and delegates the mitigation solution to. This is an informational reference; it draft-ietf-sidr-bgpsec-rollover seems like it should be normative. The solution for mitigation of replay attacks is out of band (in relation to the BGPsec protocol). As I see it, draft-ietf-sidr-bgpsec-rollover proposes 'a way' of replay attack mitigation. Techniques for key rollover \/ replay attack mitigation are expected to continue to evolve. There are various variants of the basic key rollover technique that are discussed in this informational draft: https:\/\/tools.ietf.org\/html\/draft-sriram-replay-protection-design-discussion-07 What needs to be pointed out in the BGPsec specification is that there are solutions available for replay attack mitigation. The above are the reasons why draft-ietf-sidr-bgpsec-rollover is included in informational references. Sriram"}
{"_id":"doc-en-sidr-iOxjbbBQB5--I1t7ByQFTLBGpzg","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nHi Mirja, Sorry for the delay in replying. Thank you for your careful review, and the detailed and helpful comments. Please see my responses inline below marked with [Sriram]. Changes reflecting your suggestions as discussed below have been incorporated in the forthcoming version-22. First, thanks for a well written document! Thank you. A few question on the design; not to propose changes but I would like to learn the reason why the design is as it is: 1) Why do you need to send two different negotiation capabilities for each direction instead of just using two flags in the same capability? And similar why don't you just announce multiple address families in the same capability (using variable length)? [Sriram] Oliver Borchert (implementer of one of two available implementations) posted his thoughts on this earlier (responding to a similar question from Russ Housley). He had preference for the way currently it is (please see “To Comment 2” in the link below): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08130.html [Sriram] Also, Keyur and I talked about this issue in a phone call last week. He would have preferred combining those messages (in agreement with you), but thought it was a minor issue and could be left as is for now. He also suggested that if, down the road, router vendor implementers express strong preference for it, a bis can be published. Russ also thought it was minor and was also agreeable to leaving it as is. Please let me know if you still feel strongly. 2) Why are the Secure_Path elements and Signature_Block blocks not aligned but in two different lists (given there is and one to one mapping)? Wouldn't it be easier to just update one length field (at a fixed position) and attached the new information at the end? Or to ask the question differently: why is the format as shown in figure 8 not used in the message itself (->this is related to Suresh's question)? [Sriram] The short answer is that the protocol designers felt that in the bytes sent on the wire, it made sense that the whole Secure_Path should be together and the set of Signatures should be together. For instance, then it is easy to convert Secure_Path to AS_PATH if the update needs to be forwarded unsigned to a non-BGPsec peer. The Secure_Path in its entirety is also used in the checks performed in the list in Section 5.2. [Sriram] Regarding Figure 8 (format for the data to be hashed), Oliver offered the rationale for it in the following post back when we first made the switch to this format. Michael Baer (implementer of the other available implementation), Oliver, myself, and Matt Lepinski discussed\/reviewed it in detail and then we proceeded to include it in the specification. https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU [Sriram] Suresh and Alexey seemed to appreciate the rationale that was applied for the format in Figure 8 (after they read Oliver’s explanation): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08237.html Questions on operation: 1) section 5 says \"a BGPsec speaker MAY temporarily defer validation of incoming BGPsec update messages\". Does this mean it has to remember its state before applying the update message such that is can revert to this state if it later detects that die update message was not valid? Or what action is supposed to happen if the update message is detected as not valid later on [Sriram] It is left up to an implementation the mechanism for saving the state and returning to where it was left off. If the router deferred validation, it comes back later and completes the validation. If an update message is detected not valid later, the action would be similar to what is done when update validity state change occurs due to an RPKI state change, i.e. re-run best path selection – see excerpt below (Section 5, p.22): For example, when a given RPKI certificate ceases to be valid (e.g., it expires or is revoked), all update messages containing a signature whose SKI matches the SKI in the given certificate must be re- assessed to determine if they are still valid. If this reassessment determines that the validity state of an update has changed then, depending on local policy, it may be necessary to re-run best path selection. 2) sec 4.2 says \"Next, the BGPsec speaker generates one or two Signature_Blocks.\" Are you sure it's at max 2? I guess this depends on the expected update cycles of the algorithm compared to the devices. Given update cycles for devices can be very slow and updates for algorithm can be fast if any security problems are detected, I wouldn't recommend to limit this to two. [Sriram] This was discussed at an IETF SIDR meeting extensively, and the WG had consensus that two Signature_Blocks would be adequate. 3) In relation to the comment above, I'm not a big fan of the algo migration strategy in section 6.1. I understand the problem that all router on the path need to potentially support the algo. However, you do have an negotiation phase. So why don't you the advertise the signing algorithm in the negotiation capabilities? In this case the sender could at least choose to only send the one(s) that is\/are also supported by the receiver or not use BGPsec at all if there is no match. However, I also understand that it is probably to late to change anything now and if there is wg consensus, I'm fine with that... [Sriram] The WG has had consensus on this for quite some time now – that instead of negotiation upfront, the Signature_Block(s) in the update must indicate what algorithm(s) is(are) used. 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.) 5) Is it really necessary to create registries for \"BGPsec Capability\" and \"BGPsec_Path Flags\"? Given this is a really small number of bits\/flags, I think new RFCs that update this RFC are enough to define a new use for these so far unused bits. [Sriram] This came up in the Russ Housley’s review also. But later he agreed it was OK to include these. He offered some suggestions for clarifying the bits (fields) that were already fully specified in the protocol, and hence didn’t need any IANA consideration. His suggestions were incorporated in the IANA section in version 21. Further, editorial proposals: 1) I would propose to add the Confed_Segment flag in figure 5 (and call the remaining flag field 'reserved') [Sriram] Good idea. I have made the change in the forthcoming version-22. 2) Maybe explain Adj-RIB-In or give a reference to RFCrfc4271 section 1.1 [Sriram] Done. I’ve provided the reference to RFC4271. Sriram Hi Mirja, Sorry for the delay in replying. Thank you for your careful review, and the detailed and helpful comments. Please see my responses inline below marked with [Sriram]. Changes reflecting your suggestions as discussed below have been incorporated in the forthcoming version-22. First, thanks for a well written document! Thank you. A few question on the design; not to propose changes but I would like to learn the reason why the design is as it is: 1) Why do you need to send two different negotiation capabilities for each direction instead of just using two flags in the same capability? And similar why don't you just announce multiple address families in the same capability (using variable length)? [Sriram] Oliver Borchert (implementer of one of two available implementations) posted his thoughts on this earlier (responding to a similar question from Russ Housley). He had preference for the way currently it is (please see “To Comment 2” in the link below): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08130.html [Sriram] Also, Keyur and I talked about this issue in a phone call last week. He would have preferred combining those messages (in agreement with you), but thought it was a minor issue and could be left as is for now. He also suggested that if, down the road, router vendor implementers express strong preference for it, a bis can be published. Russ also thought it was minor and was also agreeable to leaving it as is. Please let me know if you still feel strongly. 2) Why are the Secure_Path elements and Signature_Block blocks not aligned but in two different lists (given there is and one to one mapping)? Wouldn't it be easier to just update one length field (at a fixed position) and attached the new information at the end? Or to ask the question differently: why is the format as shown in figure 8 not used in the message itself (->this is related to Suresh's question)? [Sriram] The short answer is that the protocol designers felt that in the bytes sent on the wire, it made sense that the whole Secure_Path should be together and the set of Signatures should be together. For instance, then it is easy to convert Secure_Path to AS_PATH if the update needs to be forwarded unsigned to a non-BGPsec peer. The Secure_Path in its entirety is also used in the checks performed in the list in Section 5.2. [Sriram] Regarding Figure 8 (format for the data to be hashed), Oliver offered the rationale for it in the following post back when we first made the switch to this format. Michael Baer (implementer of the other available implementation), Oliver, myself, and Matt Lepinski discussed\/reviewed it in detail and then we proceeded to include it in the specification. https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU [Sriram] Suresh and Alexey seemed to appreciate the rationale that was applied for the format in Figure 8 (after they read Oliver’s explanation): https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08237.html Questions on operation: 1) section 5 says \"a BGPsec speaker MAY temporarily defer validation of incoming BGPsec update messages\". Does this mean it has to remember its state before applying the update message such that is can revert to this state if it later detects that die update message was not valid? Or what action is supposed to happen if the update message is detected as not valid later on [Sriram] It is left up to an implementation the mechanism for saving the state and returning to where it was left off. If the router deferred validation, it comes back later and completes the validation. If an update message is detected not valid later, the action would be similar to what is done when update validity state change occurs due to an RPKI state change, i.e. re-run best path selection – see excerpt below (Section 5, p.22): For example, when a given RPKI certificate ceases to be valid (e.g., it expires or is revoked), all update messages containing a signature whose SKI matches the SKI in the given certificate must be re- assessed to determine if they are still valid. If this reassessment determines that the validity state of an update has changed then, depending on local policy, it may be necessary to re-run best path selection. 2) sec 4.2 says \"Next, the BGPsec speaker generates one or two Signature_Blocks.\" Are you sure it's at max 2? I guess this depends on the expected update cycles of the algorithm compared to the devices. Given update cycles for devices can be very slow and updates for algorithm can be fast if any security problems are detected, I wouldn't recommend to limit this to two. [Sriram] This was discussed at an IETF SIDR meeting extensively, and the WG had consensus that two Signature_Blocks would be adequate. 3) In relation to the comment above, I'm not a big fan of the algo migration strategy in section 6.1. I understand the problem that all router on the path need to potentially support the algo. However, you do have an negotiation phase. So why don't you the advertise the signing algorithm in the negotiation capabilities? In this case the sender could at least choose to only send the one(s) that is\/are also supported by the receiver or not use BGPsec at all if there is no match. However, I also understand that it is probably to late to change anything now and if there is wg consensus, I'm fine with that... [Sriram] The WG has had consensus on this for quite some time now – that instead of negotiation upfront, the Signature_Block(s) in the update must indicate what algorithm(s) is(are) used. 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? [Sriram] Yes, it is true. Each AS in the path MUST sign to the next AS (Target AS). Section 3.1 says: The Secure_Path contains one Secure_Path Segment (see Figure 5) for each Autonomous System in the path to the originating AS of the prefix specified in the update message. [Sriram] Also, Section 3.2 says: A Signature_Block in Figure 6 has exactly one Signature Segment (see Figure 7) for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path Attribute. [Sriram] The following check listed in Section 5.2 make it clear as well: 3. Check that each Signature_Block contains one Signature segment for each Secure_Path Segment in the Secure_Path portion of the BGPsec_Path attribute. (Note that the entirety of each Signature_Block must be checked to ensure that it is well formed, even though the validation process may terminate before all signatures are cryptographically verified.) 5) Is it really necessary to create registries for \"BGPsec Capability\" and \"BGPsec_Path Flags\"? Given this is a really small number of bits\/flags, I think new RFCs that update this RFC are enough to define a new use for these so far unused bits. [Sriram] This came up in the Russ Housley’s review also. But later he agreed it was OK to include these. He offered some suggestions for clarifying the bits (fields) that were already fully specified in the protocol, and hence didn’t need any IANA consideration. His suggestions were incorporated in the IANA section in version 21. Further, editorial proposals: 1) I would propose to add the Confed_Segment flag in figure 5 (and call the remaining flag field 'reserved') [Sriram] Good idea. I have made the change in the forthcoming version-22. 2) Maybe explain Adj-RIB-In or give a reference to RFCrfc4271 section 1.1 [Sriram] Done. I’ve provided the reference to RFC4271. Sriram"}
{"_id":"doc-en-sidr-yGs4MwRR72uICDyqm44lwfy29X4","title":"","text":"Re: [sidr] Spencer Dawkins' No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nYou folks are headed in the right direction. I'll be happy wherever you end up. Thanks! Spencer On Thursday, January 12, 2017, Randy Bush <randy@psg.com> wrote: Note that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. isn't a MUST, but Section 7 explains this In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. how about just saying A router announcing the capability to send or to receive BGPsec updates MUST also announce the capability to send and receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. and call it a day? randy You folks are headed in the right direction. I'll be happy wherever you end up.Thanks!Spencer>> Note that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. isn't a MUST, but Section 7 explains this In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. how about just saying A router announcing the capability to send or to receive BGPsec updates MUST also announce the capability to send and receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. and call it a day? randy"}
{"_id":"doc-en-sidr-YmIIJXyh_SikJJQ8_bHkC7712zI","title":"","text":"Re: [sidr] Spencer Dawkins' No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nNote that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. isn't a MUST, but Section 7 explains this In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. how about just saying A router announcing the capability to send or to receive BGPsec updates MUST also announce the capability to send and receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. and call it a day? randy"}
{"_id":"doc-en-sidr-4MqOAk4o0ZN2xYair0m4OfUx80g","title":"","text":"Re: [sidr] Spencer Dawkins' No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Spencer, Please see my comments inline below marked with [Sriram]. I have made changes in the document in response to your comments. You’ll see them in version-22 (to be uploaded in the next few days). Perhaps I'm just having a good day, but this is one of the clearest BGP-related specifications I can remember reviewing. Thanks for that, and especially for the background on design decisions. [Sriram] Very kind of you. Thank you. I did have questions on two points (which are spread across multiple sections). I started out wondering why Note that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. isn't a MUST, but Section 7 explains this In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. Perhaps that's worth a forward pointer? (or maybe even dragging this paragraph forward from Section 7) [Sriram] I have put in a forward pointer in Section 2.2. It reads, “Please see related operational guidance in Section 7.” I'm looking at BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero. (That is, pCount is only to be set to zero in cases such as route servers or AS Number Migration where the BGPsec speaker's peer expects pCount to be set to zero.) and wondering why that's not a MUST. If I'm understanding this correctly (which is theoretically possible), the BGPsec speaker is telling its peer that it's not participating as a transit AS, but the peer thinks it should be. Is there anything intelligent that the peer can do with the update? [Sriram] You are absolutely right: MUST makes sense. Because later in Section 5.2 check list, we say: 7. If the update message was received from a peer that is not expected to set pCount equal to zero (see Section 4.2 and Section 4.3) then check to ensure that the pCount field in the most-recently added Secure_Path Segment is not equal to zero. (See router configuration guidance related to this in Section 7.) [Sriram] In Section 5.2, we also say: If any of these checks fail, it is an error in the BGPsec_Path attribute. [Sriram] Since the receiver action is clearly stated in Section 5.2, I have dropped the two sentences you cited beginning with “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero…” from Section 4.2 which is all about sender actions. That particular paragraph now reads: A route server that participates in the BGP control plane, but does not act as a transit AS in the data plane, may choose to set pCount to 0. This option enables the route server to participate in BGPsec and obtain the associated security guarantees without increasing the length of the AS path. (Note that BGPsec speakers compute the length of the AS path by summing the pCount values in the BGPsec_Path attribute, see Section 5.) However, when a route server sets the pCount value to 0, it still inserts its AS number into the Secure_Path Segment, as this information is needed to validate the signature added by the route server. See [I-D.ietf-sidr-as-migration] for a discussion of setting pCount to 0 to facilitate AS Number Migration. Also see Section 4.3 for the use of pCount=0 in the context of an AS confederation. See Section 7 for operational guidance for configuring a BGPsec router for setting pCount=0 and\/or accepting pCount=0 from a peer. Section 7 refers to this SHOULD, while adding a few more SHOULDs. A peer that is an Internet Exchange Point (IXP) (i.e. Route Server) with a transparent AS is expected to set pCount = 0 in its Secure_Path Segment while forwarding an update to a peer (see Section 4.2). Clearly, such an IXP SHOULD configure itself to set its own pCount = 0. As stated in Section 4.2, \"BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.\" This means that a BGPsec speaker SHOULD be configured so that it permits pCount =0 from an IXP peer and never permits pCount = 0 from a peer that is not an IXP. Again, I'm curious about why a BGPsec speaker wouldn't do this. Is that obvious, to those skilled in the art? I'm looking at Section 8.4, which adds some more background. The mechanism of setting the pCount field to zero is included in this specification to enable route servers in the control path to participate in BGPsec without increasing the length of the AS path. However, entities other than route servers could conceivably use this mechanism (set the pCount to zero) to attract traffic (by reducing the length of the AS path) illegitimately. This risk is largely mitigated if every BGPsec speaker drops incoming update messages that set pCount to zero but come from a peer that is not a route server. However, note that a recipient of a BGPsec update message within which an upstream entity two or more hops away has set pCount to zero is unable to verify for themselves whether pCount was set to zero legitimately. So, the reason this is a SHOULD, and not a MUST, is because a recipient two or more hops away can't be sure pCount was set appropriately? But doesn't the SHOULD increase the chances to propagate an update with an inappropriate pCount? [Sriram] I light of what I said above, I have revised the paragraph in Section 7 to read: A peer that is an Internet Exchange Point (IXP) (i.e. Route Server) with a transparent AS is expected to set pCount=0 in its Secure_Path Segment while forwarding an update to a peer (see Section 4.2). Clearly, such an IXP must configure its BGPsec router to set pCount=0 in its Secure_Path Segment. This also means that a BGPsec speaker MUST be configured so that it permits pCount=0 from an IXP peer. Two other cases where pCount is set to zero are in the context AS confederation (see Section 4.2) and AS migration [I-D.ietf-sidr-as-migration]. In these two cases, pCount=0 is set and accepted within the same AS (albeit the AS has two different identities). Note that if a BGPsec speaker does not expect a peer AS to set its pCount=0, and if an update received from that peer violates this, then the update MUST be considered to be in error (see the list of checks in Section 5.2). See Section 8.4 for a discussion of security considerations concerning pCount=0. [Sriram] I light of what I said above, I have also revised the paragraph in Section 8.4 to read: The mechanism of setting the pCount field to zero is included in this specification to enable route servers in the control path to participate in BGPsec without increasing the length of the AS path. Two other scenarios where pCount=0 is utilized are in the context AS confederation (see Section 4.2) and AS migration [I-D.ietf-sidr-as-migration]. In these two scenarios, pCount=0 is set and also accepted within the same AS (albeit the AS has two different identities). However, entities other than route servers, confederation ASes or migrating ASes could conceivably use this mechanism (set the pCount to zero) to attract traffic (by reducing the length of the AS path) illegitimately. This risk is largely mitigated if every BGPsec speaker follows the operational guidance in Section 7 for configuration for setting pCount=0 and\/or accepting pCount=0 from a peer. However, note that a recipient of a BGPsec update message within which an upstream entity two or more hops away has set pCount to zero is unable to verify for themselves whether pCount was set to zero legitimately. Sriram"}
{"_id":"doc-en-sidr-38Zc3JhgceuZoX5jdCj1Jq-LbrA","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Suresh, Thank you for this suggestion as well: * Section 2.1 The IANA registry at http:\/\/www.iana.org\/assignments\/address-family-numbers\/address-family-numbers.xhtml may be a better reference for AFIs than RFC4760. It has been incorporated in my editor copy of version 22 (to be uploaded in a couple of days). Sriram ________________________________________ From: Suresh Krishnan <suresh.krishnan@ericsson.com> Sent: Wednesday, January 11, 2017 10:53 PM To: Alexey Melnikov Cc: Sriram, Kotikalapudi (Fed); sidr wg list; Sean Turner; sidr chairs; draft-ietf-sidr-bgpsec-protocol@ietf.org; The IESG; m.waehlisch@fu-berlin.de Subject: Re: [sidr] Alexey Melnikov's Yes on draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT) On Jan 11, 2017, at 5:34 PM, Alexey Melnikov <aamelnikov@fastmail.fm<mailto:aamelnikov@fastmail.fm>> wrote: Hi Sriram, On 11 Jan 2017, at 20:17, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Hi Alexey, My comment in line below. From: Alexey Melnikov [mailto:aamelnikov@fastmail.fm] Sent: Thursday, January 05, 2017 4:57 AM) On 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com<mailto:suresh.krishnan@ericsson.com>> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something +like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5M U Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft. The design explanation would be a bit long as you can see from Oliver's (implementer's) post. There is a BGPsec design discussion document (to be published as an independent submission RFC): https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-11 I think that would be better place to include this design rationale as well. Works for me. FWIW, Works for me as well. Regards Suresh"}
{"_id":"doc-en-sidr-YEi4r1YKYZs2GTT1cE8GU5JRxPs","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nOn Jan 11, 2017, at 5:34 PM, Alexey Melnikov <aamelnikov@fastmail.fm<mailto:aamelnikov@fastmail.fm>> wrote: Hi Sriram, On 11 Jan 2017, at 20:17, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Hi Alexey, My comment in line below. From: Alexey Melnikov [mailto:aamelnikov@fastmail.fm] Sent: Thursday, January 05, 2017 4:57 AM) On 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com<mailto:suresh.krishnan@ericsson.com>> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: On Jan 4, 2017, at 05:09, Randy Bush <randy@psg.com<mailto:randy@psg.com>> wrote: +1 to the comment from Suresh about order. I though that something +like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5M U Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft. The design explanation would be a bit long as you can see from Oliver's (implementer's) post. There is a BGPsec design discussion document (to be published as an independent submission RFC): https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-11 I think that would be better place to include this design rationale as well. Works for me. FWIW, Works for me as well. Regards Suresh On Jan 11, 2017, at 5:34 PM, Alexey Melnikov <aamelnikov@fastmail.fm> wrote: Hi Sriram, On 11 Jan 2017, at 20:17, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> wrote: Hi Alexey, My comment in line below. From: Alexey Melnikov [mailto:aamelnikov@fastmail.fm] Sent: Thursday, January 05, 2017 4:57 AM) On 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something +like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5M U Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft. The design explanation would be a bit long as you can see from Oliver's (implementer's) post. There is a BGPsec design discussion document (to be published as an independent submission RFC): https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-11 I think that would be better place to include this design rationale as well. Works for me. FWIW, Works for me as well. Regards Suresh"}
{"_id":"doc-en-sidr-h7NE0yvW8SX7xyOxgn0k5yu_PYY","title":"","text":"Re: [sidr] Alissa Cooper's No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\n- I was surprised not to see an example message or two in this document. Sean is working together with Oliver and me on providing example messages in the draft-ietf-sidr-bgpsec-algs. Stephen and Sean agreed that would be a better place and it is happening: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08288.html Oliver has just posted the v4 examples: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/eJdWwuwTHT6DVS-MPbMQh8z6iH8 Probably worth adding an explicit pointer to the examples once we get them agreed by the WG. spt"}
{"_id":"doc-en-sidr-yauWsAmLEPtRVxPrO1qGVJnWikc","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Sriram, On 11 Jan 2017, at 20:17, Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> wrote: Hi Alexey, My comment in line below. From: Alexey Melnikov [mailto:aamelnikov@fastmail.fm] Sent: Thursday, January 05, 2017 4:57 AM) On 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something +like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5M U Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft. The design explanation would be a bit long as you can see from Oliver's (implementer's) post. There is a BGPsec design discussion document (to be published as an independent submission RFC): https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-11 I think that would be better place to include this design rationale as well. Works for me."}
{"_id":"doc-en-sidr-unJnzKWMX9GSYFYfPeIWpCUgYbY","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Alexey, My comment in line below. From: Alexey Melnikov [mailto:aamelnikov@fastmail.fm] Sent: Thursday, January 05, 2017 4:57 AM) On 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something +like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5M U Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft. The design explanation would be a bit long as you can see from Oliver's (implementer's) post. There is a BGPsec design discussion document (to be published as an independent submission RFC): https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-11 I think that would be better place to include this design rationale as well. Sriram"}
{"_id":"doc-en-sidr-EskfzSHIfCYszAvxRDyEWiUVb4I","title":"","text":"Re: [sidr] Alissa Cooper's No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nHi Alissa, Sorry for the delay in responding. Thank you for your comments. My responses inline below. I have already made the changes (as noted below) in my editor copy of the draft version-22. From: Alissa Cooper [mailto:alissa@cooperw.in] Sent: Wednesday, January 04, 2017 11:21 AM … - Fig 2: Shouldn't the signatures in Sig Block 2 have different identifiers (e.g., X2, Y2) than those in Sig Block 1? Good catch. Fixed. - Sec 6.1: \"(likely a small number of years)\" -- given how hard these things are to predict, is it wise to include this text here? I have removed the phrase in the parentheses. - I was surprised not to see an example message or two in this document. Sean is working together with Oliver and me on providing example messages in the draft-ietf-sidr-bgpsec-algs. Stephen and Sean agreed that would be a better place and it is happening: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08288.html Regards, Sriram"}
{"_id":"doc-en-sidr-v9RAr3n7eTJ3n96OzZuFUDBF4sk","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nHi Alvaro, Comments inlined #Keyur From: \"Alvaro Retana (aretana)\" <aretana@cisco.com> Date: Friday, January 6, 2017 at 3:10 PM To: \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov>, Keyur Patel <keyur@arrcus.com> Cc: \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org>, sidr <sidr@ietf.org>, \"mlepinski@ncf.edu\" <mlepinski@ncf.edu> Subject: Re: draft-ietf-sidr-bgpsec-protocol On 1\/6\/17, 12:40 AM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: [Cut the distribution list a little.] Sriram: Hi! Happy New Year! I have some comments on this, please see below. Thanks! Alvaro. … | | 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually | | exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT | | contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp | | capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We | | could add some clarifying that helps to indicate that such routes should be considered | | valid in stale mode (till they get refreshed)? | | [Sriram] As you have clarified for me on the phone, what you are saying here is that the | two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not | exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers | in GR mode. RFC4271 considers update message received without a well-known AS_PATH | attribute as an error, and unfortunately in this case the cached BGPsec updates do not have | AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" | and instead simply treat each cached update as NOT-IN-ERROR even though it is missing | AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will | have AS_PATH (and not considered in error) when they get refreshed (over the new simple | BGP session). Per your suggestion, I will include new text in Section 7 to describe this | required behavior for the GR mode. I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. #Keyur: Ack. Though I was only requesting some text clarification so that it is very clear to the implementers. Regards, Keyur … | | 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received | | without a well-known AS_PATH attribute as an error. We need some text to clarify the | | (error handling if any) behavior when an update message is received without a bgpsec and | | an aspath attribute. The current draft text seems unclear about generation of bgpsec | | attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec | | attribute? | | [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the | following : | | \"When a BGP speaker originates a route then: | b) the originating speaker includes an empty AS_PATH attribute in | all UPDATE messages sent to internal peers. (An empty AS_PATH | attribute is one whose length field contains the value zero).\" | | | [Sriram] So what needs to be said in the BGPsec document is the following: The | BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to | BGPsec capable internal peers. However, when a route is originated inside an AS and | propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the | update (see [RFC 4271], page 26). The Route Selection Section (9.1.2) in RFC4271 is not explicit about performing loop detection only on eBGP sessions – the criteria is generic to any route, so there is a possibility that a BGPsec-capable router may want to perform loop detection on an iBGP-received Update. Given this text from Section 5 in the BGPsec spec: Whenever the use of AS path information is called for (e.g., loop detection, or use of AS path length in best path selection) the externally visible behavior of the implementation shall be the same as if the implementation had run the algorithm in Section 4.4 and used the resulting AS_PATH attribute as it would for a non-BGPsec update message. …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Thanks! Alvaro. Hi Alvaro, Comments inlined #Keyur From: \"Alvaro Retana (aretana)\" <aretana@cisco.com> Date: Friday, January 6, 2017 at 3:10 PM To: \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov>, Keyur Patel <keyur@arrcus.com> Cc: \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org>, sidr <sidr@ietf.org>, \"mlepinski@ncf.edu\" <mlepinski@ncf.edu> Subject: Re: draft-ietf-sidr-bgpsec-protocol [Cut the distribution list a little.] Sriram: Hi! Happy New Year! I have some comments on this, please see below. Thanks! Alvaro. … | | 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually | | exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT | | contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp | | capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We | | could add some clarifying that helps to indicate that such routes should be considered | | valid in stale mode (till they get refreshed)? | | [Sriram] As you have clarified for me on the phone, what you are saying here is that the | two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not | exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers | in GR mode. RFC4271 considers update message received without a well-known AS_PATH | attribute as an error, and unfortunately in this case the cached BGPsec updates do not have | AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" | and instead simply treat each cached update as NOT-IN-ERROR even though it is missing | AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will | have AS_PATH (and not considered in error) when they get refreshed (over the new simple | BGP session). Per your suggestion, I will include new text in Section 7 to describe this | required behavior for the GR mode. I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. #Keyur: Ack. Though I was only requesting some text clarification so that it is very clear to the implementers. Regards, Keyur … | | 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received | | without a well-known AS_PATH attribute as an error. We need some text to clarify the | | (error handling if any) behavior when an update message is received without a bgpsec and | | an aspath attribute. The current draft text seems unclear about generation of bgpsec | | attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec | | attribute? | | [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the | following : | | \"When a BGP speaker originates a route then: | b) the originating speaker includes an empty AS_PATH attribute in | all UPDATE messages sent to internal peers. (An empty AS_PATH | attribute is one whose length field contains the value zero).\" | | | [Sriram] So what needs to be said in the BGPsec document is the following: The | BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to | BGPsec capable internal peers. However, when a route is originated inside an AS and | propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the | update (see [RFC 4271], page 26). The Route Selection Section (9.1.2) in RFC4271 is not explicit about performing loop detection only on eBGP sessions – the criteria is generic to any route, so there is a possibility that a BGPsec-capable router may want to perform loop detection on an iBGP-received Update. Given this text from Section 5 in the BGPsec spec: Whenever the use of AS path information is called for (e.g., loop detection, or use of AS path length in best path selection) the externally visible behavior of the implementation shall be the same as if the implementation had run the algorithm in Section 4.4 and used the resulting AS_PATH attribute as it would for a non-BGPsec update message. …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Thanks! Alvaro."}
{"_id":"doc-en-sidr-GJDClHtCbNFrDfwLOBQY3T_Ag5M","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\ni had to do some ascii porn for rob to deal with a secdir reviewer for draft-ietf-sidr-publication. it may help here. i added the routers for this discussion. +------+ +------+ +------+ | CA | | CA | | CA | +------+ +------+ +------+ | | | Publication Protocol | | | draft-ietf-sidr-publication +-------+ | +--------+ Business Relationship Set Up by | | | draft-ietf-sidr-rpki-oob-setup +----v---v--v-----+ | | | Publication | | Repository | | | +-----------------+ Distribution Protocols | draft-ietf-sidr-delta-protocol +--------------+----------------+ and\/or rcynic | | | +-------v-----+ +------v------+ +------v------+ | Relying | | Relying | | Relying | | Party | | Party | | Party | +-+-----+----++ +---+-----+---+ +-+--------+--+ | | | | | | | | | | ++ | | +--+ | | RPKI to Router Protocol (RFC 6810) | | | | | | | | draft-ietf-sidr-rpki-rtr-rfc6810-bis v v v v v v v v \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ |Rtr| |Rtr| |Rtr| |Rtr| |Rtr| |Rtr| |Rtr| |Rtr| \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ \\ \/ V V V V V V V V we're talking about 6810-bis here, the rpki-rtr protocol which carries the router keys and origin roas for bgpsec and origin validation. it is a total database push from the RP cache to the router, not a piecemeal router driven request protocol. so a monkey in the middle receives no clues as to what the router is using. there is no side channel leakage that i can see. i would be happy to be educated otherwise. as 6810[-bis] has stripped the crypto of the rpki validataion chain to the root TA, it no longer has object security; red alert. so the two ops drafts, 7115 for origin validation and draft-ietf-sidr-bgpsec-ops for bgpsec, try to be very explicit about transport protection for these data. draft-ietf-sidr-bgpsec-ops points to rfc 7115 for RP cache advice. As RPKI-based origin validation relies on the availability of RPKI data, operators SHOULD locate RPKI caches close to routers that require these data and services in order to minimize the impact of likely failures in local routing, intermediate devices, long circuits, etc. One should also consider trust boundaries, routing bootstrap reachability, etc. For example, a router should bootstrap from a cache that is reachable with minimal reliance on other infrastructure such as DNS or routing protocols. If a router needs its BGP and\/or IGP to converge for the router to reach a cache, once a cache is reachable, the router will then have to reevaluate prefixes already learned via BGP. Such configurations should be avoided if reasonably possible. If insecure transports are used between an operator's cache and their router(s), the Transport Security recommendations in [RFC6810] SHOULD be followed. In particular, operators MUST NOT use insecure transports between their routers and RPKI caches located in other Autonomous Systems. so maybe the bgpsec-protocol document can remove, as opposed to add, text just this once? randy"}
{"_id":"doc-en-sidr-jpvW6GYIRaZaLIM33cBh-amA-lI","title":"","text":"[sidr] Protocol Action: 'A Profile for BGPsec Router Certificates,\n Certificate Revocation Lists,\n and Certification Requests' to Proposed Standard\n (draft-ietf-sidr-bgpsec-pki-profiles-21.txt)\nThe IESG has approved the following document: - 'A Profile for BGPsec Router Certificates, Certificate Revocation Lists, and Certification Requests' (draft-ietf-sidr-bgpsec-pki-profiles-21.txt) as Proposed Standard This document is the product of the Secure Inter-Domain Routing Working Group. The IESG contact persons are Alvaro Retana, Alia Atlas and Deborah Brungard. A URL of this Internet Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-pki-profiles\/ Technical Summary This document defines a standard profile for X.509 certificates used to enable validation of Autonomous System (AS) paths in the Border Gateway Protocol (BGP), as part of an extension to that protocol known as BGPsec. This document also profiles the format of certification requests, and specifies Relying Party (RP) certificate path validation procedures for these EE certificates. This document extends the RPKI; therefore, this documents updates the RPKI Resource Certificates Profile (RFC 6487). Working Group Summary The document has received multiple reviews and consisted WG interest. Document Quality This document doesn't specify a protocol per-se, but the contents must be implemented as part of BGPsec. Personnel Shepherd: Chris Morrow - morrowc@ops-netman.net AD: Alvaro Retana - aretana@cisco.com RFC Editor Note This document is part of a group being considered by the IESG that normatively depend on draft-ietf-sidr-bgpsec-protocol; all documents are titled draft-ietf-sidr-bgpsec-*. Please make sure that draft-ietf-sidr-bgpsec-protocol has the lowest RFC number -- no consecutive numbers are needed in this case."}
{"_id":"doc-en-sidr-rbMsB3QnzN5OgipbTnj2s1r3d2w","title":"","text":"[sidr] Protocol Action: 'BGPsec Operational Considerations' to Best\n Current Practice (draft-ietf-sidr-bgpsec-ops-16.txt)\nThe IESG has approved the following document: - 'BGPsec Operational Considerations' (draft-ietf-sidr-bgpsec-ops-16.txt) as Best Current Practice This document is the product of the Secure Inter-Domain Routing Working Group. The IESG contact persons are Alvaro Retana, Alia Atlas and Deborah Brungard. A URL of this Internet Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ Technical Summary Deployment of the BGPsec architecture and protocols has many operational considerations. This document attempts to collect and present the most critical and universal. It is expected to evolve as BGPsec is formalized and initially deployed. Working Group Summary This draft went thorugh several revisions, with good discussion from stake-holders in the communities affected. Document Quality The document describes what the WG believes is the best way to implement\/deploy BGPsec. As it describes, it is expected to evolve as more experience is gained. Personnel Shepherd: Chris Morrow (morrowc@ops-netman.net) AD: Alvaro Retana (aretana@cisco.com) RFC Editor Note This document should be published alongside draft-ietf-sidr-bgpsec-protocol and draft-ietf-sidr-as-migration so that they have consecutive RFC numbers in the following order: draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-ops"}
{"_id":"doc-en-sidr-DEjUmsoAsgfVJiEdCnUr3xVmY6o","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nHiya, Adding the text you propose for section 7 seems good. You also asked about adding this: In particular, by following these methods, security concerns related to possible correlation of RPKI data access and BGP update events are also mitigated. Maybe better to say something like: \"With these caching mechanisms it is believed that an attacker wouldn't be able to meaningfully correlate RPKI data flows with BGPsec RP actions, thus avoiding attacks that attempt to determine the set of ASes interacting with an RP via the interactions between the RP and RPKI servers.\" Also, I had a look back at the overall thread and I think this is where we're at: discuss point #1: the draft needs a bit of text saying how to handle an SKI that is not 20 bytes long. I don't think we have a text proposal but it should be easy enough, e.g. you could say \"If the SKI in a certificate is not 20 bytes long then if it is longer, use the leftmost 20 bytes. If the SKI value is shorter than 20 bytes, then pad left with zero bytes.\" Note that I don't care which way you prefer to fix this, any way is fine. discuss point #2: this one's sorted. (I updated my ballot to indicate this one's cleared.) discuss point #3: with your suggested text and something like the above we should be good with this one too If you'd like to submit a revised ID with those changes then I should be fine to clear. Cheers, S."}
{"_id":"doc-en-sidr-UBd_miGdg9W0gczM7y9MdnJbN5o","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen, Please see response below. From: sidr <sidr-bounces@ietf.org> on behalf of Stephen Farrell <stephen.farrell@cs.tcd.ie> Sent: Wednesday, January 4, 2017 4:45 PM To: Montgomery, Douglas (Fed); Russ Housley Hiya, The RPKI validating caches *are* the relaying parties for BGPsec, they are (a) designed to be run on a separate box than the router itself and (b) their behavior WRT exchanges with RPKI repositories is independent of BGP message processing by any of the routers that they serve. Sure. That makes sense. But where's it stated for BGPsec that the RP ought act that way? I propose adding the following paragraph in Section 7. Please let me know if this would help resolve your concern\/comment. The deployment structure, technologies and best practices concerning global RPKI data to reach routers (via local RPKI caches) are described in [RFC6810] [RFC7115] [I-D.ietf-sidr-bgpsec-ops] [I-D.-ietf-sidr-delta-protocol] [rsync]. For example, serial-number based incremental update mechanisms are used for efficient transfer of just the data records that have changed since last update [RFC6810]. Update notification file is used by relying parties (RPs) to discover whether any changes exist between the state of the global RPKI repository and the RP's cache [I-D.-ietf-sidr-delta-protocol]. The notification describes the location of the files containing the snapshot and incremental deltas which can be used by the RP to synchronize with the repository. Making use of these technologies and best practices results in enabling robustness, efficiency, and better security for the BGPsec routers and RPKI caches in terms of the flow of RPKI data from repositories to RPKI caches to routers (in distilled form). If you feel that the following sentence adds additional value, it can be added at the end: In particular, by following these methods, security concerns related to possible correlation of RPKI data access and BGP update events are also mitigated. You may edit\/suggesting any wording improvements. I look forward to your further guidance on this. Thank you. Sriram"}
{"_id":"doc-en-sidr-2bTvQmuQUYTzTGnmceYNKBYWBSE","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen, Please see responses inline below. [Sriram] Signer's ASN is indeed included in the signed data. In Figure 8, \"Secure_Path Segment : N\" corresponds to the signing AS (current AS) and that is where the signer's ASN is included along with its pCount and Flags. Hmm. That's the target ASN of the previous signer though. Semantically the \"Secure_Path Segment: N\" shown in the data to be hashed in Figure 8, contains the current signer's ASN, although logically it is equal to the target ASN of the previous signer. I thought there were cases where they could differ? But if not, then you probably need to state that as a rule for checking signatures, is that there already? (Happy to check later, but don't have time right now.) They had differed in one situation but that was before we put in a fix for the confederation boundary, and that fix is in the second paragraph of Section 4.3 of version-21. So now we are good. Yes, now a signer's ASN always equals the target ASN used in the hashed data by the previous signer. So in the signature validation, the verifier always plugs in its own ASN as the target ASN for validation of the most recently added signature. Without that the validation of that signature will fail. That rule is built in into the validation process (page 26): \"For the first segment to be processed (the most recently added segment (i.e. N = K) given that there are K hops in the Secure_Path), the 'Target AS Number' is AS(K+1), the AS number of the BGPsec speaker validating the update message.\" - 5.2, I think you need to say something to the effect that every Secure_Path MUST have a signature with an algorithm that is supported. As I read the text, the algorithm as stated here could be read to not require that. E.g. the para before the bullets on p25 could be read to mean \"drop all stuff involving unsupported algs and then continue to process the rest of the stuff.\" [Sriram] Seems like a bit of a pathological case. Could happen only if the sender behavior was incorrect. Yes, but 5.2 is verifier behaviour and ought not assume a correct signer, so I do think the alg presented here needs to cover such things. Please see response below. Sender is not required to know which algorithms a peer supports but sender's expected behavior is this: MUST include a Signature_Block for the \"current\" algorithm (which every BGPsec speaker MUST support through the transition period), Where does it say that the current\/next thing applies to the entire world of BGPsec? I didn't read it that way as it happens, but rather that the current\/next could involve different algorithms at different nodes at the same time. So e.g. I read it to be allowed that a migration from rsa\/sha256 then to ecdsa then to eddsa could occur with some non-updated nodes still signing with rsa\/sha256 whilst some shiny new nodes are doing ecdsa and eddsa and others are in between. I do agree that a global current\/next pair of algs is nicer, if that is what's wanted. But I don't recall the text saying that. (Again happy to check later, but no time right now;-) The text does describe it in terms of \"a global current\/new pair of algs\" in Section 6.1 (p. 28, v-21): \"To this end, a mandatory algorithm suites document exists which specifies a mandatory-to-use 'current' algorithm suite for use by all BGPsec speakers [I-D.ietf-sidr-bgpsec-algs]. It is anticipated that, in the future, the mandatory algorithm suites document will be updated to specify a transition from the 'current' algorithm suite to a 'new' algorithm suite. During the period of transition (likely a small number of years), all BGPsec update messages SHOULD simultaneously use both the 'current' algorithm suite and the 'new' algorithm suite. (Note that Section 3 and Section 4 specify how the BGPsec_Path attribute can contain signatures, in parallel, for two algorithm suites.) Once the transition is complete, use of the old 'current' algorithm will be deprecated, use of the 'new' algorithm will be mandatory, ….\" Thank you. Sriram"}
{"_id":"doc-en-sidr-llW7wJjHHrNrRGokBOSIdKi8OGQ","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nre keyur's point 4. the issue is that 4271 has semantics of AS_PATH, bgpsec replaces it with BGPSEC_PATH, but bgpsec does not explicitly repeat things such as loop detection using BGPSEC_PATH. instead of this becoming another text explosion, a simple statement that, in bgpsec, the following AS_PATH semantics of 4271: <list>, hold analogously for BGPSEC_PATH. randy"}
{"_id":"doc-en-sidr-mYP6laalsmiosbPm4FCFsydpOMA","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nOn 1\/6\/17, 12:40 AM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: [Cut the distribution list a little.] Sriram: Hi! Happy New Year! I have some comments on this, please see below. Thanks! Alvaro. … | | 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually | | exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT | | contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp | | capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We | | could add some clarifying that helps to indicate that such routes should be considered | | valid in stale mode (till they get refreshed)? | | [Sriram] As you have clarified for me on the phone, what you are saying here is that the | two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not | exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers | in GR mode. RFC4271 considers update message received without a well-known AS_PATH | attribute as an error, and unfortunately in this case the cached BGPsec updates do not have | AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" | and instead simply treat each cached update as NOT-IN-ERROR even though it is missing | AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will | have AS_PATH (and not considered in error) when they get refreshed (over the new simple | BGP session). Per your suggestion, I will include new text in Section 7 to describe this | required behavior for the GR mode. I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. … | | 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received | | without a well-known AS_PATH attribute as an error. We need some text to clarify the | | (error handling if any) behavior when an update message is received without a bgpsec and | | an aspath attribute. The current draft text seems unclear about generation of bgpsec | | attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec | | attribute? | | [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the | following : | | \"When a BGP speaker originates a route then: | b) the originating speaker includes an empty AS_PATH attribute in | all UPDATE messages sent to internal peers. (An empty AS_PATH | attribute is one whose length field contains the value zero).\" | | | [Sriram] So what needs to be said in the BGPsec document is the following: The | BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to | BGPsec capable internal peers. However, when a route is originated inside an AS and | propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the | update (see [RFC 4271], page 26). The Route Selection Section (9.1.2) in RFC4271 is not explicit about performing loop detection only on eBGP sessions – the criteria is generic to any route, so there is a possibility that a BGPsec-capable router may want to perform loop detection on an iBGP-received Update. Given this text from Section 5 in the BGPsec spec: Whenever the use of AS path information is called for (e.g., loop detection, or use of AS path length in best path selection) the externally visible behavior of the implementation shall be the same as if the implementation had run the algorithm in Section 4.4 and used the resulting AS_PATH attribute as it would for a non-BGPsec update message. …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Thanks! Alvaro. [Cut the distribution list a little.] Sriram: Hi! Happy New Year! I have some comments on this, please see below. Thanks! Alvaro. … | | 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually | | exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT | | contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp | | capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We | | could add some clarifying that helps to indicate that such routes should be considered | | valid in stale mode (till they get refreshed)? | | [Sriram] As you have clarified for me on the phone, what you are saying here is that the | two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not | exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers | in GR mode. RFC4271 considers update message received without a well-known AS_PATH | attribute as an error, and unfortunately in this case the cached BGPsec updates do not have | AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" | and instead simply treat each cached update as NOT-IN-ERROR even though it is missing | AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will | have AS_PATH (and not considered in error) when they get refreshed (over the new simple | BGP session). Per your suggestion, I will include new text in Section 7 to describe this | required behavior for the GR mode. I don’t have an objection for this behavior, but I think we should make the WG (and idr!) aware of the change and get their comments (if any) before I approve the publication. … | | 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received | | without a well-known AS_PATH attribute as an error. We need some text to clarify the | | (error handling if any) behavior when an update message is received without a bgpsec and | | an aspath attribute. The current draft text seems unclear about generation of bgpsec | | attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec | | attribute? | | [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the | following : | | \"When a BGP speaker originates a route then: | b) the originating speaker includes an empty AS_PATH attribute in | all UPDATE messages sent to internal peers. (An empty AS_PATH | attribute is one whose length field contains the value zero).\" | | | [Sriram] So what needs to be said in the BGPsec document is the following: The | BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to | BGPsec capable internal peers. However, when a route is originated inside an AS and | propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the | update (see [RFC 4271], page 26). The Route Selection Section (9.1.2) in RFC4271 is not explicit about performing loop detection only on eBGP sessions – the criteria is generic to any route, so there is a possibility that a BGPsec-capable router may want to perform loop detection on an iBGP-received Update. Given this text from Section 5 in the BGPsec spec: Whenever the use of AS path information is called for (e.g., loop detection, or use of AS path length in best path selection) the externally visible behavior of the implementation shall be the same as if the implementation had run the algorithm in Section 4.4 and used the resulting AS_PATH attribute as it would for a non-BGPsec update message. …how should an iBGP speaker perform loop detection if there’s no BGPsec_Path attribute? In other words, there is no defined mechanism to run the algorithm in 4.4 without it. I’m not suggesting that you include an empty attribute, but that you indicate in 4.4 that no BGPsec_Path attribute is equivalent to an empty AS_PATH. Thanks! Alvaro."}
{"_id":"doc-en-sidr-SGYMuWghkQgSao1JG_QMAk3heSk","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nMy previous post of this message seems to have line wrap issue. Resending ... hopefully this avoids that issue. - Sriram ------------------- Keyur, Thank you for taking the time to read and offer comments. I find the comments very insightful and helpful. My comments are marked with [Sriram] below. From: Keyur Patel keyur@arrcus.com Sent: Wednesday, January 4, 2017 5:53 PM The document is well written, easy to read and follow. Some minor comments are listed below: 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We could add some clarifying that helps to indicate that such routes should be considered valid in stale mode (till they get refreshed)? [Sriram] As you have clarified for me on the phone, what you are saying here is that the two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers in GR mode. RFC4271 considers update message received without a well-known AS_PATH attribute as an error, and unfortunately in this case the cached BGPsec updates do not have AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" and instead simply treat each cached update as NOT-IN-ERROR even though it is missing AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will have AS_PATH (and not considered in error) when they get refreshed (over the new simple BGP session). Per your suggestion, I will include new text in Section 7 to describe this required behavior for the GR mode. 2) 4.1 4th paragraph: \"Note also that new signatures are only added to a BGPsec update message when a BGPsec speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPsec speaker's own AS number). Therefore, a BGPsec speaker who only sends BGPsec update messages to peers within its own AS does not need to possess any private signature keys.\" This text doesn't seem to apply to confed peers? If so, it would be nice to clarify that this text doesn't apply to any confed peers. [Sriram] You have clarified in our phone conversation that you consider the inter-AS-member sessions as \"iBGP\" since they are all within a confederation AS domain. The BGPsec document considers the inter-AS-member sessions as \"eBGP\" (not \"iBGP\") and intra-Member-AS sessions as \"iBGP\". You also clarified that you may call inter-AS-member sessions as \"confederation-eBGP\" sessions. Obviously, private key is required to sign over such \"confederation-eBGP\/BGPsec\" sessions. I understand your point. I will put in new text (notes) to clarify this in the document. 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received without a well-known AS_PATH attribute as an error. We need some text to clarify the (error handling if any) behavior when an update message is received without a bgpsec and an aspath attribute. The current draft text seems unclear about generation of bgpsec attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec attribute? [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the following : \"When a BGP speaker originates a route then: b) the originating speaker includes an empty AS_PATH attribute in all UPDATE messages sent to internal peers. (An empty AS_PATH attribute is one whose length field contains the value zero).\" [Sriram] So what needs to be said in the BGPsec document is the following: The BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to BGPsec capable internal peers. However, when a route is originated inside an AS and propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the update (see [RFC 4271], page 26). 4) With an AS_PATH attribute in 4271 there was loop detection in place. With BGPSec I don’t see that being called explicitly other than a passing remark in section 5. Section 5.2 should have a check that allows a BGPsec speaker to bail out of a validation procedure when a aspath loop is detected. [Sriram] I agree. I will include loop detection in the list of error checks in Section 5.2. Sriram My previous post of this message seems to have line wrap issue. Resending ... hopefully this avoids that issue. - Sriram ------------------- Keyur, Thank you for taking the time to read and offer comments. I find the comments very insightful and helpful. My comments are marked with [Sriram] below. From: Keyur Patel keyur@arrcus.com Sent: Wednesday, January 4, 2017 5:53 PM The document is well written, easy to read and follow. Some minor comments are listed below: 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We could add some clarifying that helps to indicate that such routes should be considered valid in stale mode (till they get refreshed)? [Sriram] As you have clarified for me on the phone, what you are saying here is that the two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers in GR mode. RFC4271 considers update message received without a well-known AS_PATH attribute as an error, and unfortunately in this case the cached BGPsec updates do not have AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" and instead simply treat each cached update as NOT-IN-ERROR even though it is missing AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will have AS_PATH (and not considered in error) when they get refreshed (over the new simple BGP session). Per your suggestion, I will include new text in Section 7 to describe this required behavior for the GR mode. 2) 4.1 4th paragraph: \"Note also that new signatures are only added to a BGPsec update message when a BGPsec speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPsec speaker's own AS number). Therefore, a BGPsec speaker who only sends BGPsec update messages to peers within its own AS does not need to possess any private signature keys.\" This text doesn't seem to apply to confed peers? If so, it would be nice to clarify that this text doesn't apply to any confed peers. [Sriram] You have clarified in our phone conversation that you consider the inter-AS-member sessions as \"iBGP\" since they are all within a confederation AS domain. The BGPsec document considers the inter-AS-member sessions as \"eBGP\" (not \"iBGP\") and intra-Member-AS sessions as \"iBGP\". You also clarified that you may call inter-AS-member sessions as \"confederation-eBGP\" sessions. Obviously, private key is required to sign over such \"confederation-eBGP\/BGPsec\" sessions. I understand your point. I will put in new text (notes) to clarify this in the document. 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received without a well-known AS_PATH attribute as an error. We need some text to clarify the (error handling if any) behavior when an update message is received without a bgpsec and an aspath attribute. The current draft text seems unclear about generation of bgpsec attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec attribute? [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the following : \"When a BGP speaker originates a route then: b) the originating speaker includes an empty AS_PATH attribute in all UPDATE messages sent to internal peers. (An empty AS_PATH attribute is one whose length field contains the value zero).\" [Sriram] So what needs to be said in the BGPsec document is the following: The BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to BGPsec capable internal peers. However, when a route is originated inside an AS and propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the update (see [RFC 4271], page 26). 4) With an AS_PATH attribute in 4271 there was loop detection in place. With BGPSec I don’t see that being called explicitly other than a passing remark in section 5. Section 5.2 should have a check that allows a BGPsec speaker to bail out of a validation procedure when a aspath loop is detected. [Sriram] I agree. I will include loop detection in the list of error checks in Section 5.2. Sriram"}
{"_id":"doc-en-sidr-e8Pg5rJSdOTURB983ma9NP0vvOA","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\nKeyur, Thank you for taking the time to read and offer comments. I find the comments very insightful and helpful. My comments are marked with [Sriram] below. From: Keyur Patel keyur@arrcus.com Sent: Wednesday, January 4, 2017 5:53 PM The document is well written, easy to read and follow. Some minor comments are listed below: 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We could add some clarifying that helps to indicate that such routes should be considered valid in stale mode (till they get refreshed)? [Sriram] As you have clarified for me on the phone, what you are saying here is that the two BGPsec peers lost the BGPsec session and now restarting in GR mode, but they have not exchanged BGPsec capability this time. Hence, they are now simple BGP (non-BGPsec) peers in GR mode. RFC4271 considers update message received without a well-known AS_PATH attribute as an error, and unfortunately in this case the cached BGPsec updates do not have AS_PATH (albeit they have BGPsec_Path). So you are saying \"the router should not panic\" and instead simply treat each cached update as NOT-IN-ERROR even though it is missing AS_PATH attribute. This way the GR can work properly. Of course, shortly the updates will have AS_PATH (and not considered in error) when they get refreshed (over the new simple BGP session). Per your suggestion, I will include new text in Section 7 to describe this required behavior for the GR mode. 2) 4.1 4th paragraph: \"Note also that new signatures are only added to a BGPsec update message when a BGPsec speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPsec speaker's own AS number). Therefore, a BGPsec speaker who only sends BGPsec update messages to peers within its own AS does not need to possess any private signature keys.\" This text doesn't seem to apply to confed peers? If so, it would be nice to clarify that this text doesn't apply to any confed peers. [Sriram] You have clarified in our phone conversation that you consider the inter-AS-member sessions as \"iBGP\" since they are all within a confederation AS domain. The BGPsec document considers the inter-AS-member sessions as \"eBGP\" (not \"iBGP\") and intra-Member-AS sessions as \"iBGP\". You also clarified that you may call inter-AS-member sessions as \"confederation-eBGP\" sessions. Obviously, private key is required to sign over such \"confederation-eBGP\/BGPsec\" sessions. I understand your point. I will put in new text (notes) to clarify this in the document. 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received without a well-known AS_PATH attribute as an error. We need some text to clarify the (error handling if any) behavior when an update message is received without a bgpsec and an aspath attribute. The current draft text seems unclear about generation of bgpsec attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec attribute? [Sriram] As you have clarified for me over the phone, RFC 4271 (page 26) says the following : \"When a BGP speaker originates a route then: b) the originating speaker includes an empty AS_PATH attribute in all UPDATE messages sent to internal peers. (An empty AS_PATH attribute is one whose length field contains the value zero).\" [Sriram] So what needs to be said in the BGPsec document is the following: The BGPsec_Path attribute is not attached in updates originated inside an AS and propagated to BGPsec capable internal peers. However, when a route is originated inside an AS and propagated to non-BGPsec internal peers, an empty AS_PATH attribute is included in the update (see [RFC 4271], page 26). 4) With an AS_PATH attribute in 4271 there was loop detection in place. With BGPSec I don’t see that being called explicitly other than a passing remark in section 5. Section 5.2 should have a check that allows a BGPsec speaker to bail out of a validation procedure when a aspath loop is detected. [Sriram] I agree. I will include loop detection in the list of error checks in Section 5.2. Sriram"}
{"_id":"doc-en-sidr-CkZRFd1KV3Cos5fAkb2PZva1FR8","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\ndid i miss the response to this? i think some of the points are important. randy"}
{"_id":"doc-en-sidr-DCxXSzMIvbUaN_rP5WWLI7Spu_A","title":"","text":"Re: [sidr] Benoit Claise's No Objection on\n draft-ietf-sidr-bgpsec-ops-16: (with COMMENT)\nProposal: one extra section on migration\/deployability There is text in draft-ietf-sidr-bgpsec-protocol-21 How will migration from BGP to BGPsec look like? What are the benefits for the first adopters? Initially small groups of contiguous ASes would be doing BGPsec. There would be possibly one or more such groups in different geographic regions of the global Internet. Only the routes originated within each group and propagated within its borders would get the benefits of cryptographic AS path protection. As BGPsec adoption grows, each group grows in size and eventually they join together to form even larger BGPsec capable groups of contiguous ASes. The benefit for early adopters starts with AS path security within the contiguous-AS regions spanned by their respective groups. Over time they would see those contiguous-AS regions grow much larger. i see no merit in reproducing text from another document. i could refer to it, but i prefer to add 7. Routing Policy As BGPsec signed paths can not traverse non-BGPsec topology, partial BGPsec deployment forms islands of assured paths. As islands grow to touch each other, they become larger islands. randy"}
{"_id":"doc-en-sidr-BHuk3uIz6wjyKtUPZutbc04b1G0","title":"","text":"Re: [sidr]\n =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nMirja Kühlewind has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: No Objection [...] 1) Why do you need to send two different negotiation capabilities for each direction instead of just using two flags in the same capability? And similar why don't you just announce multiple address families in the same capability (using variable length)? This is a nit, but I was wondering about this myself."}
{"_id":"doc-en-sidr-CeFSXV5i66UIDa1uU_1qg9jmZ4g","title":"","text":"[sidr] Benoit Claise's No Objection on\n draft-ietf-sidr-bgpsec-ops-16: (with COMMENT)\nBenoit Claise has entered the following ballot position for draft-ietf-sidr-bgpsec-ops-16: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- Happy to see an operational considerations document at the same time at the protocol specifications, even if we know that \"It is expected to evolve as BGPsec is formalized and initially deployed.\" Thanks Randy Proposal: one extra section on migration\/deployability There is text in draft-ietf-sidr-bgpsec-protocol-21 How will migration from BGP to BGPsec look like? What are the benefits for the first adopters? Initially small groups of contiguous ASes would be doing BGPsec. There would be possibly one or more such groups in different geographic regions of the global Internet. Only the routes originated within each group and propagated within its borders would get the benefits of cryptographic AS path protection. As BGPsec adoption grows, each group grows in size and eventually they join together to form even larger BGPsec capable groups of contiguous ASes. The benefit for early adopters starts with AS path security within the contiguous-AS regions spanned by their respective groups. Over time they would see those contiguous-AS regions grow much larger."}
{"_id":"doc-en-sidr-tAYHVAVmk9hOzpOWZexpdPR8gsA","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nHiya, Stephen, Thank you for the detailed review and comments. Please see my responses marked with [Sriram] inline below. [Sriram] Your DISCUSS points (1) and (3) were already discussed \/being discussed in separate threads. Yep, thanks. I need to check back to see how close we are to resolving those, but I had thought the ball wasn't in my court at the moment:-) I'm sure we'll sort 'em soon though. (2) Figure 8: It seems to me to be an error to omit the signer's ASN from the signed data and only have that included in the signer's certificate. Why is that intimate level of binding to the RPKI desirable? There may well be reasons but I'm not seeing 'em, and I am recalling that it took a chunk of effort to make CMS less dependent on X.509 for similar reasons (meaning identifying signers exclusively via cert issuer and serial in that case). I would expect that there could be demand to have some level of independence between BGPsec and RPKI for at least internal uses such as those noted in the spec already. [Sriram] Signer's ASN is indeed included in the signed data. In Figure 8, \"Secure_Path Segment : N\" corresponds to the signing AS (current AS) and that is where the signer's ASN is included along with its pCount and Flags. Hmm. That's the target ASN of the previous signer though. I thought there were cases where they could differ? But if not, then you probably need to state that as a rule for checking signatures, is that there already? (Happy to check later, but don't have time right now.) One other thing below... ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- - Figures 2 and 5 present the fields in different orders. That seems like a bad idea. [Sriram] Good catch. Already fixed in my editor copy of version-22. - 3.2: The reference to the pki profile doc is not precise enough, the string \"key identifier\" does not occur in that draft - it's in RFC6487, 4.8.2. [Sriram] Again, a good catch. Already fixed in my editor copy of version-22. - 4.1, last para: is the distinction between an \"internal peer\" and \"iBGP peer\" sufficiently clear to routing folk? For me they sound similar but I assume it's ok. [Sriram] I think it is well understood. But when I push version-22 out, I’ll consider if I should simply just use \"iBGP peer\" consistently and avoid using \"internal peer\". - 5.2, I think you need to say something to the effect that every Secure_Path MUST have a signature with an algorithm that is supported. As I read the text, the algorithm as stated here could be read to not require that. E.g. the para before the bullets on p25 could be read to mean \"drop all stuff involving unsupported algs and then continue to process the rest of the stuff.\" [Sriram] Seems like a bit of a pathological case. Could happen only if the sender behavior was incorrect. Yes, but 5.2 is verifier behaviour and out not assume a correct signer, so I do thing the alg presented here needs to cover such things. Sender is not required to know which algorithms a peer supports but sender's expected behavior is this: MUST include a Signature_Block for the \"current\" algorithm (which every BGPsec speaker MUST support through the transition period), Where does it say that the current\/next thing applies to the entire world of BGPsec? I didn't read it that way as it happens, but rather that the current\/next could involve different algorithms at different nodes at the same time. So e.g. I read it to be allowed that a migration from rsa\/sha256 then to ecdsa then to eddsa could occur with some non-updated nodes still signing with rsa\/sha256 whilst some shiny new nodes are doing ecdsa and eddsa and others are in between. I do agree that a global current\/next pair of algs is nicer, if that is what's wanted. But I don't recall the text saying that. (Again happy to check later, but no time right now;-) Cheers, S. and if the sender supports the \"next\" algorithm, then it MUST include a Signature_Block for the \"next\" algorithm also. So the peer BGPsec receiver (who MUST support at least the \"current\" algorithm) is not expected to be starved of a Signature_Block it can work with. - section 7: WRT non-deterministic signature algorithms, I think it'd be useful to note here that all such algorithms require good random number generation on the signer's system and that failing in that respect can expose the signer's private key. IMO deterministic signature schemes are better for this reason but the need for a good RNG is I think a real operational issue worthy of note. [Sriram] I will include wording to cover this in Section 7 in version-22. Sriram"}
{"_id":"doc-en-sidr-Ror0VPtHttQfrWSXubx8SaHUU_Q","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen, Thank you for the detailed review and comments. Please see my responses marked with [Sriram] inline below. [Sriram] Your DISCUSS points (1) and (3) were already discussed \/being discussed in separate threads. (2) Figure 8: It seems to me to be an error to omit the signer's ASN from the signed data and only have that included in the signer's certificate. Why is that intimate level of binding to the RPKI desirable? There may well be reasons but I'm not seeing 'em, and I am recalling that it took a chunk of effort to make CMS less dependent on X.509 for similar reasons (meaning identifying signers exclusively via cert issuer and serial in that case). I would expect that there could be demand to have some level of independence between BGPsec and RPKI for at least internal uses such as those noted in the spec already. [Sriram] Signer's ASN is indeed included in the signed data. In Figure 8, \"Secure_Path Segment : N\" corresponds to the signing AS (current AS) and that is where the signer's ASN is included along with its pCount and Flags. ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- - Figures 2 and 5 present the fields in different orders. That seems like a bad idea. [Sriram] Good catch. Already fixed in my editor copy of version-22. - 3.2: The reference to the pki profile doc is not precise enough, the string \"key identifier\" does not occur in that draft - it's in RFC6487, 4.8.2. [Sriram] Again, a good catch. Already fixed in my editor copy of version-22. - 4.1, last para: is the distinction between an \"internal peer\" and \"iBGP peer\" sufficiently clear to routing folk? For me they sound similar but I assume it's ok. [Sriram] I think it is well understood. But when I push version-22 out, I’ll consider if I should simply just use \"iBGP peer\" consistently and avoid using \"internal peer\". - 5.2, I think you need to say something to the effect that every Secure_Path MUST have a signature with an algorithm that is supported. As I read the text, the algorithm as stated here could be read to not require that. E.g. the para before the bullets on p25 could be read to mean \"drop all stuff involving unsupported algs and then continue to process the rest of the stuff.\" [Sriram] Seems like a bit of a pathological case. Could happen only if the sender behavior was incorrect. Sender is not required to know which algorithms a peer supports but sender's expected behavior is this: MUST include a Signature_Block for the \"current\" algorithm (which every BGPsec speaker MUST support through the transition period), and if the sender supports the \"next\" algorithm, then it MUST include a Signature_Block for the \"next\" algorithm also. So the peer BGPsec receiver (who MUST support at least the \"current\" algorithm) is not expected to be starved of a Signature_Block it can work with. - section 7: WRT non-deterministic signature algorithms, I think it'd be useful to note here that all such algorithms require good random number generation on the signer's system and that failing in that respect can expose the signer's private key. IMO deterministic signature schemes are better for this reason but the need for a good RNG is I think a real operational issue worthy of note. [Sriram] I will include wording to cover this in Section 7 in version-22. Sriram"}
{"_id":"doc-en-sidr-mzfi7fiN0-7B22PIsWb5YX0ABww","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nOn 5 Jan 2017, at 03:19, Suresh Krishnan <suresh.krishnan@ericsson.com> wrote: On 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU Thanks for the pointer Sean. Very interesting. Indeed! I wish a few words about design could be added to the draft."}
{"_id":"doc-en-sidr-rUmPkJ9xxh8x0MXG2_UNQSuEpeI","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nOn 01\/04\/2017 09:38 AM, Sean Turner wrote: +1 to the comment from Suresh about order. I though that something like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU Thanks for the pointer Sean. Very interesting. Regards Suresh"}
{"_id":"doc-en-sidr-fEUMLtA3OEHITGI0GrJ9gsJxtIg","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-pki-profiles-19: (with COMMENT)\nOn 4 Jan 2017, at 17:21, Sean Turner wrote: On Jan 4, 2017, at 18:19, Ben Campbell <ben@nostrum.com> wrote: -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. Where’s that in draft-ietf-sidr-bgpsec-protocol? Regardless, I’m not sure that restoration will work in this draft because there are repeated MUST requirements from other RFC and my AD told me to not capitalize them :) Oops, sorry, I meant to say draft-ietf-sidr-bgpsec-ops. Maybe I misunderstand what you mean; are the non-capitalized requirements from other drafts intended as normative for _this_ draft? If not, then the treatment of non-capitalized 2119 words as normal English seems to help. It’s more like: \"As defined in RFC mubleqsuat, client must do this.” The thinking goes (and I agree) that we should repeat requirements if we’re just quoting them. Without getting into specific reasoning either way: My comment was not meant to be binding, just something to consider. Ben. t"}
{"_id":"doc-en-sidr-MyEAT_aXYs_awGsaGAX7ciiCuJU","title":"","text":"[sidr] Ben Campbell's Yes on draft-ietf-sidr-bgpsec-protocol-21:\n (with COMMENT)\nBen Campbell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Yes When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- I share some of the concerns about deployability, but have nothing new to add to that conversation. Otherwise I just have a few minor comments: -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. [Update: Oops, sorry, I meant to say draft-ietf-sidr-bgpsec-ops excludes non-capitalized versions of 2119 words. (That is to say, it treats them as their normal English equivalents.)] - 5.2, step 2: I'm almost sure I've missed something here, but if I understand correctly, previous sections talked about how a peer can propagate a BGPsec_Path attribute without modification. Will that cause a problem in this step if the immediate peer propagated an unmodified BGPsec_Path that came from a different AS? - 8.4, last paragraph: The text describes a replay attack, and delegates the mitigation solution to draft-ietf-sidr-bgpsec-rollover. This is an informational reference; it seems like it should be normative."}
{"_id":"doc-en-sidr-sOrQ51usKRRJSOt_snCwnoFTwRM","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-pki-profiles-19: (with COMMENT)\nOn Jan 4, 2017, at 18:19, Ben Campbell <ben@nostrum.com> wrote: -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. Where’s that in draft-ietf-sidr-bgpsec-protocol? Regardless, I’m not sure that restoration will work in this draft because there are repeated MUST requirements from other RFC and my AD told me to not capitalize them :) Oops, sorry, I meant to say draft-ietf-sidr-bgpsec-ops. Maybe I misunderstand what you mean; are the non-capitalized requirements from other drafts intended as normative for _this_ draft? If not, then the treatment of non-capitalized 2119 words as normal English seems to help. It’s more like: \"As defined in RFC mubleqsuat, client must do this.” The thinking goes (and I agree) that we should repeat requirements if we’re just quoting them. spt"}
{"_id":"doc-en-sidr-3kOZuwusbF_CoAIz7X7vSpb8iCQ","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-pki-profiles-19: (with COMMENT)\n-2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. Where’s that in draft-ietf-sidr-bgpsec-protocol? Regardless, I’m not sure that restoration will work in this draft because there are repeated MUST requirements from other RFC and my AD told me to not capitalize them :) Oops, sorry, I meant to say draft-ietf-sidr-bgpsec-ops. Maybe I misunderstand what you mean; are the non-capitalized requirements from other drafts intended as normative for _this_ draft? If not, then the treatment of non-capitalized 2119 words as normal English seems to help. Thanks! Ben."}
{"_id":"doc-en-sidr-Wo4O55GCJe8jIA9Jopb4R2tSfUo","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol\n[adding routing-ads] From: Keyur Patel <keyur@arrcus.com> Date: Wednesday, January 4, 2017 at 2:17 PM To: Jonathan Hardwick <jonathan.hardwick@metaswitch.com>, \"Alvaro Retana (aretana)\" <aretana@cisco.com>, Zhangxian Xian <zhang.xian@huawei.com>, Jon Hudson <jon.hudson@gmail.com> Cc: rtg-dir <rtg-dir-bounces@ietf.org>, \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org>, sidr <sidr-bounces@ietf.org>, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov>, \"mlepinski@ncf.edu\" <mlepinski@ncf.edu> Subject: draft-ietf-sidr-bgpsec-protocol Hello, Apologies for the delayed response. I have been selected as the Routing Directorate QA reviewer for draft-ietf-sidr-bgpsec-protocol. The Routing Directorate QA reviews are intended to be a support to improve the quality of RTG Area documents as they pass through the IETF process. This is the QA review at the time of the WG document adoption poll. Summary: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. The document is well written, easy to read and follow. Some minor comments are listed below: Comments for the authors: 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We could add some clarifying that helps to indicate that such routes should be considered valid in stale mode (till they get refreshed)? 2) 4.1 4th paragraph: “Note also that new signatures are only added to a BGPsec update message when a BGPsec speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPsec speaker's own AS number). Therefore, a BGPsec speaker who only sends BGPsec update messages to peers within its own AS does not need to possess any private signature keys.” This text doesn’t seem to apply to confed peers? If so, it would be nice to clarify that this text doesn’t apply to any confed peers. 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received without a wellknown AS_PATH attribute as an error. We need some text to clarify the (error handling if any) behavior when an update message is received without a bgpsec and an aspath attribute. The current draft text seems unclear about generation of bgpsec attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec attribute? 4) With an AS_PATH attribute in 4271 there was loop detection in place. With BGPSec I don’t see that being called explicitly other than a passing remark in section 5. Section 5.2 should have a check that allows a BGPsec speaker to bail out of a validation procedure when a aspath loop is detected. Best Regards, Keyur [adding routing-ads] From: Keyur Patel <keyur@arrcus.com> Date: Wednesday, January 4, 2017 at 2:17 PM To: Jonathan Hardwick <jonathan.hardwick@metaswitch.com>, \"Alvaro Retana (aretana)\" <aretana@cisco.com>, Zhangxian Xian <zhang.xian@huawei.com>, Jon Hudson <jon.hudson@gmail.com> Cc: rtg-dir <rtg-dir-bounces@ietf.org>, \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org>, sidr <sidr-bounces@ietf.org>, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov>, \"mlepinski@ncf.edu\" <mlepinski@ncf.edu> Subject: draft-ietf-sidr-bgpsec-protocol Hello, Apologies for the delayed response. I have been selected as the Routing Directorate QA reviewer for draft-ietf-sidr-bgpsec-protocol. The Routing Directorate QA reviews are intended to be a support to improve the quality of RTG Area documents as they pass through the IETF process. This is the QA review at the time of the WG document adoption poll. Summary: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. The document is well written, easy to read and follow. Some minor comments are listed below: Comments for the authors: 1) Section 4.1 “The BGPsec Path attribute and the AS_PATH attribute are mutually exclusive. That is, any update message containing the BGPsec Path attribute MUST NOT contain the AS_PATH attribute”. For any restarting speakers in a GR mode, where the bgp capability is not exchanged, the existing stale routes won’t have an AS_PATH attribute. We could add some clarifying that helps to indicate that such routes should be considered valid in stale mode (till they get refreshed)? 2) 4.1 4th paragraph: “Note also that new signatures are only added to a BGPsec update message when a BGPsec speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPsec speaker's own AS number). Therefore, a BGPsec speaker who only sends BGPsec update messages to peers within its own AS does not need to possess any private signature keys.” This text doesn’t seem to apply to confed peers? If so, it would be nice to clarify that this text doesn’t apply to any confed peers. 3) Section 5 and Section 5.2, 1st paragraph: RFC4271 considers update message received without a wellknown AS_PATH attribute as an error. We need some text to clarify the (error handling if any) behavior when an update message is received without a bgpsec and an aspath attribute. The current draft text seems unclear about generation of bgpsec attribute as well (in a ibgp scenario). Is it a requirement to generate an empty bgpsec attribute? 4) With an AS_PATH attribute in 4271 there was loop detection in place. With BGPSec I don’t see that being called explicitly other than a passing remark in section 5. Section 5.2 should have a check that allows a BGPsec speaker to bail out of a validation procedure when a aspath loop is detected. Best Regards, Keyur"}
{"_id":"doc-en-sidr-ASMIUbtcfmLn8Xx3Z9Qu6Fzo6fM","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-pki-profiles-19: (with COMMENT)\nBen Campbell has entered the following ballot position for draft-ietf-sidr-bgpsec-pki-profiles-19: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-pki-profiles\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- A few strictly editorial comments: - IDNits complains about some undefined references. == Missing Reference: 'ID.sidr-rfc6485bis' is mentioned on line 334, but not defined Yep that gets fixed when I change it to: RFC 7935 ** Obsolete undefined reference: RFC 6485 (Obsoleted by RFC 7935) I haven’t a clue where this reference is and why this warning is there. == Missing Reference: 'RFC6818' is mentioned on line 416, but not defined And this also seems to be a fail on nroffedit. It’s in the list but not populated in the informative references. 6818 is in the rfc-ref.txt from which the references are pulled. grrr <aside> Have I recently mentioned how much I sometimes %$#@#$ hate the tools we need to use to make these drafts. <\/aside> I’m going to claim I failed here, beg forgiveness, and hope that we’ll let the RFC editor help us out later in the process. - Abstract: Why is the phrase \"(to routers within an Autonomous System)\" in parentheses? sigh - no idea - parentheses removed -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. Where’s that in draft-ietf-sidr-bgpsec-protocol? Regardless, I’m not sure that restoration will work in this draft because there are repeated MUST requirements from other RFC and my AD told me to not capitalize them :) spt"}
{"_id":"doc-en-sidr-EDSzXmE4mHKVgnELv8dF0dXVElw","title":"","text":"[sidr] Kathleen Moriarty's No Objection on\n draft-ietf-sidr-as-migration-06: (with COMMENT)\nKathleen Moriarty has entered the following ballot position for draft-ietf-sidr-as-migration-06: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-as-migration\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- I think the Abstract & introduction are too brief. A lot of concerns might have been avoided with a little more explanation up front. I removed my discuss points as expanding the abstract to include more details in the introduction that appear in the security consideration section isn't really discussable, but would help the draft IMO. Comments are left, I didn't comb through them, so take or leave the ones that have not been addressed. Thank you. --- Standards Track *is* right for this document, but it takes a little to understand that while the document doesn't make any changes to the protocol, it does describe how implementations use the protocol to deliver a specific function. --- Some rewording of the introduction could go a long way in helping with document clarity: Possibly: \"This document describes how ASN migration may be performed securely using the RPKI and BGPSec mechanisms. It defines the implementation behavior during ASN migration, but does not define any changes to the BGPSec protocol.\" *Note - if the last part remains true --- 1.2 refers to \"private ASNs\" and this term is well understood. But the referenced RFC 1930 doesn't use that term. It uses the term \"Reserved AS Numbers\" and describes them as \"reserved for private use\". --- Section 2 has \"...merging two or more ASNs...\" I think it is ASes that are being merged. Ditto \"...is not enabled between the ASNs...\" --- Section 3 has Since they are using methods to migrate that do not require coordination with customers, they do not have a great deal of control over the length of the transition period as they might with something completely under their administrative control I can't parse this. If the methods do NOT require coordination with customers, surely the methods are wholly under the control of the operator. Is there a typo: s\/do not require\/require\/ ? Or is there some other message? --- Section 3 As solutions were being proposed for RPKI implementations to solve this transition case, operational complexity and hardware scaling considerations associated with maintaining multiple legacy ASN keys on routers throughout the combined network have been carefully considered. As worded (passive voice) it demands a citation. Possibly it is meant to say that operators have carefully considered this. Maybe that the SIDR WG has done the consideration. --- Section 3 It would be helpful to add a final sentence saying what this section goes on to do. I think it examines the basic functions of RPKI to determine whether they already handle ASN migration and to identify any issues that might arise when an ASN changes. --- 3.1 Route Origin Validation as defined by RFC 6480 [RFC6480] does not need a unique solution to enable AS migration, as the existing protocol and procedure allows for a solution. That doesn't read too well to me at least, do you mean something like: Route Origin Validation as defined by RFC 6480 [RFC6480] does not need modification to enable AS migration, as the existing protocol and procedure allows for a solution as follows. --- 3.1 In the scenario discussed, AS64510 is being replaced by AS64500. s\/discussed\/discussed in RFC 7705\/ --- There are some abbreviations that will need to be expanded (e.g., ROA) --- 3.2.1 has... However, there is currently no guidance in the BGPSec protocol specification [I-D.ietf-sidr-bgpsec-protocol] on whether or not the forward-signed ASN value is required to match the configured remote AS to validate properly \"currently\" looks unlikely to change at this stage given the status of draft-ietf-sidr-bgpsec-protocol. So, either - make the changes to draft-ietf-sidr-bgpsec-protocol while you can or - change this text to reflect reality as... \"However, there is no guidance...\" --- 3.2.1 s\/remote as 64510\/remote AS 64510\/ s\/local as 64510\/local AS 64510\/ --- 3.2.1 It took me several attempts to parse... Assuming that this mismatch will be allowed by vendor implementations and using it as a means to solve this migration case is likely to be problematic. Did you mean: If we assume that this mismatch will be allowed by vendor implementations and that using it as a means to solve this migration case, then we are likely to see problems when implementations disallow the mismatch. --- 3.2.2 However, if the updates are left intact, this will cause the AS Path length to be increased, which is undesirable as discussed in RFC7705 [RFC7705]. On reading this I thought: \"Undesirable is OK for a short transition period,\" but I went and read 7705. There, in the introduction, it says \"it is critical that the ISP does not increase AS_PATH length during or after ASN migration\". So I would s\/is undesirable\/must be avoided\/ (Note: Section 4 has this as MUST NOT.) --- The text before the bullets in section 4 should... s\/listed in no particular order:\/listed in no particular order. BGPSec:\/ Then \"BGPSec\" can be deleted from the first bullet. --- In section 5... Since that PE has been moved to AS64500, it is not possible for it to forward-sign AS64510 with pCount=0 without some minor changes to the BGPSec implementation to address this use case. I know what this is saying, but it is a bit skewed since implementations are not normally in scope for our specs. Perhaps... Since that PE has been moved to AS64500, this described a new behavior for implementations to forward-sign AS64510 with pCount=0. --- Section 5 This document proposes applying a similar technique Too late! If this is to be an RFC on the Standards Track then This document describes how to apply a similar technique --- Section 5 has (see section 4.4 of the above-referenced draft) Really? Too tired to actually include the reference? But by the time this document is published the reference will be an RFC and this text will be left dangling. ---- 5.2 The requirement to sign updates in iBGP represents a change to the normal behavior for this specific AS-migration implementation only. s\/implementation\/scenario\/ --- I always love it when the Acknowledgements section thanks one of the authors :-) --- Section 8 This has happened before, but it usually leads the IESG to say \"Hang on, why don't you just fix the protocol spec?\" At the least, the Abstract and Introduction need to include the right text that would be present for an \"Update\". That is: what document is updated and what change is made. --- Section 9 Is \"reasonably secure\" should be replaced with something more accurate. Maybe this will come with the new text Sandy is working on. this is not fundamentally altering the existing security risks for BGPSec. That seems to say \"...is somewhat (or marginally) altering...\" which doesn't sound good. --- I hope the more detailed review is helpful. I still need to look at BGPsec to feel more comfortable with this one."}
{"_id":"doc-en-sidr-oI_25NC84j1RUM35Bm4sI5r0F-I","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nHiya, On 04\/01\/17 21:39, Montgomery, Douglas (Fed) wrote: The RPKI validating caches *are* the relaying parties for BGPsec, they are (a) designed to be run on a separate box than the router itself and (b) their behavior WRT exchanges with RPKI repositories is independent of BGP message processing by any of the routers that they serve. Sure. That makes sense. But where's it stated for BGPsec that the RP ought act that way? Cheers, S. Maybe the first few sections of https:\/\/tools.ietf.org\/html\/rfc6810 would make that point better than my mumblings. e.g., For various research \/ measurement reasons we run 3 different validating caches that don’t serve a single BGP router. Their exchanges with the repositories are no different than if they served a DFZ BGP router. Dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 3:48 PM, \"Stephen Farrell\" <stephen.farrell@cs.tcd.ie> wrote: Hiya, On 04\/01\/17 20:00, Montgomery, Douglas (Fed) wrote: Stephen, If I understand your question, I don’t think one can infer anything about the BGP feeds or route selection processes of an AS based upon the traffic a validating cache sends to RPKI repositories. Is that the same traffic a BGPsec relying party sends? I can imagine that it might or might not be, but don't recall the BGPsec spec saying. If, in fact, it isn't possible to infer which ASes are likely to be used from the traffic emitted by an RP for PKI purposes, then yes, this discuss point goes away. (I think:-) Cheers, S. The design of RPKI validating caches (and all implementations that I know of) prefetch and validate RPKI objects independent of BGP traffic processing. That is, they are background processing the entire RPKI, and are not event driven by BGP traffic. As a matter of fact, the RPKI validating cache’s are typically on systems that have no reason to implement BGP at all. Also the RPKI-to-Rtr protocol between the cache and router is batch driven (roughly) by the validation process, not BGP event driven. I.e., the RPKI traffic to a validating cache in an AS with no BGP feeds and one with full BGP feeds is the same, and both independent of BGP event processing. If that was not the supposition of your question … please ignore. dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 2:33 PM, \"sidr on behalf of Stephen Farrell\" <sidr-bounces@ietf.org on behalf of stephen.farrell@cs.tcd.ie> wrote: ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … More or less if traffic to\/from ASxxxx is visible to an attacker and\/or can be modified by an attacker. That could be due to collusion between the AS and an attacker for example, or because an attacker has compromised some routers within a transit AS. If a link goes down, I'm not sure this is only if a link goes down. I'd guess the same risk would exist when any BGPsec path is first seen at a relying party and where that RP doesn't have all the necessary RPKI stuff cached before signature validation. . and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. Right. Sorry to not be clearer on what might become visible to the network outside the RP's AS - I'm afraid I just don't have all the RPKI details in my head;-) That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Right, I think all that'd be needed for this would be to ack that there's this (normally fairly minor) new risk and that you can avoid it if you pre-fetch enough stuff. (As a separate question, I wonder if the amount of stuff involved in the RPKI is such that it'd be fairly easy to pre-fetch it all frequently enough to nearly never hit this problem.) Cheers, S. Russ"}
{"_id":"doc-en-sidr-Ze75QArV-bOMLlWrVPbXKts-SHI","title":"","text":"[sidr] Ben Campbell's Yes on draft-ietf-sidr-bgpsec-protocol-21:\n (with COMMENT)\nBen Campbell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Yes When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- I share some of the concerns about deployability, but have nothing new to add to that conversation. Otherwise I just have a few minor comments: -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader. - 5.2, step 2: I'm almost sure I've missed something here, but if I understand correctly, previous sections talked about how a peer can propagate a BGPsec_Path attribute without modification. Will that cause a problem in this step if the immediate peer propagated an unmodified BGPsec_Path that came from a different AS? - 8.4, last paragraph: The text describes a replay attack, and delegates the mitigation solution to draft-ietf-sidr-bgpsec-rollover. This is an informational reference; it seems like it should be normative."}
{"_id":"doc-en-sidr-kt_Jig2RybRaOxJRcE4o0vvdIkk","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nThe RPKI validating caches *are* the relaying parties for BGPsec, they are (a) designed to be run on a separate box than the router itself and (b) their behavior WRT exchanges with RPKI repositories is independent of BGP message processing by any of the routers that they serve. Maybe the first few sections of https:\/\/tools.ietf.org\/html\/rfc6810 would make that point better than my mumblings. e.g., For various research \/ measurement reasons we run 3 different validating caches that don’t serve a single BGP router. Their exchanges with the repositories are no different than if they served a DFZ BGP router. Dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 3:48 PM, \"Stephen Farrell\" <stephen.farrell@cs.tcd.ie> wrote: Hiya, On 04\/01\/17 20:00, Montgomery, Douglas (Fed) wrote: Stephen, If I understand your question, I don’t think one can infer anything about the BGP feeds or route selection processes of an AS based upon the traffic a validating cache sends to RPKI repositories. Is that the same traffic a BGPsec relying party sends? I can imagine that it might or might not be, but don't recall the BGPsec spec saying. If, in fact, it isn't possible to infer which ASes are likely to be used from the traffic emitted by an RP for PKI purposes, then yes, this discuss point goes away. (I think:-) Cheers, S. The design of RPKI validating caches (and all implementations that I know of) prefetch and validate RPKI objects independent of BGP traffic processing. That is, they are background processing the entire RPKI, and are not event driven by BGP traffic. As a matter of fact, the RPKI validating cache’s are typically on systems that have no reason to implement BGP at all. Also the RPKI-to-Rtr protocol between the cache and router is batch driven (roughly) by the validation process, not BGP event driven. I.e., the RPKI traffic to a validating cache in an AS with no BGP feeds and one with full BGP feeds is the same, and both independent of BGP event processing. If that was not the supposition of your question … please ignore. dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 2:33 PM, \"sidr on behalf of Stephen Farrell\" <sidr-bounces@ietf.org on behalf of stephen.farrell@cs.tcd.ie> wrote: ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … More or less if traffic to\/from ASxxxx is visible to an attacker and\/or can be modified by an attacker. That could be due to collusion between the AS and an attacker for example, or because an attacker has compromised some routers within a transit AS. If a link goes down, I'm not sure this is only if a link goes down. I'd guess the same risk would exist when any BGPsec path is first seen at a relying party and where that RP doesn't have all the necessary RPKI stuff cached before signature validation. . and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. Right. Sorry to not be clearer on what might become visible to the network outside the RP's AS - I'm afraid I just don't have all the RPKI details in my head;-) That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Right, I think all that'd be needed for this would be to ack that there's this (normally fairly minor) new risk and that you can avoid it if you pre-fetch enough stuff. (As a separate question, I wonder if the amount of stuff involved in the RPKI is such that it'd be fairly easy to pre-fetch it all frequently enough to nearly never hit this problem.) Cheers, S. Russ"}
{"_id":"doc-en-sidr-r7Htbpv5W6g3exLjYFWws3MYhLA","title":"","text":"[sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-pki-profiles-19: (with COMMENT)\nBen Campbell has entered the following ballot position for draft-ietf-sidr-bgpsec-pki-profiles-19: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-pki-profiles\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- A few strictly editorial comments: - IDNits complains about some undefined references. - Abstract: Why is the phrase \"(to routers within an Autonomous System)\" in parentheses? -2: draft-ietf-sidr-bgpsec-protocol explicitly excludes non-capitalized versions of 2119 words. This draft does not. It seems different 2119 approaches among the various bgpsec draft could be confusing to the reader."}
{"_id":"doc-en-sidr-lSOBb3zomXRbciyxPaVGo_5lht4","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nHiya, On 04\/01\/17 20:00, Montgomery, Douglas (Fed) wrote: Stephen, If I understand your question, I don’t think one can infer anything about the BGP feeds or route selection processes of an AS based upon the traffic a validating cache sends to RPKI repositories. Is that the same traffic a BGPsec relying party sends? I can imagine that it might or might not be, but don't recall the BGPsec spec saying. If, in fact, it isn't possible to infer which ASes are likely to be used from the traffic emitted by an RP for PKI purposes, then yes, this discuss point goes away. (I think:-) Cheers, S. The design of RPKI validating caches (and all implementations that I know of) prefetch and validate RPKI objects independent of BGP traffic processing. That is, they are background processing the entire RPKI, and are not event driven by BGP traffic. As a matter of fact, the RPKI validating cache’s are typically on systems that have no reason to implement BGP at all. Also the RPKI-to-Rtr protocol between the cache and router is batch driven (roughly) by the validation process, not BGP event driven. I.e., the RPKI traffic to a validating cache in an AS with no BGP feeds and one with full BGP feeds is the same, and both independent of BGP event processing. If that was not the supposition of your question … please ignore. dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 2:33 PM, \"sidr on behalf of Stephen Farrell\" <sidr-bounces@ietf.org on behalf of stephen.farrell@cs.tcd.ie> wrote: ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … More or less if traffic to\/from ASxxxx is visible to an attacker and\/or can be modified by an attacker. That could be due to collusion between the AS and an attacker for example, or because an attacker has compromised some routers within a transit AS. If a link goes down, I'm not sure this is only if a link goes down. I'd guess the same risk would exist when any BGPsec path is first seen at a relying party and where that RP doesn't have all the necessary RPKI stuff cached before signature validation. . and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. Right. Sorry to not be clearer on what might become visible to the network outside the RP's AS - I'm afraid I just don't have all the RPKI details in my head;-) That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Right, I think all that'd be needed for this would be to ack that there's this (normally fairly minor) new risk and that you can avoid it if you pre-fetch enough stuff. (As a separate question, I wonder if the amount of stuff involved in the RPKI is such that it'd be fairly easy to pre-fetch it all frequently enough to nearly never hit this problem.) Cheers, S. Russ"}
{"_id":"doc-en-sidr-A-7xhQ4CjYVHvqY1ETOCvu59fas","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen, If I understand your question, I don’t think one can infer anything about the BGP feeds or route selection processes of an AS based upon the traffic a validating cache sends to RPKI repositories. The design of RPKI validating caches (and all implementations that I know of) prefetch and validate RPKI objects independent of BGP traffic processing. That is, they are background processing the entire RPKI, and are not event driven by BGP traffic. As a matter of fact, the RPKI validating cache’s are typically on systems that have no reason to implement BGP at all. Also the RPKI-to-Rtr protocol between the cache and router is batch driven (roughly) by the validation process, not BGP event driven. I.e., the RPKI traffic to a validating cache in an AS with no BGP feeds and one with full BGP feeds is the same, and both independent of BGP event processing. If that was not the supposition of your question … please ignore. dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research at NIST\/ITL\/ANTD On 1\/4\/17, 2:33 PM, \"sidr on behalf of Stephen Farrell\" <sidr-bounces@ietf.org on behalf of stephen.farrell@cs.tcd.ie> wrote: ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … More or less if traffic to\/from ASxxxx is visible to an attacker and\/or can be modified by an attacker. That could be due to collusion between the AS and an attacker for example, or because an attacker has compromised some routers within a transit AS. If a link goes down, I'm not sure this is only if a link goes down. I'd guess the same risk would exist when any BGPsec path is first seen at a relying party and where that RP doesn't have all the necessary RPKI stuff cached before signature validation. . and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. Right. Sorry to not be clearer on what might become visible to the network outside the RP's AS - I'm afraid I just don't have all the RPKI details in my head;-) That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Right, I think all that'd be needed for this would be to ack that there's this (normally fairly minor) new risk and that you can avoid it if you pre-fetch enough stuff. (As a separate question, I wonder if the amount of stuff involved in the RPKI is such that it'd be fairly easy to pre-fetch it all frequently enough to nearly never hit this problem.) Cheers, S. Russ"}
{"_id":"doc-en-sidr-YNfX9SwAdskJfazltaN5HdVNvpE","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nwhile i would also like to see less use of sha-1 in new network protocols... limiting the SKI length to a fixed 20 bytes is not really a bad idea for implementation efficiency and interoperability. as Sean points out, rfc7093's straight forward (leftmost 160 bits --20bytes) of a SHA-2 algorithm digest works well for the use of a hash value in this particular context (generating Key Identifiers).. mA From: Sean Turner <sean@sn3rd.com> To: Stephen Farrell <stephen.farrell@cs.tcd.ie> Cc: sidr-chairs@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; The IESG <iesg@ietf.org>; m.waehlisch@fu-berlin.de; sidr@ietf.org Sent: Wednesday, January 4, 2017 10:48 AM Subject: Re: [sidr] Stephen Farrell's Discuss on draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT) On Jan 4, 2017, at 08:53, Stephen Farrell <stephen.farrell@cs.tcd.ie> wrote: Stephen Farrell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Discuss When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... (1) 3.2\/Figure 7: A fixed 20 byte SKI being a sha-1 hash of the public key is a bad plan, for all the usual reasons. Why is it ok for that to be hardcoded here when it could change if\/when new alg choices are made for the RPKI? If it is not too late then I think you should add a length or alg field to that. If it is too late to do that, then are we really ok that you will need to rev the BGPsec version number in order to get rid of all sha-1 code from your implementation? That seems like a bad plan for a new protocol. Not sure it absolutely needs a length field; if the RPKI does ever decide to change to another hash algorithm for SKI, e.g., SHA-256\/384\/512, or to change to a hash of the SubjectPublicKeyInfo they could always the procedures from https:\/\/datatracker.ietf.org\/doc\/rfc7093\/ to generate the values for a 20-byte value. spt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr while i would also like to see less use of sha-1 in new network protocols...limiting the SKI length to a fixed 20 bytes is not really a bad idea for implementation efficiency and interoperability.as Sean points out, rfc7093's straight forward (leftmost 160 bits --20bytes) of a SHA-2 algorithm digest works well for the use of a hash value in this particular context (generating Key Identifiers)..mA From: Sean Turner <sean@sn3rd.com> To: Stephen Farrell <stephen.farrell@cs.tcd.ie> Cc: sidr-chairs@ietf.org; draft-ietf-sidr-bgpsec-protocol@ietf.org; The IESG <iesg@ietf.org>; m.waehlisch@fu-berlin.de; sidr@ietf.org Sent: Wednesday, January 4, 2017 10:48 AM Subject: Re: [sidr] Stephen Farrell's Discuss on draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT) > > > Stephen Farrell has entered the following ballot position for> draft-ietf-sidr-bgpsec-protocol-21: Discuss> > When responding, please keep the subject line intact and reply to all> email addresses included in the To and CC lines. (Feel free to cut this> introductory paragraph, however.)> > > Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html> for more information about IESG DISCUSS and COMMENT positions.> > > The document, along with other ballot positions, can be found here:> https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/> > > > ----------------------------------------------------------------------> DISCUSS:> ----------------------------------------------------------------------> > > > I have a couple of fairly straightforward things I'd> like to briefly discuss...> > (1) 3.2\/Figure 7: A fixed 20 byte SKI being a sha-1 hash> of the public key is a bad plan, for all the usual> reasons. Why is it ok for that to be hardcoded here when> it could change if\/when new alg choices are made for the> RPKI? If it is not too late then I think you should add a> length or alg field to that. If it is too late to do that,> then are we really ok that you will need to rev the BGPsec> version number in order to get rid of all sha-1 code from> your implementation? That seems like a bad plan for a new> protocol.Not sure it absolutely needs a length field; if the RPKI does ever decide to change to another hash algorithm for SKI, e.g., SHA-256\/384\/512, or to change to a hash of the SubjectPublicKeyInfo they could always the procedures from https:\/\/datatracker.ietf.org\/doc\/rfc7093\/ to generate the values for a 20-byte value. spt_______________________________________________sidr mailing listsidr@ietf.orghttps:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-2nFrHRXRx1J4uVcca6EViLBitC8","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\n---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … More or less if traffic to\/from ASxxxx is visible to an attacker and\/or can be modified by an attacker. That could be due to collusion between the AS and an attacker for example, or because an attacker has compromised some routers within a transit AS. If a link goes down, I'm not sure this is only if a link goes down. I'd guess the same risk would exist when any BGPsec path is first seen at a relying party and where that RP doesn't have all the necessary RPKI stuff cached before signature validation. . and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. Right. Sorry to not be clearer on what might become visible to the network outside the RP's AS - I'm afraid I just don't have all the RPKI details in my head;-) That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Right, I think all that'd be needed for this would be to ack that there's this (normally fairly minor) new risk and that you can avoid it if you pre-fetch enough stuff. (As a separate question, I wonder if the amount of stuff involved in the RPKI is such that it'd be fairly easy to pre-fetch it all frequently enough to nearly never hit this problem.) Cheers, S. Russ"}
{"_id":"doc-en-sidr-rYfg3BKnioE2juyf5uRKeTRluXk","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\n---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... [snip] (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) I am not sure what you mean by a \"compromised AS,” but it may not matters … If a link goes down, and that causes an alternative path to be selected, that forces the validation a new path which might involve a previously unvalidated AS. If an OCSP responder or repository that provides RPKI objects is contacted as part of that validation, then some external entities can detect that something is changing. That is, stuff not normally validated because it is associated with a unselected path gets fetched. That said, the NOC could fetch a snapshot of the RPKI, then the exposure of the switch to a new path can be limited to that AS. This assumes that the snapshot uses CRLs, which seems like a very reasonable choice in the RPKI. Russ"}
{"_id":"doc-en-sidr-jvFMO7kZAjR8GabLZzapK7Q-c3U","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nHiya, On 04\/01\/17 18:48, Sean Turner wrote: Stephen Farrell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Discuss When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... (1) 3.2\/Figure 7: A fixed 20 byte SKI being a sha-1 hash of the public key is a bad plan, for all the usual reasons. Why is it ok for that to be hardcoded here when it could change if\/when new alg choices are made for the RPKI? If it is not too late then I think you should add a length or alg field to that. If it is too late to do that, then are we really ok that you will need to rev the BGPsec version number in order to get rid of all sha-1 code from your implementation? That seems like a bad plan for a new protocol. Not sure it absolutely needs a length field; if the RPKI does ever decide to change to another hash algorithm for SKI, e.g., SHA-256\/384\/512, or to change to a hash of the SubjectPublicKeyInfo they could always the procedures from https:\/\/datatracker.ietf.org\/doc\/rfc7093\/ to generate the values for a 20-byte value. Something like that could work I guess e.g. if this draft said \"if a router cert contains an SKI that's != 20 bytes long, then here's what you do...\" that'd be fine. I'm not sure that's identical to what's in 7093 though but it is close and should be fairly obvious and uncontroversial. I do think it very worthwhile though to not so closely couple the code for generating SKIs with that for BGPsec as they will (I guess) tend to be different codebases not evolving in a tightly coupled manner. Cheers, S. spt"}
{"_id":"doc-en-sidr-LeUCbidS9Bz2pOKjTHPtaXA8V4I","title":"","text":"Re: [sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen Farrell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Discuss When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... (1) 3.2\/Figure 7: A fixed 20 byte SKI being a sha-1 hash of the public key is a bad plan, for all the usual reasons. Why is it ok for that to be hardcoded here when it could change if\/when new alg choices are made for the RPKI? If it is not too late then I think you should add a length or alg field to that. If it is too late to do that, then are we really ok that you will need to rev the BGPsec version number in order to get rid of all sha-1 code from your implementation? That seems like a bad plan for a new protocol. Not sure it absolutely needs a length field; if the RPKI does ever decide to change to another hash algorithm for SKI, e.g., SHA-256\/384\/512, or to change to a hash of the SubjectPublicKeyInfo they could always the procedures from https:\/\/datatracker.ietf.org\/doc\/rfc7093\/ to generate the values for a 20-byte value. spt"}
{"_id":"doc-en-sidr-jDuwMmArCU3xdXcj3SJha43fwIY","title":"","text":"[sidr] =?utf-8?q?Mirja_K=C3=BChlewind=27s_No_Objection_on_draft-i?=\n =?utf-8?q?etf-sidr-bgpsec-protocol-21=3A_=28with_COMMENT=29?=\nMirja Kühlewind has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- First, thanks for a well written document! A few question on the design; not to propose changes but I would like to learn the reason why the design is as it is: 1) Why do you need to send two different negotiation capabilities for each direction instead of just using two flags in the same capability? And similar why don't you just announce multiple address families in the same capability (using variable length)? 2) Why are the Secure_Path elements and Signature_Block blocks not aligned but in two different lists (given there is and one to one mapping)? Wouldn't it be easier to just update one length field (at a fixed position) and attached the new information at the end? Or to ask the question differently: why is the format as shown in figure 8 not used in the message itself (->this is related to Suresh's question)? Questions on operation: 1) section 5 says \"a BGPsec speaker MAY temporarily defer validation of incoming BGPsec update messages\". Does this mean it has to remember its state before applying the update message such that is can revert to this state if it later detects that die update message was not valid? Or what action is supposed to happen if the update message is detected as not valid later on 2) sec 4.2 says \"Next, the BGPsec speaker generates one or two Signature_Blocks.\" Are you sure it's at max 2? I guess this depends on the expected update cycles of the algorithm compared to the devices. Given update cycles for devices can be very slow and updates for algorithm can be fast if any security problems are detected, I wouldn't recommend to limit this to two. 3) In relation to the comment above, I'm not a big fan of the algo migration strategy in section 6.1. I understand the problem that all router on the path need to potentially support the algo. However, you do have an negotiation phase. So why don't you the advertise the signing algorithm in the negotiation capabilities? In this case the sender could at least choose to only send the one(s) that is\/are also supported by the receiver or not use BGPsec at all if there is no match. However, I also understand that it is probably to late to change anything now and if there is wg consensus, I'm fine with that... 4) section 8.1 says \"the recipient of a valid BGPsec update message is assured that the update propagated via the sequence of ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Is that true? It is assured that at least these ASes have been crossed but there might have been others on the path that did not sign the BGPsec_Path attribute, no? 5) Is it really necessary to create registries for \"BGPsec Capability\" and \"BGPsec_Path Flags\"? Given this is a really small number of bits\/flags, I think new RFCs that update this RFC are enough to define a new use for these so far unused bits. Further, editorial proposals: 1) I would propose to add the Confed_Segment flag in figure 5 (and call the remaining flag field 'reserved') 2) Maybe explain Adj-RIB-In or give a reference to RFCrfc4271 section 1.1"}
{"_id":"doc-en-sidr-YYnXaqB81yydgjavfEoK0jmlZyw","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-ops-12: (with COMMENT)\nOn 4 Jan 2017, at 6:49, Alvaro Retana (aretana) wrote: | | -12.2: [I-D.ietf.sider.bgpsec.overview] is mentioned in section 2 as | | needed to understand this document. That suggests it should be a | | normative reference. | | ennie meenie. i think some other reviewer had me push refs around. i | don't have a dog in this fight. my personal opinion would be that | overview is informative and the protocol spec itself is normative. I agree. In fact, it was me who asked to move I-D.ietf-sidr-bgpsec-overview to Informative as the reference to the spec (draft-ietf-sidr-bgpsec-protocol) is the Normative one. In this case, we don’t want to make I-D.ietf-sidr-bgpsec-overview a Normative reference because it is an Informational document and would result in a downref (resulting in more process, and that document is not ready yet). The issue I saw is that section 2 says readers are expected to understand bgpsec, and cites the overview for that purpose. Perhaps it should cite the protocol doc for the \"expected to understand\" part, and them mention separately that the overview provides, well, an overview? Ben."}
{"_id":"doc-en-sidr-XcX9SB3C0f9ExC3O1YltIih_N84","title":"","text":"[sidr] Alissa Cooper's No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nAlissa Cooper has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- - I share various people's concerns about the deployability of this protocol, but I realize this is where the WG ended up after many years of work so fingers crossed, I guess. - Fig 2: Shouldn't the signatures in Sig Block 2 have different identifiers (e.g., X2, Y2) than those in Sig Block 1? - Sec 6.1: \"(likely a small number of years)\" -- given how hard these things are to predict, is it wise to include this text here? - I was surprised not to see an example message or two in this document."}
{"_id":"doc-en-sidr-KERU9pxBcKM4zeo0nGf7PYktwvY","title":"","text":"[sidr] Spencer Dawkins' No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nSpencer Dawkins has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- Perhaps I'm just having a good day, but this is one of the clearest BGP-related specifications I can remember reviewing. Thanks for that, and especially for the background on design decisions. I did have questions on two points (which are spread across multiple sections). I started out wondering why Note that BGPsec update messages can be quite large, therefore any BGPsec speaker announcing the capability to receive BGPsec messages SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages]. isn't a MUST, but Section 7 explains this In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. Perhaps that's worth a forward pointer? (or maybe even dragging this paragraph forward from Section 7) I'm looking at BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero. (That is, pCount is only to be set to zero in cases such as route servers or AS Number Migration where the BGPsec speaker's peer expects pCount to be set to zero.) and wondering why that's not a MUST. If I'm understanding this correctly (which is theoretically possible), the BGPsec speaker is telling its peer that it's not participating as a transit AS, but the peer thinks it should be. Is there anything intelligent that the peer can do with the update? Section 7 refers to this SHOULD, while adding a few more SHOULDs. A peer that is an Internet Exchange Point (IXP) (i.e. Route Server) with a transparent AS is expected to set pCount = 0 in its Secure_Path Segment while forwarding an update to a peer (see Section 4.2). Clearly, such an IXP SHOULD configure itself to set its own pCount = 0. As stated in Section 4.2, \"BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.\" This means that a BGPsec speaker SHOULD be configured so that it permits pCount =0 from an IXP peer and never permits pCount = 0 from a peer that is not an IXP. Again, I'm curious about why a BGPsec speaker wouldn't do this. Is that obvious, to those skilled in the art? I'm looking at Section 8.4, which adds some more background. The mechanism of setting the pCount field to zero is included in this specification to enable route servers in the control path to participate in BGPsec without increasing the length of the AS path. However, entities other than route servers could conceivably use this mechanism (set the pCount to zero) to attract traffic (by reducing the length of the AS path) illegitimately. This risk is largely mitigated if every BGPsec speaker drops incoming update messages that set pCount to zero but come from a peer that is not a route server. However, note that a recipient of a BGPsec update message within which an upstream entity two or more hops away has set pCount to zero is unable to verify for themselves whether pCount was set to zero legitimately. So, the reason this is a SHOULD, and not a MUST, is because a recipient two or more hops away can't be sure pCount was set appropriately? But doesn't the SHOULD increase the chances to propagate an update with an inappropriate pCount?"}
{"_id":"doc-en-sidr-xD_T5KoApsJvCs3S8M0dNwy_MEg","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\n+1 to the comment from Suresh about order. I though that something like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy I believe this is that thread that resulted in the final organization: https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/8B_e4CNxQCUKeZ_AUzsdnn2f5MU spt"}
{"_id":"doc-en-sidr-Ex-1uYTyMzz-0yPqygvwqBsd1Rs","title":"","text":"[sidr] Stephen Farrell's Discuss on\n draft-ietf-sidr-bgpsec-protocol-21: (with DISCUSS and COMMENT)\nStephen Farrell has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Discuss When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I have a couple of fairly straightforward things I'd like to briefly discuss... (1) 3.2\/Figure 7: A fixed 20 byte SKI being a sha-1 hash of the public key is a bad plan, for all the usual reasons. Why is it ok for that to be hardcoded here when it could change if\/when new alg choices are made for the RPKI? If it is not too late then I think you should add a length or alg field to that. If it is too late to do that, then are we really ok that you will need to rev the BGPsec version number in order to get rid of all sha-1 code from your implementation? That seems like a bad plan for a new protocol. (2) Figure 8: It seems to me to be an error to omit the signer's ASN from the signed data and only have that included in the signer's certificate. Why is that intimate level of binding to the RPKI desirable? There may well be reasons but I'm not seeing 'em, and I am recalling that it took a chunk of effort to make CMS less dependent on X.509 for similar reasons (meaning identifying signers exclusively via cert issuer and serial in that case). I would expect that there could be demand to have some level of independence between BGPsec and RPKI for at least internal uses such as those noted in the spec already. (3) section 8: Is there a potential exposure here in that a relying party who emits e.g. certificate status checks or cert retrieval queries for an RPKI cert they've not previously seen is exposing something about the set of paths its traffic is likely to follow. (This is similar to why we have OCSP stapling in the web.) IIRC the RPKI specs may cover this but I suspect it'd be worth noting here as well even if so as this represents exposing something about BGP announcement content to off-path parties which I think is new for BGP. Is that a new thing for BGP? (I think the new aspect to the attack is that a bad actor who has already compromised some AS could more easily spot that traffic from the relying party's AS is likely to transit the compromised AS.) ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- - (Non actionable comment really aimed at the IESG and not the authors\/WG...) I'm kinda sad that even today we don't appear to have learned to value deploy-ability more highly. I fear that BGPsec and RPKI will suffer a similar lack of deployment as seen with S\/MIME and DNSSEC and for possibly similar reasons (complexity, not starting with modest improvements, requiring a number of parties to change before seeing benefits). I hope I'm wrong about that, but equally, if I'm not and RPKI\/BGPsec deployment turns out to be very very slow, (as opposed to the optimistic, \"just slow\";-) then I also hope the IESG at that time will be willing to consider alternatives - it's too easy for the IETF to just get stuck when a technology like this fails to deploy. But maybe I'm wrong and this'll all be fine and will be widely deployed and used in a few years. - Figures 2 and 5 present the fields in different orders. That seems like a bad idea. - 3.2: The reference to the pki profile doc is not precise enough, the string \"key identifier\" does not occur in that draft - it's in RFC6487, 4.8.2. - 4.1, last para: is the distinction between an \"internal peer\" and \"iBGP peer\" sufficiently clear to routing folk? For me they sound similar but I assume it's ok. - 5.2, I think you need to say something to the effect that every Secure_Path MUST have a signature with an algorithm that is supported. As I read the text, the algorithm as stated here could be read to not require that. E.g. the para before the bullets on p25 could be read to mean \"drop all stuff involving unsupported algs and then continue to process the rest of the stuff.\" - section 7: WRT non-deterministic signature algorithms, I think it'd be useful to note here that all such algorithms require good random number generation on the signer's system and that failing in that respect can expose the signer's private key. IMO deterministic signature schemes are better for this reason but the need for a good RNG is I think a real operational issue worthy of note."}
{"_id":"doc-en-sidr-3YmtHqBOh-zA_pc9qUT_pyJorP0","title":"","text":"Re: [sidr] Ben Campbell's No Objection on\n draft-ietf-sidr-bgpsec-ops-12: (with COMMENT)\nOn 1\/3\/17, 9:00 PM, \"Randy Bush\" <randy@psg.com> wrote: | | -12.2: [I-D.ietf.sider.bgpsec.overview] is mentioned in section 2 as | | needed to understand this document. That suggests it should be a | | normative reference. | | ennie meenie. i think some other reviewer had me push refs around. i | don't have a dog in this fight. my personal opinion would be that | overview is informative and the protocol spec itself is normative. I agree. In fact, it was me who asked to move I-D.ietf-sidr-bgpsec-overview to Informative as the reference to the spec (draft-ietf-sidr-bgpsec-protocol) is the Normative one. In this case, we don’t want to make I-D.ietf-sidr-bgpsec-overview a Normative reference because it is an Informational document and would result in a downref (resulting in more process, and that document is not ready yet). Alvaro. | | -12.2: [I-D.ietf.sider.bgpsec.overview] is mentioned in section 2 as | | needed to understand this document. That suggests it should be a | | normative reference. | | ennie meenie. i think some other reviewer had me push refs around. i | don't have a dog in this fight. my personal opinion would be that | overview is informative and the protocol spec itself is normative. I agree. In fact, it was me who asked to move I-D.ietf-sidr-bgpsec-overview to Informative as the reference to the spec (draft-ietf-sidr-bgpsec-protocol) is the Normative one. In this case, we don’t want to make I-D.ietf-sidr-bgpsec-overview a Normative reference because it is an Informational document and would result in a downref (resulting in more process, and that document is not ready yet). Alvaro."}
{"_id":"doc-en-sidr-AjEyj7lpK7zQezwAuBhgeQue-1o","title":"","text":"Re: [sidr] Alexey Melnikov's Yes on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\n+1 to the comment from Suresh about order. I though that something like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. a vendor engineer actually implementing requested the change to the current syntax for ease of generating\/parsing. randy"}
{"_id":"doc-en-sidr--7oNzgmHsRs4eZtBFmmIeL5LGSA","title":"","text":"[sidr] Alexey Melnikov's Yes on draft-ietf-sidr-bgpsec-protocol-21:\n (with COMMENT)\nAlexey Melnikov has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: Yes When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- +1 to the comment from Suresh about order. I though that something like what he proposed will minimize memcopies and possibly use of memory why hashing. So I am also curious to know answer to his question. Otherwise the document is very well written and it was a pleasure to read!"}
{"_id":"doc-en-sidr-f4AMOXqlCHJ1wnvvTrdefP6ISBE","title":"","text":"[sidr] Suresh Krishnan's No Objection on\n draft-ietf-sidr-bgpsec-protocol-21: (with COMMENT)\nSuresh Krishnan has entered the following ballot position for draft-ietf-sidr-bgpsec-protocol-21: No Objection When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- * Section 2.1 The IANA registry at http:\/\/www.iana.org\/assignments\/address-family-numbers\/address-family-numbers.xhtml may be a better reference for AFIs than RFC4760. * Section 4.2 Is there a specific reason that the signature construction algorithm orders the fields in the way it does? It does look pretty complicated to parse out and arrange the fields this way from the BGPsec packet that was received. Something like the following seems much simpler to calculate +------------------------------------+ | Target AS Number | +------------------------------------+ ---\\ | Signature Segment : N-1 | \\ +------------------------------------+ \\ ... | +------------------------------------+ | | Signature Segment : 2 | | +------------------------------------+ | | Signature Segment : 1 | \\ +------------------------------------+ > Data from | Secure_Path Segment : N | \/ N Segments +------------------------------------+ | ... | +------------------------------------+ | | Secure_Path Segment : 2 | | +------------------------------------+ \/ | Secure_Path Segment : 1 | \/ +------------------------------------+---\/ | Algorithm Suite Identifier | +------------------------------------+ | AFI | +------------------------------------+ | SAFI | +------------------------------------+ | Prefix | +------------------------------------+ as the segment fields and signature fields are naturally grouped together in the packet. Is there a difference in cryptographic strength between these two constructions?"}
{"_id":"doc-en-sidr-_u6Kcvd3oz6as_SLVn4tgvRH1Xo","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nthat is not the core of the problem. the bgpsec protocol doc has to specifically say that the public AS upon receiving the update from the private AS o if the private signed to the public, public should check sig, then strip it and then might sign as the originating AS or might not. on what criteria does it decide? o if the private did not sign, the public might sign or it might not. on what criteria does it decide? as i said, once you burn that in, i will hack the ops doc Does this change (in Section 7 in the document) work for you? [OLD] It is possible that a stub customer of an ISP employs a private AS number. Such a stub customer cannot publish a ROA in the global RPKI for the private AS number and the prefixes that they use. Also, the stub customer cannot become a BGPsec speaker. If a BGPsec speaker in the ISP's AS receives an announcement for a prefix from the stub customer and chooses to propagate it to BGPsec peers, then it MUST strip the private AS and re-originate the prefix. In order to do this, the prefix MUST have a ROA authorizing the ISP's AS to originate it. [NEW] It is possible that a stub customer of an ISP employs a private AS number. Such a stub customer cannot publish a ROA in the global RPKI for the private AS number and the prefixes that they use. Also, the global RPKI cannot support private AS numbers for issuing router certificates for eBGP routers in the private AS. For interactions between the stub customer and the ISP, the following two scenarios are possible: 1. The stub customer sends an unsigned BGP update for a prefix to the ISP's AS. An edge BGPsec speaker in the ISP's AS may choose to propagate the prefix to its non-BGPsec and BGPsec peers. If so, the ISP's edge BGPsec speaker MUST strip the AS_PATH with the private AS number, and then (a) re-originate the prefix without any signatures towards its non-BGPsec peer and (b) re-originate the prefix including its own signature towards its BGPsec peer. In both cases (i.e. (a) and (b)), the prefix MUST have a ROA in the global RPKI authorizing the ISP's AS to originate it. 2. The ISP and the stub customer may use a local RPKI repository (using a mechanism such as described in [I-D.ietf-sidr-slurm]). Then there can be a ROA for the prefix originated by the sub AS, and the eBGP speaker in the stub AS can be a BGPsec speaker having a router certificate, albeit the ROA and router certificate are valid only locally. With this arrangement, the stub AS sends a signed update for the prefix to the ISP's AS. An edge BGPsec speaker in the ISP's AS validates the update using RPKI data based the local RPKI view. Further, it may choose to propagate the prefix to its non-BGPsec and BGPsec peers. If so, the ISP's edge BGPsec speaker MUST strip the Secure_Path and the Signature Segment received from the stub AS with the private AS number, and then (a) re-originate the prefix without any signatures towards its non-BGPsec peer and (b) re-originate the prefix including its own signature towards its BGPsec peer. In both cases (i.e. (a) and (b)), the prefix MUST have a ROA in the global RPKI authorizing the ISP's AS to originate it. i am easily confused. can this be said with significantly less words so i have a chance to actually understand it? randy"}
{"_id":"doc-en-sidr-E8mGsjC8w-pQemrx1_dILjHIZJw","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nOn Mon, Jan 2, 2017 at 9:32 AM, Borchert, Oliver (Fed) < oliver.borchert@nist.gov> wrote: To avoid unnecessary confusion with the ambiguity of the word private, I would change the wording of “the (private) Member-AS Number” to “the Member-AS Number” by removing the wording of “(private)” within parenthesis. This leaves the usage of private only for the signing parties private key which I think is well understood. Oliver I'd suggest the use of \"private use\" in the parenthesis instead of eliminating the word \"private\", and maybe add an informational reference to RFC6996 as well. If the intent that a \"Member-AS Number\" is to be from the private use range as defined in RFC6996, then that should be stated some place. -- =============================================== David Farmer Email:farmer@umn.edu Networking & Telecommunication Services Office of Information Technology University of Minnesota 2218 University Ave SE Phone: 612-626-0815 Minneapolis, MN 55414-3029 Cell: 612-812-9952 =============================================== To avoid unnecessary confusion with the ambiguity of the word private, I would change the wording of “the (private) Member-AS Number” to “the Member-AS Number” by removing the wording of “(private)” within parenthesis. This leaves the usage of private only for the signing parties private key which I think is well understood. OliverI'd suggest the use of \"private use\" in the parenthesis instead of eliminating the word \"private\", and maybe add an informational reference to RFC6996 as well. If the intent that a \"Member-AS Number\" is to be from the private use range as defined in RFC6996, then that should be stated some place.-- ===============================================David Farmer Email:farmer@umn.eduNetworking & Telecommunication ServicesOffice of Information TechnologyUniversity of Minnesota 2218 University Ave SE Phone: 612-626-0815Minneapolis, MN 55414-3029 Cell: 612-812-9952==============================================="}
{"_id":"doc-en-sidr-Wq5MJHvs6sry52F83Ax-z9bFXUU","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nSent: Thursday, December 29, 2016 6:02 PM that is not the core of the problem. the bgpsec protocol doc has to specifically say that the public AS upon receiving the update from the private AS o if the private signed to the public, public should check sig, then strip it and then might sign as the originating AS or might not. on what criteria does it decide? o if the private did not sign, the public might sign or it might not. on what criteria does it decide? as i said, once you burn that in, i will hack the ops doc Does this change (in Section 7 in the document) work for you? [OLD] It is possible that a stub customer of an ISP employs a private AS number. Such a stub customer cannot publish a ROA in the global RPKI for the private AS number and the prefixes that they use. Also, the stub customer cannot become a BGPsec speaker. If a BGPsec speaker in the ISP's AS receives an announcement for a prefix from the stub customer and chooses to propagate it to BGPsec peers, then it MUST strip the private AS and re-originate the prefix. In order to do this, the prefix MUST have a ROA authorizing the ISP's AS to originate it. [NEW] It is possible that a stub customer of an ISP employs a private AS number. Such a stub customer cannot publish a ROA in the global RPKI for the private AS number and the prefixes that they use. Also, the global RPKI cannot support private AS numbers for issuing router certificates for eBGP routers in the private AS. For interactions between the stub customer and the ISP, the following two scenarios are possible: 1. The stub customer sends an unsigned BGP update for a prefix to the ISP's AS. An edge BGPsec speaker in the ISP's AS may choose to propagate the prefix to its non-BGPsec and BGPsec peers. If so, the ISP's edge BGPsec speaker MUST strip the AS_PATH with the private AS number, and then (a) re-originate the prefix without any signatures towards its non-BGPsec peer and (b) re-originate the prefix including its own signature towards its BGPsec peer. In both cases (i.e. (a) and (b)), the prefix MUST have a ROA in the global RPKI authorizing the ISP's AS to originate it. 2. The ISP and the stub customer may use a local RPKI repository (using a mechanism such as described in [I-D.ietf-sidr-slurm]). Then there can be a ROA for the prefix originated by the sub AS, and the eBGP speaker in the stub AS can be a BGPsec speaker having a router certificate, albeit the ROA and router certificate are valid only locally. With this arrangement, the stub AS sends a signed update for the prefix to the ISP's AS. An edge BGPsec speaker in the ISP's AS validates the update using RPKI data based the local RPKI view. Further, it may choose to propagate the prefix to its non-BGPsec and BGPsec peers. If so, the ISP's edge BGPsec speaker MUST strip the Secure_Path and the Signature Segment received from the stub AS with the private AS number, and then (a) re-originate the prefix without any signatures towards its non-BGPsec peer and (b) re-originate the prefix including its own signature towards its BGPsec peer. In both cases (i.e. (a) and (b)), the prefix MUST have a ROA in the global RPKI authorizing the ISP's AS to originate it. Sriram"}
{"_id":"doc-en-sidr-fguWWcaaIzIkIlYIObrH0DfoF7c","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nSee my comments inline >>> 1. It is common to use private ASNs in Confederations, >> but the global RPKI can’t support that. draft-ietf-sidr-slurm seems >> to address the issue of local management of private resources in the >> RPKI. … >the issue is not how the confed AS validates ROAs of the private ASs in >the confed. that is trivial and supported by existing software. my >questions revolve around path processing. I believe the answer to your question is found in section 7, paragraph #8 and following. There I see explanation on how to process the path using private AS numbers, etc. >4.3 confuses me by using 'private' ambiguously. i have tried to read >that section yet again and drowned in the mass of words. perhaps more >coffee will help; but i am not optimistic. i pity the implementors. > >randy Revisiting Section 4.3, I made the following observations: In my opinion the second Paragraph explains clearly the process of the ingress BGPSec router at the confederation boundary. I believe the process described of adding a signature with pCount=0 will resolve the issue that Alvaro observed. Said that, I feel that the explanations in paragraphs #3 and #4 are not very helpful. There I do agree with Randy's \"mass of words\" comment. I suggest to either shorten them or completely remove them. These two paragraphs are not needed, in contrary they might add unnecessary confusion. When removed the following current paragraphs 5 and following do explain clearly the process in the intermediate AS-members and the egress BGPSec router of the confederation. In short I think paragraphs #3 and #4 disrupt the flow and are not so helpful, so I propose to remove them. To avoid unnecessary confusion with the ambiguity of the word private, I would change the wording of “the (private) Member-AS Number” to “the Member-AS Number” by removing the wording of “(private)” within parenthesis. This leaves the usage of private only for the signing parties private key which I think is well understood. Oliver"}
{"_id":"doc-en-sidr-lZsJudYpZzdRhbKazMrq9I0Xrhw","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\n1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. … the issue is not how the confed AS validates ROAs of the private ASs in the confed. that is trivial and supported by existing software. my questions revolve around path processing. 4.3 confuses me by using 'private' ambiguously. i have tried to read that section yet again and drowned in the mass of words. perhaps more coffee will help; but i am not optimistic. i pity the implementors. randy"}
{"_id":"doc-en-sidr-_htqJIw_T0wQy_5XIPE33691ubg","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\n2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. that is not the core of the problem. the bgpsec protocol doc has to specifically say that the public AS upon receiving the update from the private AS o if the private signed to the public, public should check sig, then strip it and then might sign as the originating AS or might not. on what criteria does it decide? o if the private did not sign, the public might sign or it might not. on what criteria does it decide? as i said, once you burn that in, i will hack the ops doc randy"}
{"_id":"doc-en-sidr-iIBqPdLmGNvi2ZSarmvAGwG3euw","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nHi Alvaro, Please see my comments inline below. From: Alvaro Retana (aretana) [mailto:aretana@cisco.com] Sent: Friday, December 09, 2016 5:00 PM …. Hi! I think the only item left is the Confederations one… …. Yes, I agree that the collusion problem is one that (as you mentioned below) is out of the scope of BGPsec. You are right that pCount=0 (as proposed below) doesn’t solve the collusion problem – but it does address the following security guarantee that is currently not met in the Confederations case (from 8.1): …. In the latest version-21 of the draft that I uploaded last Friday, I have incorporated the solution that you have proposed, namely, adding a signature with pCount = 0, at the border of the confederation (see 2nd, 3rd, and 4th paragraphs added newly in Section 4.3, page 18). As I see it, this solution offers the following three benefits: 1. It eliminates the discontinuity issue at the confederation boundary and hence facilitates maintaining the security guarantee within confederations as well. 2. It allows for tolerance to lack of proper configuration in a BGPsec speaker in an interior AS in a confederation, i.e. when such a BGPsec speaker is not configured to know its confederation’s public AS number. So it addresses the following comment you made earlier: “In this network AS65003 (for example) only needs to know (i.e. be configured) that AS65001 and AS65004 as confederation peers, and not the specific knowledge of which is the confederation ID.” https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08126.html (Randy’s post also seemed to hint that this tolerance would be useful: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08127.html ) 3. A common description of the validation algorithm (Section 5.2) applies to all BGPsec speakers. That is, no exceptions need to be stated for BGPsec speakers inside a confederation. (Previously we had described such exceptions in Section 4.3, but now they are not needed any more and hence deleted.) Related to the above, is the support for private ASNs --- this topic also came up in the review of draft-ietf-sidr-bgpsec-ops, and the GenArt\/SecDir reviews. There are two related points: 1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. … 2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. There are two new paragraphs in the ops and mgmt. section (Section 7, page 30) that discuss proper handling of private ASNs that may be used for stub ASes or inside confederations. Please let me know if I missed anything or if you would like to suggest any wording improvements. Thank you. Sriram"}
{"_id":"doc-en-sidr-T7zTPYOf180aeFswDiuCjMlU438","title":"","text":"Re: [sidr] New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-21.txt\nThis new version incorporates all (except two minor) comments received during the IETF LC review process from Alvaro, SECDIR\/Gen-ART (Russ Housley), and OPSDIR (Nevil Brownlee). The two minor comments not addressed yet are from Russ, and are pending feedback from WG members (particularly implementers). These have to do with minor tweaks to the BGPsec update format structure. Many thanks to Alvaro, Russ, and Nevil for the detailed reviews and comments\/suggestions. Sriram ________________________________________ From: internet-drafts@ietf.org <internet-drafts@ietf.org> Sent: Friday, December 23, 2016 6:53 PM To: Matthew Lepinski; Sriram, Kotikalapudi (Fed) Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-21.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-21.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 21 Title: BGPsec Protocol Specification Document date: 2016-12-23 Group: sidr Pages: 41 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-21.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-21 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-21 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. The IETF Secretariat"}
{"_id":"doc-en-sidr-82mKeTwMfWpmviMvfvt2jRZvh2c","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-21.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-21.txt Pages : 41 Date : 2016-12-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems (ASes) through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries digital signatures produced by each autonomous system that propagates the update message. The digital signatures provide confidence that every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-21 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-21 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-oz1WW8gJfH3YYLg0UmlcABPVmik","title":"","text":"Re: [sidr] Implementer inputs requested (Fw: SecDir Review of\n draft-ietf-sidr-bgpsec-protocol-20)\nSriram, regarding the implementer input, here are my thoughts: To comment 1: ============== It is not uncommon to have a length field not include its own size. An example is the length field of the capabilities which does specify the length (size) of the following capability (payload). In our case the length field specifies the length (size) of the signature itself (payload) and not the total length of all the signature fields (ski, length, signature) as do the other length fields. In addition, adding the 2 bytes for the field itself, will add more complexity to the processing regarding the crypto. Currently we can use the value “as is” without any additional math applying to it which will change once we include the 2 bytes for the field itself. So, I prefer to keep it as is. To comment 2: ============== I do not believe that by sending 2 separate capabilities we really “waste” anything. The reason is that compared to the overall BGP traffic, a handful of bytes exchanged during the session establishment doesn’t do any harm. But on a more serious note, introducing a 2-bit encoding adds additional complexity. The proposed encoding 01 – 10 – 11 (or 1, 2, 3) is fine except that it leaves out two additional stages. (A) the encoding 00 and (B) no capability sent at all. Looking at other capabilities, the “non-existence” of a capability states no support. Now by adding an unused 00, what does this mean? Does it mean we don’t support the capability which means we have two forms of signaling no support? And if it does not mean that, is it an error in which we need to add error handling. I think this adds unnecessary complexity that the implementer must check for 00 and the non-existence and deal with them the same way or differently? To keep it simple, I prefer to keep it as it is, this way we do not add additional confusion: (I) Announce the proper capability if supported (II) and if not supported don’t announce the capability. This is straight forward and falls in line with other capabilities. (As Example MPNLRI, 4 Byte ASN, etc.) Thanks, Oliver From: Kotikalapudi Sriram <kotikalapudi.sriram@nist.gov> Date: Thursday, December 22, 2016 at 12:41 PM To: sidr list <sidr@ietf.org> Cc: Russ Housley <housley@vigilsec.com>, \"baerm@tislabs.com\" <baerm@tislabs.com>, Oliver Borchert <oliver.borchert@nist.gov>, \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org> Subject: Implementer inputs requested (Fw: SecDir Review of draft-ietf-sidr-bgpsec-protocol-20) Russ Housley had suggested these changes (#1 and #2 below) as part of his SecDir review. But he also suggested to me to put it out on the mailing list so that implementers in particular and anyone having an opinion can have a say. Russ's comment: Minor: #1 In Section 3.2, the Signature Length within the Signature Segment does not count the length field itself. It seems that all of the other length values in this specification count the size of the length too. Consistency will avoid implementation errors. Russ's comment: Minor: #2 Section 2.1 says: ... The BGP speaker sets this bit to 0 to indicate the capability to receive BGPsec update messages. The BGP speaker sets this bit to 1 to indicate the capability to send BGPsec update messages. It seems a bit wasteful to repeat the whole capability for each direction. Wouldn't it be better to follow the example used in other capability definitions (such as RFC 7911) by using one of the unassigned bits? The Send\/Receive pair of bits would have these semantics: This field indicates whether the sender is (a) able to receive BGPsec update messages from its peer (value 1), (b) able to send BGPsec update messages to its peer (value 2), or (c) both (value 3) for the address family identified in the AFI. [Sriram] Observation: Two implementations exist and they were shown to interoperate at the IETF-97 in Seoul. The changes would cause those implementations to make code modifications. Sriram Sriram, regarding the implementer input, here are my thoughts: To comment 1: ============== It is not uncommon to have a length field not include its own size. An example is the length field of the capabilities which does specify the length (size) of the following capability (payload). In our case the length field specifies the length (size) of the signature itself (payload) and not the total length of all the signature fields (ski, length, signature) as do the other length fields. In addition, adding the 2 bytes for the field itself, will add more complexity to the processing regarding the crypto. Currently we can use the value “as is” without any additional math applying to it which will change once we include the 2 bytes for the field itself. So, I prefer to keep it as is. To comment 2: ============== I do not believe that by sending 2 separate capabilities we really “waste” anything. The reason is that compared to the overall BGP traffic, a handful of bytes exchanged during the session establishment doesn’t do any harm. But on a more serious note, introducing a 2-bit encoding adds additional complexity. The proposed encoding 01 – 10 – 11 (or 1, 2, 3) is fine except that it leaves out two additional stages. (A) the encoding 00 and (B) no capability sent at all. Looking at other capabilities, the “non-existence” of a capability states no support. Now by adding an unused 00, what does this mean? Does it mean we don’t support the capability which means we have two forms of signaling no support? And if it does not mean that, is it an error in which we need to add error handling. I think this adds unnecessary complexity that the implementer must check for 00 and the non-existence and deal with them the same way or differently? To keep it simple, I prefer to keep it as it is, this way we do not add additional confusion: (I) Announce the proper capability if supported (II) and if not supported don’t announce the capability. This is straight forward and falls in line with other capabilities. (As Example MPNLRI, 4 Byte ASN, etc.) Thanks, Oliver From: Kotikalapudi Sriram <kotikalapudi.sriram@nist.gov> Date: Thursday, December 22, 2016 at 12:41 PM To: sidr list <sidr@ietf.org> Cc: Russ Housley <housley@vigilsec.com>, \"baerm@tislabs.com\" <baerm@tislabs.com>, Oliver Borchert <oliver.borchert@nist.gov>, \"sidr-chairs@ietf.org\" <sidr-chairs@ietf.org> Subject: Implementer inputs requested (Fw: SecDir Review of draft-ietf-sidr-bgpsec-protocol-20) Russ Housley had suggested these changes (#1 and #2 below) as part of his SecDir review. But he also suggested to me to put it out on the mailing list so that implementers in particular and anyone having an opinion can have a say. Russ's comment: Minor: #1 In Section 3.2, the Signature Length within the Signature Segment does not count the length field itself. It seems that all of the other length values in this specification count the size of the length too. Consistency will avoid implementation errors. Russ's comment: Minor: #2 Section 2.1 says: ... The BGP speaker sets this bit to 0 to indicate the capability to receive BGPsec update messages. The BGP speaker sets this bit to 1 to indicate the capability to send BGPsec update messages. It seems a bit wasteful to repeat the whole capability for each direction. Wouldn't it be better to follow the example used in other capability definitions (such as RFC 7911) by using one of the unassigned bits? The Send\/Receive pair of bits would have these semantics: This field indicates whether the sender is (a) able to receive BGPsec update messages from its peer (value 1), (b) able to send BGPsec update messages to its peer (value 2), or (c) both (value 3) for the address family identified in the AFI. [Sriram] Observation: Two implementations exist and they were shown to interoperate at the IETF-97 in Seoul. The changes would cause those implementations to make code modifications. Sriram"}
{"_id":"doc-en-sidr-KYJvlFfdOOG6IUEGFFCC3V8jW5o","title":"","text":"[sidr] Implementer inputs requested (Fw: SecDir Review of\n draft-ietf-sidr-bgpsec-protocol-20)\nRuss Housley had suggested these changes (#1 and #2 below) as part of his SecDir review. But he also suggested to me to put it out on the mailing list so that implementers in particular and anyone having an opinion can have a say. Russ's comment: Minor: #1 In Section 3.2, the Signature Length within the Signature Segment does not count the length field itself. It seems that all of the other length values in this specification count the size of the length too. Consistency will avoid implementation errors. Russ's comment: Minor: #2 Section 2.1 says: ... The BGP speaker sets this bit to 0 to indicate the capability to receive BGPsec update messages. The BGP speaker sets this bit to 1 to indicate the capability to send BGPsec update messages. It seems a bit wasteful to repeat the whole capability for each direction. Wouldn't it be better to follow the example used in other capability definitions (such as RFC 7911) by using one of the unassigned bits? The Send\/Receive pair of bits would have these semantics: This field indicates whether the sender is (a) able to receive BGPsec update messages from its peer (value 1), (b) able to send BGPsec update messages to its peer (value 2), or (c) both (value 3) for the address family identified in the AFI. [Sriram] Observation: Two implementations exist and they were shown to interoperate at the IETF-97 in Seoul. The changes would cause those implementations to make code modifications. Sriram Russ Housley had suggested these changes (#1 and #2 below) as part of his SecDir review. But he also suggested to me to put it out on the mailing list so that implementers in particular and anyone having an opinion can have a say. Russ's comment: Minor: #1 In Section 3.2, the Signature Length within the Signature Segment does not count the length field itself. It seems that all of the other length values in this specification count the size of the length too. Consistency will avoid implementation errors. Russ's comment: Minor: #2 Section 2.1 says: ... The BGP speaker sets this bit to 0 to indicate the capability to receive BGPsec update messages. The BGP speaker sets this bit to 1 to indicate the capability to send BGPsec update messages. It seems a bit wasteful to repeat the whole capability for each direction. Wouldn't it be better to follow the example used in other capability definitions (such as RFC 7911) by using one of the unassigned bits? The Send\/Receive pair of bits would have these semantics: This field indicates whether the sender is (a) able to receive BGPsec update messages from its peer (value 1), (b) able to send BGPsec update messages to its peer (value 2), or (c) both (value 3) for the address family identified in the AFI. [Sriram] Observation: Two implementations exist and they were shown to interoperate at the IETF-97 in Seoul. The changes would cause those implementations to make code modifications. Sriram"}
{"_id":"doc-en-sidr-Tqm6vOhDkDrKPYaeElsaBDztvH4","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nIOW, AS65003 doesn’t necessarily always know that AS65001 is also AS2. It may not know the confederation ID at all, or it may even think that AS65001 is also some other AS. and this is within spec. we have no measure of how common this is, and it would be hard to measure due to the problem of vantage points. such is life with bgp. randy"}
{"_id":"doc-en-sidr-coNsGYJQlt7GdLjOYdKEwWqAVhU","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nOn 12\/21\/16, 12:47 PM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: Sriram: Hi! | I said in my previous post: | \"(2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary.\" | | I retract my observation… … | | So let us focus back on only your original concern. | If we need the solution of \"confed AS signing to itself with pCount = 0\", | it would be only to address your original concern of an apparent discontinuity. | I looked at the implications of the solution once again. | While it may be easy to describe it in terms of sender actions, | the solution would have ripple effects in several places in the document. | | So I wish to take another fresh look at your concern with your help, | and try to understand if there isn't another way to address it. | | The example scenario is: | AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) | | With the current specification, we have the following sequence of signed updates: | (Notation: (S-i-j) means signature from AS i to AS j, | P is the prefix; and most recent AS appears in the right most position) | | #1 AS1 to AS2\/AS65001: P [AS1 {(S-1-2)}] | | #2 AS2\/AS65001 to AS2\/AS65002: P [AS1, AS65001 {(S-1-2), (S-65001-65002)}], | | #3 AS2\/AS65002 to AS3: P [AS1, AS2, {(S-1-2), ( S-2-3)}] | (Secure_Path Segment and Signature within the confed are stripped) | | The discontinuity you are concerned about is in the middle (2nd) update above, i.e., | the first signature is from AS1 to AS2 while the second signature is from AS65001 to AS65002. | Am I right? Yes. | But then you have observed the following earlier: | | \"Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001…so I don’t see it as a proxy.\" | https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08107.html | | Given this observation, would you accept that there is no discontinuity in update #2 above | since AS65001 is AS2? | | If this is acceptable, then can we assert that the security guarantee is Section 8.1 | is good inside confederations as well with the understanding that each member AS | is also the public AS of the confed? For instance, AS65002 is cognizant that | AS65001 is also AS2. So AS65002 does not see a discontinuity. No, it is not ok to me. Even though in theory all the routers in a confederation know the confederation ID, in practice the only reason that it is needed is if an external (to the confederation) peering session exists in that member AS. In other words, it is possible to configure a router to be an “internal” member (i.e. not having any external-to-the-confederation peers) by only indicating the confederation peers and not the confederation ID. For example, extending the network above: AS1 -> AS2\/AS65001 -> AS65003 -> AS65004 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001, AS65002 AS65003, AS65004 are Members) In this network AS65003 (for example) only needs to know (i.e. be configured) that AS65001 and AS65004 as confederation peers, and not the specific knowledge of which is the confederation ID. In fact, if AS65003 was configured with the wrong confederation ID (AS4, for example), everything would still work with no issues, because the confederation ID wouldn’t be used in the existing peering sessions. IOW, AS65003 doesn’t necessarily always know that AS65001 is also AS2. It may not know the confederation ID at all, or it may even think that AS65001 is also some other AS. Yes, I have to admit that we could argue whether either case\/or both (of not knowing the proper confederation ID) is a misconfiguration…but the fact persists that there is no explicit indication that AS2 intended to send the Update to AS65001 (even if they are, or should be, the same box). This is where I think we’re again at a place where we’re probably agreeing to disagree – and where more input from the WG would be great. I am happy to be in the rough if the WG agrees with you. Thanks! Alvaro. Sriram: Hi! | I said in my previous post: | \"(2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary.\" | | I retract my observation… … | | So let us focus back on only your original concern. | If we need the solution of \"confed AS signing to itself with pCount = 0\", | it would be only to address your original concern of an apparent discontinuity. | I looked at the implications of the solution once again. | While it may be easy to describe it in terms of sender actions, | the solution would have ripple effects in several places in the document. | | So I wish to take another fresh look at your concern with your help, | and try to understand if there isn't another way to address it. | | The example scenario is: | AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) | | With the current specification, we have the following sequence of signed updates: | (Notation: (S-i-j) means signature from AS i to AS j, | P is the prefix; and most recent AS appears in the right most position) | | #1 AS1 to AS2\/AS65001: P [AS1 {(S-1-2)}] | | #2 AS2\/AS65001 to AS2\/AS65002: P [AS1, AS65001 {(S-1-2), (S-65001-65002)}], | | #3 AS2\/AS65002 to AS3: P [AS1, AS2, {(S-1-2), ( S-2-3)}] | (Secure_Path Segment and Signature within the confed are stripped) | | The discontinuity you are concerned about is in the middle (2nd) update above, i.e., | the first signature is from AS1 to AS2 while the second signature is from AS65001 to AS65002. | Am I right? Yes. | But then you have observed the following earlier: | | \"Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001…so I don’t see it as a proxy.\" | https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08107.html | | Given this observation, would you accept that there is no discontinuity in update #2 above | since AS65001 is AS2? | | If this is acceptable, then can we assert that the security guarantee is Section 8.1 | is good inside confederations as well with the understanding that each member AS | is also the public AS of the confed? For instance, AS65002 is cognizant that | AS65001 is also AS2. So AS65002 does not see a discontinuity. No, it is not ok to me. Even though in theory all the routers in a confederation know the confederation ID, in practice the only reason that it is needed is if an external (to the confederation) peering session exists in that member AS. In other words, it is possible to configure a router to be an “internal” member (i.e. not having any external-to-the-confederation peers) by only indicating the confederation peers and not the confederation ID. For example, extending the network above: AS1 -> AS2\/AS65001 -> AS65003 -> AS65004 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001, AS65002 AS65003, AS65004 are Members) In this network AS65003 (for example) only needs to know (i.e. be configured) that AS65001 and AS65004 as confederation peers, and not the specific knowledge of which is the confederation ID. In fact, if AS65003 was configured with the wrong confederation ID (AS4, for example), everything would still work with no issues, because the confederation ID wouldn’t be used in the existing peering sessions. IOW, AS65003 doesn’t necessarily always know that AS65001 is also AS2. It may not know the confederation ID at all, or it may even think that AS65001 is also some other AS. Yes, I have to admit that we could argue whether either case\/or both (of not knowing the proper confederation ID) is a misconfiguration…but the fact persists that there is no explicit indication that AS2 intended to send the Update to AS65001 (even if they are, or should be, the same box). This is where I think we’re again at a place where we’re probably agreeing to disagree – and where more input from the WG would be great. I am happy to be in the rough if the WG agrees with you. Thanks! Alvaro."}
{"_id":"doc-en-sidr-cGE8zf3Auqu0CtvbuYFsa22oa70","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nHi Alvaro, I said in my previous post: \"(2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary.\" I retract my observation that the document had a problem in that \"confed ASes fail to validate properly the signature injected at the boundary.\" The document does not have that problem. My apologies for not being careful earlier. Confed ASes do validate properly the signature injected at the boundary :) Because the document says the following in Section 4.3 (page 18): When validating a received BGPsec update message, confederation members need to make the following adjustment to the algorithm presented in Section 5.2<https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-20#section-5.2>. When a confederation member processes (validates) a Signature Segment and its corresponding Secure_Path Segment, the confederation member must note the following. For a signature produced by a peer BGPsec speaker outside of a confederation, the 'Target AS Number' will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number. So let us focus back on only your original concern. If we need the solution of \"confed AS signing to itself with pCount = 0\", it would be only to address your original concern of an apparent discontinuity. I looked at the implications of the solution once again. While it may be easy to describe it in terms of sender actions, the solution would have ripple effects in several places in the document. So I wish to take another fresh look at your concern with your help, and try to understand if there isn't another way to address it. The example scenario is: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) With the current specification, we have the following sequence of signed updates: (Notation: (S-i-j) means signature from AS i to AS j, P is the prefix; and most recent AS appears in the right most position) #1 AS1 to AS2\/AS65001: P [AS1 {(S-1-2)}] #2 AS2\/AS65001 to AS2\/AS65002: P [AS1, AS65001 {(S-1-2), (S-65001-65002)}], #3 AS2\/AS65002 to AS3: P [AS1, AS2, {(S-1-2), ( S-2-3)}] (Secure_Path Segment and Signature within the confed are stripped) The discontinuity you are concerned about is in the middle (2nd) update above, i.e., the first signature is from AS1 to AS2 while the second signature is from AS65001 to AS65002. Am I right? But then you have observed the following earlier: \"Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001...so I don't see it as a proxy.\" https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08107.html Given this observation, would you accept that there is no discontinuity in update #2 above since AS65001 is AS2? If this is acceptable, then can we assert that the security guarantee is Section 8.1 is good inside confederations as well with the understanding that each member AS is also the public AS of the confed? For instance, AS65002 is cognizant that AS65001 is also AS2. So AS65002 does not see a discontinuity. Thank you. Sriram Hi Alvaro, I said in my previous post: \"(2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary.\" I retract my observation that the document had a problem in that \"confed ASes fail to validate properly the signature injected at the boundary.\" The document does not have that problem. My apologies for not being careful earlier. Confed ASes do validate properly the signature injected at the boundary :) Because the document says the following in Section 4.3 (page 18): When validating a received BGPsec update message, confederation members need to make the following adjustment to the algorithm presented in Section 5.2. When a confederation member processes (validates) a Signature Segment and its corresponding Secure_Path Segment, the confederation member must note the following. For a signature produced by a peer BGPsec speaker outside of a confederation, the 'Target AS Number' will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number. So let us focus back on only your original concern. If we need the solution of \"confed AS signing to itself with pCount = 0\", it would be only to address your original concern of an apparent discontinuity. I looked at the implications of the solution once again. While it may be easy to describe it in terms of sender actions, the solution would have ripple effects in several places in the document. So I wish to take another fresh look at your concern with your help, and try to understand if there isn't another way to address it. The example scenario is: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) With the current specification, we have the following sequence of signed updates: (Notation: (S-i-j) means signature from AS i to AS j, P is the prefix; and most recent AS appears in the right most position) #1 AS1 to AS2\/AS65001: P [AS1 {(S-1-2)}] #2 AS2\/AS65001 to AS2\/AS65002: P [AS1, AS65001 {(S-1-2), (S-65001-65002)}], #3 AS2\/AS65002 to AS3: P [AS1, AS2, {(S-1-2), ( S-2-3)}] (Secure_Path Segment and Signature within the confed are stripped) The discontinuity you are concerned about is in the middle (2nd) update above, i.e., the first signature is from AS1 to AS2 while the second signature is from AS65001 to AS65002. Am I right? But then you have observed the following earlier: \"Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001…so I don’t see it as a proxy.\" https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08107.html Given this observation, would you accept that there is no discontinuity in update #2 above since AS65001 is AS2? If this is acceptable, then can we assert that the security guarantee is Section 8.1 is good inside confederations as well with the understanding that each member AS is also the public AS of the confed? For instance, AS65002 is cognizant that AS65001 is also AS2. So AS65002 does not see a discontinuity. Thank you. Sriram"}
{"_id":"doc-en-sidr-mR1ZlfniN0AnGFpfZf8WscmX6xk","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nHi! I am (obviously) fine with it. Thanks! Alvaro. Thumb-typed and autocorrected.. If we agree and others on the WG list express no objection or find no fault in this solution, I will be happy to go ahead and add this solution for the confederation case (it requires just a couple of sentences to be added the spec)."}
{"_id":"doc-en-sidr-3j6h7PT14WJGKK3cIqTttVmy3rU","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nThinking about it some more, I now find that your proposed solution of adding a signature with pCount = 0 at the border of the confederation works well and fully addresses these two concerns (the second concern is new). (1) Your proposed solution addresses the concern you brought up in an earlier message - https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08081.html (2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary. This is explained below. First let us take note of the following two instructions that are in the spec: (a) From page Section 4.3 (page 16): \"When a confederation member sends a BGPsec update message to a peer that is a member of the same confederation but is a different Member-AS, the confederation member puts its (private) Member-AS Number (as opposed to the public AS Confederation Identifier) in the AS Number field of the Secure_Path Segment that it adds to the BGPsec update message.\" (b) From Section 5.2 (page 25): (note: this one is part of the method of identifying the Target AS while assembling the data to be hashed for signature validation) \"For each other Signature Segment (N smaller than K), the 'Target AS Number' is AS(N+1), the AS number in the Secure_Path segment that corresponds to the Signature Segment added immediately after the one being processed.\" Now I will explain what I mean by (2) above using the same example that you presented earlier: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) In this example, by \"signature injected at the boundary\", we mean the signature of AS1 to AS2 (in the update received by AS65001). Let us think about the step where AS65002 is processing the update from AS65001 and validating the \"signature injected at the boundary\". Following step (a) above, AS65001 put in its own private AS number (i.e. AS65001) in the Secure_Path Segment that it added to the BGPsec update message forwarded to AS65002. Therefore, following step (b), AS65002 identifies AS65001 to be the 'Target AS Number' for the data to be hashed for validating the signature. However, this would falsely result in 'Invalid' outcome for the signature being validated by AS65002. Because AS1 actually signed to AS2 (the public AS number), and hence the 'Target AS Number' is actually AS2. Now the solution: Your suggested solution says that AS65001 should add a signature where it uses the private key of the public AS (i.e. AS2) to sign and forward the update to itself (AS65001) with pCount = 0. Correspondingly, AS65001 also puts in the public AS number (i.e. AS2) in the Secure_Path Segment that it adds to the BGPsec update message sent to itself. (Please correct me if I misunderstood.) This helps to fully address the problem identified above. (Note that AS65001 follows instruction (a) when it subsequently forwards the update to AS65002, and AS65002 follows instruction (b) while validating. The validation now works without the error identified above.) If we agree and others on the WG list express no objection or find no fault in this solution, I will be happy to go ahead and add this solution for the confederation case (it requires just a couple of sentences to be added the spec). Thank you. Sriram Thinking about it some more, I now find that your proposed solution of adding a signature with pCount = 0 at the border of the confederation works well and fully addresses these two concerns (the second concern is new). (1) Your proposed solution addresses the concern you brought up in an earlier message - https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg08081.html (2) It also keeps confed ASes from failing to validate properly the signature injected at the boundary. This is explained below. First let us take note of the following two instructions that are in the spec: (a) From page Section 4.3 (page 16): \"When a confederation member sends a BGPsec update message to a peer that is a member of the same confederation but is a different Member-AS, the confederation member puts its (private) Member-AS Number (as opposed to the public AS Confederation Identifier) in the AS Number field of the Secure_Path Segment that it adds to the BGPsec update message.\" (b) From Section 5.2 (page 25): (note: this one is part of the method of identifying the Target AS while assembling the data to be hashed for signature validation) \"For each other Signature Segment (N smaller than K), the 'Target AS Number' is AS(N+1), the AS number in the Secure_Path segment that corresponds to the Signature Segment added immediately after the one being processed.\" Now I will explain what I mean by (2) above using the same example that you presented earlier: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members) In this example, by \"signature injected at the boundary\", we mean the signature of AS1 to AS2 (in the update received by AS65001). Let us think about the step where AS65002 is processing the update from AS65001 and validating the \"signature injected at the boundary\". Following step (a) above, AS65001 put in its own private AS number (i.e. AS65001) in the Secure_Path Segment that it added to the BGPsec update message forwarded to AS65002. Therefore, following step (b), AS65002 identifies AS65001 to be the 'Target AS Number' for the data to be hashed for validating the signature. However, this would falsely result in 'Invalid' outcome for the signature being validated by AS65002. Because AS1 actually signed to AS2 (the public AS number), and hence the 'Target AS Number' is actually AS2. Now the solution: Your suggested solution says that AS65001 should add a signature where it uses the private key of the public AS (i.e. AS2) to sign and forward the update to itself (AS65001) with pCount = 0. Correspondingly, AS65001 also puts in the public AS number (i.e. AS2) in the Secure_Path Segment that it adds to the BGPsec update message sent to itself. (Please correct me if I misunderstood.) This helps to fully address the problem identified above. (Note that AS65001 follows instruction (a) when it subsequently forwards the update to AS65002, and AS65002 follows instruction (b) while validating. The validation now works without the error identified above.) If we agree and others on the WG list express no objection or find no fault in this solution, I will be happy to go ahead and add this solution for the confederation case (it requires just a couple of sentences to be added the spec). Thank you. Sriram"}
{"_id":"doc-en-sidr-4OQ9zuLWC0Q9lpIdGDru7l_7Ijg","title":"","text":"Re: [sidr] Last Call: <draft-ietf-sidr-bgpsec-ops-12.txt> (BGPsec\n Operational Considerations) to Best Current Practice\nHi all, This following paragraph looks somewhat awkward to me. TEXT: An edge site which does not provide transit and trusts its upstream(s) SHOULD only originate a signed prefix announcement and need not validate received announcements. COMMENT: If you are multihomed and receive full (or partial) tables, there is benefit in validating the received routes, if not: why not? One upstream might be poisoned while the other isn't? Mabye the text should be amended to make it clear that this might apply if the stub ASN only takes default-originates? Kind regards, Job The IESG has received a request from the Secure Inter-Domain Routing WG (sidr) to consider the following document: - 'BGPsec Operational Considerations' <draft-ietf-sidr-bgpsec-ops-12.txt> as Best Current Practice The IESG plans to make a decision in the next few weeks, and solicits final comments on this action. Please send substantive comments to the ietf@ietf.org mailing lists by 2016-12-21. Exceptionally, comments may be sent to iesg@ietf.org instead. In either case, please retain the beginning of the Subject line to allow automated sorting. Abstract Deployment of the BGPsec architecture and protocols has many operational considerations. This document attempts to collect and present the most critical and universal. It is expected to evolve as BGPsec is formalized and initially deployed. The file can be obtained via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ IESG discussion can be tracked via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ballot\/ No IPR declarations have been submitted directly on this I-D. The document contains these normative downward references. See RFC 3967 for additional information: rfc6811: BGP Prefix Origin Validation (Proposed Standard - IETF stream) draft-ietf-sidr-bgpsec-protocol: BGPsec Protocol Specification (None - IETF stream) rfc6493: The Resource Public Key Infrastructure (RPKI) Ghostbusters Record (Proposed Standard - IETF stream) Note that some of these references may already be listed in the acceptable Downref Registry."}
{"_id":"doc-en-sidr-WV6GLQmBIyCWJcuaglzANDG0g0Y","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nOn 12\/13\/16, 7:26 AM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: [Sriram-3] I understand now your main comment about confederation. I think there are two ways to address it (of course I hope other people chime in as well): Choice A: The pCount = 0 solution that you have suggested. But I feel that this is somewhat a cosmetic solution. In your example, it can be perhaps questioned whether the signature with pCount = 0 from AS2 to AS65001 does actually fit the security guarantee from Section 8.1 that you’ve cited. Because AS2 (the AS with the public ASN) did not produce that signature directly. Instead AS65001 played proxy for AS2 -- which is of course part of the original solution anyway. So we may consider choice B below. Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001…so I don’t see it as a proxy. Choice B: Include a caveat to the statement in Section 8.1. For instance, we modify it as follows: For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path (except for a minor caveat that applies in the case of BGPsec speakers in a confederation). The caveat applies because a BGPsec speaker in a confederation-member AS can be a proxy receiver and signer for the public AS (identified by the public AS number of the confederation). Therefore, a signature that > appears to correspond to an AS with the public AS number may actually be proxy produced by a member AS that has an internal AS number not matching the public AS number. The confederation-member ASes are cognizant of this and hence it poses no security concern within the confederation, and it is transparent to ASes outside the confederation (see Section 4.3). [Sriram-3] Do you feel Choice B makes sense? Personally, I don’t like Choice B because it reads: “we guarantee X, except in a scenario where the signatures are not what they seem”… It doesn’t give me a warm a fuzzy feeling, especially when we’re talking about a security-related document. This is where I would like the Chairs\/rest of the WG to pitch in. … [Sriram-3] Perhaps I should wait for some more IESG LC reviews to roll in before I include this set of changes and those from Russ (Gen-ART) and Nevil (OPS-DIR)? Please advise. The IETF LC ends tomorrow. Include the changes with anything you receive by tomorrow. Thanks! Alvaro. [Sriram-3] I understand now your main comment about confederation. I think there are two ways to address it (of course I hope other people chime in as well): Choice A: The pCount = 0 solution that you have suggested. But I feel that this is somewhat a cosmetic solution. In your example, it can be perhaps questioned whether the signature with pCount = 0 from AS2 to AS65001 does actually fit the security guarantee from Section 8.1 that you’ve cited. Because AS2 (the AS with the public ASN) did not produce that signature directly. Instead AS65001 played proxy for AS2 -- which is of course part of the original solution anyway. So we may consider choice B below. Well, the PE with both AS2 and AS65001 *is* both AS2 *and* AS65001…so I don’t see it as a proxy. Choice B: Include a caveat to the statement in Section 8.1. For instance, we modify it as follows: For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path (except for a minor caveat that applies in the case of BGPsec speakers in a confederation). The caveat applies because a BGPsec speaker in a confederation-member AS can be a proxy receiver and signer for the public AS (identified by the public AS number of the confederation). Therefore, a signature that > appears to correspond to an AS with the public AS number may actually be proxy produced by a member AS that has an internal AS number not matching the public AS number. The confederation-member ASes are cognizant of this and hence it poses no security concern within the confederation, and it is transparent to ASes outside the confederation (see Section 4.3). [Sriram-3] Do you feel Choice B makes sense? Personally, I don’t like Choice B because it reads: “we guarantee X, except in a scenario where the signatures are not what they seem”… It doesn’t give me a warm a fuzzy feeling, especially when we’re talking about a security-related document. This is where I would like the Chairs\/rest of the WG to pitch in. … [Sriram-3] Perhaps I should wait for some more IESG LC reviews to roll in before I include this set of changes and those from Russ (Gen-ART) and Nevil (OPS-DIR)? Please advise. The IETF LC ends tomorrow. Include the changes with anything you receive by tomorrow. Thanks! Alvaro."}
{"_id":"doc-en-sidr-PPf9MGE5acEzUJjwlVEwxoAhBg8","title":"","text":"Re: [sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\nHi! I think the only item left is the Confederations one…and we might be speaking past each other. Thanks, Alvaro. My comments are marked with [Sriram-3]. [Sriram-3] I understand now your main comment about confederation. I think there are two ways to address it (of course I hope other people chime in as well): Choice A: The pCount = 0 solution that you have suggested. But I feel that this is somewhat a cosmetic solution. In your example, it can be perhaps questioned whether the signature with pCount = 0 from AS2 to AS65001 does actually fit the security guarantee from Section 8.1 that you’ve cited. Because AS2 (the AS with the public ASN) did not produce that signature directly. Instead AS65001 played proxy for AS2 -- which is of course part of the original solution anyway. So we may consider choice B below. Choice B: Include a caveat to the statement in Section 8.1. For instance, we modify it as follows: For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path (except for a minor caveat that applies in the case of BGPsec speakers in a confederation). The caveat applies because a BGPsec speaker in a confederation-member AS can be a proxy receiver and signer for the public AS (identified by the public AS number of the confederation). Therefore, a signature that appears to correspond to an AS with the public AS number may actually be proxy produced by a member AS that has an internal AS number not matching the public AS number. The confederation-member ASes are cognizant of this and hence it poses no security concern within the confederation, and it is transparent to ASes outside the confederation (see Section 4.3). [Sriram-3] Do you feel Choice B makes sense? [Sriram-3] Please see inline below for the rest of my comments (all marked with [Sriram-3]). Yes, I agree that the collusion problem is one that (as you mentioned below) is out of the scope of BGPsec. You are right that pCount=0 (as proposed below) doesn’t solve the collusion problem – but it does address the following security guarantee that is currently not met in the Confederations case (from 8.1): o For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path. In the case of Confederations, it cannot be (currently) verified that all the ASNs in the path intentionally chose to send the update to the next ASN because there is a discontinuity at the border. For a topology like this: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members), it can be verified that AS1 intentionally sent the Update to AS2, but there is no explicit indication (even if symbolic: pCount=0) of the intention for AS65001 to “receive” the update, and then be able to send it to AS65002. I still think that this continuity issue should be addressed; it nothing more just because the intentionality is mentioned as a security guarantee of BGPsec. [Sriram-3] Please see solution choices and A and B above and the related discussion. Chairs: Please poll the WG or make a decision of whether there is consensus (or not) to not solve this continuity issue (maybe from prior discussions on the list). If the WG decides not to solve this issue (or if it was already discussed), I’m ok with being in the rough. Related to the above, is the support for private ASNs --- this topic also came up in the review of draft-ietf-sidr-bgpsec-ops, and the GenArt\/SecDir reviews. There are two related points: 1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. Given that the signing of Updates is mandated, I think that support of draft-ietf-sidr-slurm is necessary; IOW, I think that draft-ietf-sidr-slurm should be a Normative reference. [Sriram-3] OK, will include draft-ietf-sidr-slurm as a normative reference. 2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. [Sriram-3] Agree. I’ll factor in your inputs and those from Joel, Russ, and Randy to include a paragraph on this topic in the ops and mgmt. section. [Sriram-3] Perhaps I should wait for some more IESG LC reviews to roll in before I include this set of changes and those from Russ (Gen-ART) and Nevil (OPS-DIR)? Please advise. Thank you. Sriram Hi! I think the only item left is the Confederations one…and we might be speaking past each other. Thanks, Alvaro. My comments are marked with [Sriram-3]. [Sriram-3] I understand now your main comment about confederation. I think there are two ways to address it (of course I hope other people chime in as well): Choice A: The pCount = 0 solution that you have suggested. But I feel that this is somewhat a cosmetic solution. In your example, it can be perhaps questioned whether the signature with pCount = 0 from AS2 to AS65001 does actually fit the security guarantee from Section 8.1 that you’ve cited. Because AS2 (the AS with the public ASN) did not produce that signature directly. Instead AS65001 played proxy for AS2 -- which is of course part of the original solution anyway. So we may consider choice B below. Choice B: Include a caveat to the statement in Section 8.1. For instance, we modify it as follows: For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path (except for a minor caveat that applies in the case of BGPsec speakers in a confederation). The caveat applies because a BGPsec speaker in a confederation-member AS can be a proxy receiver and signer for the public AS (identified by the public AS number of the confederation). Therefore, a signature that appears to correspond to an AS with the public AS number may actually be proxy produced by a member AS that has an internal AS number not matching the public AS number. The confederation-member ASes are cognizant of this and hence it poses no security concern within the confederation, and it is transparent to ASes outside the confederation (see Section 4.3). [Sriram-3] Do you feel Choice B makes sense? [Sriram-3] Please see inline below for the rest of my comments (all marked with [Sriram-3]). Yes, I agree that the collusion problem is one that (as you mentioned below) is out of the scope of BGPsec. You are right that pCount=0 (as proposed below) doesn’t solve the collusion problem – but it does address the following security guarantee that is currently not met in the Confederations case (from 8.1): o For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path. In the case of Confederations, it cannot be (currently) verified that all the ASNs in the path intentionally chose to send the update to the next ASN because there is a discontinuity at the border. For a topology like this: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members), it can be verified that AS1 intentionally sent the Update to AS2, but there is no explicit indication (even if symbolic: pCount=0) of the intention for AS65001 to “receive” the update, and then be able to send it to AS65002. I still think that this continuity issue should be addressed; it nothing more just because the intentionality is mentioned as a security guarantee of BGPsec. [Sriram-3] Please see solution choices and A and B above and the related discussion. Chairs: Please poll the WG or make a decision of whether there is consensus (or not) to not solve this continuity issue (maybe from prior discussions on the list). If the WG decides not to solve this issue (or if it was already discussed), I’m ok with being in the rough. Related to the above, is the support for private ASNs --- this topic also came up in the review of draft-ietf-sidr-bgpsec-ops, and the GenArt\/SecDir reviews. There are two related points: 1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. Given that the signing of Updates is mandated, I think that support of draft-ietf-sidr-slurm is necessary; IOW, I think that draft-ietf-sidr-slurm should be a Normative reference. [Sriram-3] OK, will include draft-ietf-sidr-slurm as a normative reference. 2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. [Sriram-3] Agree. I’ll factor in your inputs and those from Joel, Russ, and Randy to include a paragraph on this topic in the ops and mgmt. section. [Sriram-3] Perhaps I should wait for some more IESG LC reviews to roll in before I include this set of changes and those from Russ (Gen-ART) and Nevil (OPS-DIR)? Please advise. Thank you. Sriram"}
{"_id":"doc-en-sidr-Wv9b3sO2Fc8j1_0Q3-HpjblHMWE","title":"","text":"[sidr] Confederations and Private ASNs (WAS: AD Review of\n draft-ietf-sidr-bgpsec-protocol-18)\n[Changed the Subject to specifically discuss Confederation support, and hopefully get some attention from the WG.] Sriram: Hi! I think the only item left is the Confederations one…and we might be speaking past each other. Yes, I agree that the collusion problem is one that (as you mentioned below) is out of the scope of BGPsec. You are right that pCount=0 (as proposed below) doesn’t solve the collusion problem – but it does address the following security guarantee that is currently not met in the Confederations case (from 8.1): o For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path. In the case of Confederations, it cannot be (currently) verified that all the ASNs in the path intentionally chose to send the update to the next ASN because there is a discontinuity at the border. For a topology like this: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members), it can be verified that AS1 intentionally sent the Update to AS2, but there is no explicit indication (even if symbolic: pCount=0) of the intention for AS65001 to “receive” the update, and then be able to send it to AS65002. I still think that this continuity issue should be addressed; it nothing more just because the intentionality is mentioned as a security guarantee of BGPsec. Chairs: Please poll the WG or make a decision of whether there is consensus (or not) to not solve this continuity issue (maybe from prior discussions on the list). If the WG decides not to solve this issue (or if it was already discussed), I’m ok with being in the rough. Related to the above, is the support for private ASNs --- this topic also came up in the review of draft-ietf-sidr-bgpsec-ops, and the GenArt\/SecDir reviews. There are two related points: 1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. Given that the signing of Updates is mandated, I think that support of draft-ietf-sidr-slurm is necessary; IOW, I think that draft-ietf-sidr-slurm should be a Normative reference. 2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. Thanks! Alvaro. On 12\/5\/16, 1:35 PM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov<mailto:kotikalapudi.sriram@nist.gov>> wrote: Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved.[*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG.… [Sriram-2] Please see discussion at the top of this email. I am afraid, the solution you propose will not work. The first AS in the Confederation can still tunnel the update to the second AS it is colluding with, and the second AS “forward signs from the Confederation AS (the public number) to the Member-AS with pCount=0”. So the problem you originally identified doesn’t go away. [Changed the Subject to specifically discuss Confederation support, and hopefully get some attention from the WG.] Sriram: Hi! I think the only item left is the Confederations one…and we might be speaking past each other. Yes, I agree that the collusion problem is one that (as you mentioned below) is out of the scope of BGPsec. You are right that pCount=0 (as proposed below) doesn’t solve the collusion problem – but it does address the following security guarantee that is currently not met in the Confederations case (from 8.1): o For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path. In the case of Confederations, it cannot be (currently) verified that all the ASNs in the path intentionally chose to send the update to the next ASN because there is a discontinuity at the border. For a topology like this: AS1 -> AS2\/AS65001 -> AS65002\/AS2 -> AS3 (AS2 is the Confederation ID and AS65001 and AS65002 are Members), it can be verified that AS1 intentionally sent the Update to AS2, but there is no explicit indication (even if symbolic: pCount=0) of the intention for AS65001 to “receive” the update, and then be able to send it to AS65002. I still think that this continuity issue should be addressed; it nothing more just because the intentionality is mentioned as a security guarantee of BGPsec. Chairs: Please poll the WG or make a decision of whether there is consensus (or not) to not solve this continuity issue (maybe from prior discussions on the list). If the WG decides not to solve this issue (or if it was already discussed), I’m ok with being in the rough. Related to the above, is the support for private ASNs --- this topic also came up in the review of draft-ietf-sidr-bgpsec-ops, and the GenArt\/SecDir reviews. There are two related points: 1. It is common to use private ASNs in Confederations, but the global RPKI can’t support that. draft-ietf-sidr-slurm seems to address the issue of local management of private resources in the RPKI. Given that the signing of Updates is mandated, I think that support of draft-ietf-sidr-slurm is necessary; IOW, I think that draft-ietf-sidr-slurm should be a Normative reference. 2. Private ASNs (as pointed out in the SecDir review) are commonly used for stubs. This document should include something (I’m thinking in the Ops Section) about the protocol considerations: there must be a ROA from the resource owner for the ISP to properly re-originate the Update, etc.. Thanks! Alvaro. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved.[*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG.… [Sriram-2] Please see discussion at the top of this email. I am afraid, the solution you propose will not work. The first AS in the Confederation can still tunnel the update to the second AS it is colluding with, and the second AS “forward signs from the Confederation AS (the public number) to the Member-AS with pCount=0”. So the problem you originally identified doesn’t go away."}
{"_id":"doc-en-sidr-NTfK74R-gGwA2XaF7VAzRhRkHqo","title":"","text":"[sidr] Last Call: <draft-ietf-sidr-bgpsec-ops-12.txt> (BGPsec\n Operational Considerations) to Best Current Practice\nThe IESG has received a request from the Secure Inter-Domain Routing WG (sidr) to consider the following document: - 'BGPsec Operational Considerations' <draft-ietf-sidr-bgpsec-ops-12.txt> as Best Current Practice The IESG plans to make a decision in the next few weeks, and solicits final comments on this action. Please send substantive comments to the ietf@ietf.org mailing lists by 2016-12-21. Exceptionally, comments may be sent to iesg@ietf.org instead. In either case, please retain the beginning of the Subject line to allow automated sorting. Abstract Deployment of the BGPsec architecture and protocols has many operational considerations. This document attempts to collect and present the most critical and universal. It is expected to evolve as BGPsec is formalized and initially deployed. The file can be obtained via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ IESG discussion can be tracked via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-ops\/ballot\/ No IPR declarations have been submitted directly on this I-D. The document contains these normative downward references. See RFC 3967 for additional information: rfc6811: BGP Prefix Origin Validation (Proposed Standard - IETF stream) draft-ietf-sidr-bgpsec-protocol: BGPsec Protocol Specification (None - IETF stream) rfc6493: The Resource Public Key Infrastructure (RPKI) Ghostbusters Record (Proposed Standard - IETF stream) Note that some of these references may already be listed in the acceptable Downref Registry."}
{"_id":"doc-en-sidr-33Rb3XxY3Q_LC_fEwp0qzcNjIJ4","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nAlvaro, Thanks for this set of further comments\/questions\/discussion. They are very insightful and helpful. I have uploaded version-20 which includes changes based on your latest comments. Regarding your security concern with the method used for confederations: The problem you described is a variant of the problem of collusion between non-peering ASes by tunneling. The WG had discussed this problem (although in slightly different context). See the thread at: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07260.html At the time, the WG agreed that it was beyond the scope of BGPsec to solve the problem of collusion between non-peering ASes using OOB communication. BGPsec is designed to protect messages sent within BGP (i.e. within the control plane) – not when the control plane in bypassed. So I have the added the following new wording in version-20 in the ops and mgmt. section: There is a possibility of passing a BGPsec update via tunneling between colluding ASes. For example, say, AS-X does not peer with AS-Y, but colludes with AS-Y, signs and sends a BGPsec update to AS-Y by tunneling. AS-Y can then further sign and propagate the BGPsec update to its peers. It is beyond the scope of the BGPsec protocol to detect this form of malicious behavior. BGPsec is designed to protect messages sent within BGP (i.e. within the control plane) - not when the control plane in bypassed. A variant of the collusion by tunneling mentioned above can happen in the context of AS confederations. When a BGPsec router (outside of a confederation) is forwarding an update to a member of the confederation, it signs the update to the public ASN of the confederation and not to the member's ASN (see Section 4.3). Said member can tunnel the signed update to another member as is (i.e. without adding a signature). The update can then be propagated using BGPsec to other confederation members or to BGPsec neighbors outside of the confederation. This kind of operation is possible, but no grave security or reachability compromise is feared due to the following reasons: (1) The confederation members belong to one organization and strong internal trust is expected; and (2) Recall that the signatures that are internal to the confederation must be removed prior to forwarding the update to an outside BGPsec router (see Section 4.3). Regarding processing of duplicate update question: I feel now that there is no real utility in discussing the details of optimization of validation processing for duplicate updates in the middle of protocol specification (as we did before in Section 5). We need not even get into defining duplicate updates, etc. I have moved the note about non-deterministic\/deterministic signature algorithms from Section 5 into the ops and mgmt. section (Section 7). The paragraph there now reads as follows: Many signature algorithms are non-deterministic. That is, many signature algorithms will produce different signatures each time they are run (even when they are signing the same data with the same key). Therefore, if a BGPsec router receives a BGPsec update from a peer and later receives a second BGPsec update message from the same peer for the same prefix with the same Secure_Path and SKIs, the second update will differ from the first update in the signature fields (for a non-deterministic signature algorithm). For a deterministic signature algorithm, the signature fields will also be identical between the two updates. On the basis of these observations, an implementation may incorporate optimizations in update validation processing. Your other comments\/suggestions were straight forward and I have incorporated them as well in version-20. Please see my responses to your individual comments marked with [Sriram-2] below. Sriram ----------------------------------------------------- Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. ------------------------------------ [Sriram-2] Please see my responses to your individual comments marked with [Sriram-2] below [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. [Sriram-2] Good rewording. Made the substitution. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED that an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. [Sriram-2] I agree. Now the document uses paragraph above that you’ve offered. The last sentence slightly modified to read “…if configured for only BGPsec use.” M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned\/ [Sriram-2] Done. Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [Sriram-2] OK. Made that change in the IANA considerations section. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration> procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action” [Sriram-2] Done. Made that change in the IANA considerations section. M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. [Sriram-2] Agree with that. Done as suggested. M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. ☹ [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. We do not even need to define duplicate here, nor talk about details of optimizations in the document. 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. We need not get into the details of validation optimizations in the document. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. The sentence you are referring to is no longer there; not needed. [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network.… [Sriram-2] Again, this is irrelevant now in light of the explanation provided at the top of this email and the changes made in the document. Nothing said in version-20 that contradicts what is done in plain BGP with duplicates. M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”?… [Sriram-2] I agree. MUST is appropriate here. Done the substitution. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved.[*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG.… [Sriram-2] Please see discussion at the top of this email. I am afraid, the solution you propose will not work. The first AS in the Confederation can still tunnel the update to the second AS it is colluding with, and the second AS “forward signs from the Confederation AS (the public number) to the Member-AS with pCount=0”. So the problem you originally identified doesn’t go away. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation.… [Sriram-2] The text has been deleted as suggested. New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. [Sriram-2] The following para added in the ops and mgmt. section: In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. N2. The references to RFC5226 and RFC6487 should be Normative. [Sriram-2] Done. Sriram Alvaro, Thanks for this set of further comments\/questions\/discussion. They are very insightful and helpful. I have uploaded version-20 which includes changes based on your latest comments. Regarding your security concern with the method used for confederations: The problem you described is a variant of the problem of collusion between non-peering ASes by tunneling. The WG had discussed this problem (although in slightly different context). See the thread at: https:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07260.html At the time, the WG agreed that it was beyond the scope of BGPsec to solve the problem of collusion between non-peering ASes using OOB communication. BGPsec is designed to protect messages sent within BGP (i.e. within the control plane) – not when the control plane in bypassed. So I have the added the following new wording in version-20 in the ops and mgmt. section: There is a possibility of passing a BGPsec update via tunneling between colluding ASes. For example, say, AS-X does not peer with AS-Y, but colludes with AS-Y, signs and sends a BGPsec update to AS-Y by tunneling. AS-Y can then further sign and propagate the BGPsec update to its peers. It is beyond the scope of the BGPsec protocol to detect this form of malicious behavior. BGPsec is designed to protect messages sent within BGP (i.e. within the control plane) - not when the control plane in bypassed. A variant of the collusion by tunneling mentioned above can happen in the context of AS confederations. When a BGPsec router (outside of a confederation) is forwarding an update to a member of the confederation, it signs the update to the public ASN of the confederation and not to the member's ASN (see Section 4.3). Said member can tunnel the signed update to another member as is (i.e. without adding a signature). The update can then be propagated using BGPsec to other confederation members or to BGPsec neighbors outside of the confederation. This kind of operation is possible, but no grave security or reachability compromise is feared due to the following reasons: (1) The confederation members belong to one organization and strong internal trust is expected; and (2) Recall that the signatures that are internal to the confederation must be removed prior to forwarding the update to an outside BGPsec router (see Section 4.3). Regarding processing of duplicate update question: I feel now that there is no real utility in discussing the details of optimization of validation processing for duplicate updates in the middle of protocol specification (as we did before in Section 5). We need not even get into defining duplicate updates, etc. I have moved the note about non-deterministic\/deterministic signature algorithms from Section 5 into the ops and mgmt. section (Section 7). The paragraph there now reads as follows: Many signature algorithms are non-deterministic. That is, many signature algorithms will produce different signatures each time they are run (even when they are signing the same data with the same key). Therefore, if a BGPsec router receives a BGPsec update from a peer and later receives a second BGPsec update message from the same peer for the same prefix with the same Secure_Path and SKIs, the second update will differ from the first update in the signature fields (for a non-deterministic signature algorithm). For a deterministic signature algorithm, the signature fields will also be identical between the two updates. On the basis of these observations, an implementation may incorporate optimizations in update validation processing. Your other comments\/suggestions were straight forward and I have incorporated them as well in version-20. Please see my responses to your individual comments marked with [Sriram-2] below. Sriram ----------------------------------------------------- Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. ------------------------------------ [Sriram-2] Please see my responses to your individual comments marked with [Sriram-2] below [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. [Sriram-2] Good rewording. Made the substitution. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED that an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. [Sriram-2] I agree. Now the document uses paragraph above that you’ve offered. The last sentence slightly modified to read “…if configured for only BGPsec use.” M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned\/ [Sriram-2] Done. Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [Sriram-2] OK. Made that change in the IANA considerations section. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration> procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action” [Sriram-2] Done. Made that change in the IANA considerations section. M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. [Sriram-2] Agree with that. Done as suggested. M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. ☹ [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. We do not even need to define duplicate here, nor talk about details of optimizations in the document. 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. We need not get into the details of validation optimizations in the document. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram-2] This is irrelevant now in light of the explanation provided at the top of this email. The sentence you are referring to is no longer there; not needed. [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network.… [Sriram-2] Again, this is irrelevant now in light of the explanation provided at the top of this email and the changes made in the document. Nothing said in version-20 that contradicts what is done in plain BGP with duplicates. M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”?… [Sriram-2] I agree. MUST is appropriate here. Done the substitution. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved.[*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG.… [Sriram-2] Please see discussion at the top of this email. I am afraid, the solution you propose will not work. The first AS in the Confederation can still tunnel the update to the second AS it is colluding with, and the second AS “forward signs from the Confederation AS (the public number) to the Member-AS with pCount=0”. So the problem you originally identified doesn’t go away. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation.… [Sriram-2] The text has been deleted as suggested. New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. [Sriram-2] The following para added in the ops and mgmt. section: In Section 2.2, is was stated that a BGPsec speaker SHOULD announce support for the capability to receive BGP extended messages. Lack of negotiation of this capability is not expected to pose a problem in the early years of BGPsec deployment. However, as BGPsec is deployed more and more, the BGPsec update messages would grow in size and some messages may be dropped due to their size exceeding the current 4K bytes limit. Therefore, it is strongly RECOMMENDED that all BGPsec speakers negotiate the extended message capability within a reasonable period of time after initial deployment of BGPsec. N2. The references to RFC5226 and RFC6487 should be Normative. [Sriram-2] Done. Sriram"}
{"_id":"doc-en-sidr-hbyBKe3-383K5OVG_FalqYjWWqY","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-20.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-20.txt Pages : 39 Date : 2016-12-05 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-20 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-20 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-Vgm6qjJgLlbxLk1--Jy4qpzpjiY","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-ops-10\ngreat review. thanks! 1. Why is this document a BCP? A BCP is a document that describes “the community's best current thinking…on what is believed to be the best way to perform some operations” [rfc2026]. This document meets that bar of the description, but there is clearly not a lot of practice behind the considerations – which I think is reflected in the lack of significant comments from the WG. I would prefer if this document as Informational, pending some actual experience. But I’ll settle for a good explanation (to be also included in the Shepherd’s write-up) of why BCP. because it is, as you quote, the community's best current thinking…on what is believed to be the best way to perform some operations as to significant comments from the wg, welcome to sidr; it's either a poolpah or silent assent. 2. This document, as a companion of draft-ietf-sidr-bgpsec-protocol, is the only place where Operational (or Management) Considerations are discussed. However, important items recommended in RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions), such as migration or fault management are not covered anywhere. Given the tone and current content of this document, I don’t think extending it is the way forward -- so, in my review of draft-ietf-sidr-bgpsec-protocol [1], I asked the authors to include an Operations and Management Section there and to consider using this document as the base. Merging this document into draft-ietf-sidr-bgpsec-protocol is an action that the WG\/authors\/Chairs\/Shepherds should consider. While that is my preferred solution, I will move forward with publication of this document if that is the consensus. sidr has been separating protocol from ops all the way down the line, e.g. in origin validation. heck, you have separated (protocol == sidr) from (ops == sidrops). M1. In Section 5, you wrote: “As they are not formally verifiable, an eBGP listener SHOULD NOT strongly trust unsigned security markings such as communities received across a trust boundary.” After reading this piece of text several times, I think I picked up on the subtle message: don’t trust unsigned *security markings* -- vs what I got from the first n-1 readings: don’t trust communities. I think that this paragraph would greatly benefit from more details or an example related to security markings. BGPsec does not sign over communities, so they are not formally trustable. Additionally, outsourcing verification is not prudent security practice. Therefore an eBGP listener SHOULD NOT strongly trust unsigned security signaling, such as communities, received across a trust boundary. M2. In Section 7. (Routing Policy): “As BGPsec will be rolled out over…a long time. Hence a normal operator's policy SHOULD NOT be overly strict, perhaps preferring Valid paths and giving very low preference, but still using, Not Valid paths.” This recommendation concerns me because “Not Valid” talks directly to the fact that the announcement is, well, not valid – vs just unable to be verified (because there’s no BGPsec_Path attribute, for example). The next sentence is a reflection of my concern: “Operators should be aware that accepting Not Valid announcements…will often be the equivalent of treating them as fully Valid.” I-D.sidr-bgpsec-protocol suggests the same thing (in 5.1, pointing to this document). I am left with the question: why validate at all if the BCP recommendation is to use all announcements no matter the state? I obviously realize that it is still early days – maybe it is too early for a BCP document if the “practice” is not there yet… this is the result of a primrose path and, as i am a naggumite, i am quite willing to be strict here. but how we got here was; paths are either valid or not; you do not know if it is not valid because of lack of current rpki data or an attck (much blood spilled here). once you have swollowed this reduced signaling koolaid, you could have a not valid path because you just don't have the data, a weaker state than failure. this left us wussing out on what to do with them in best path choice. how about s\/SHOULD NOT\/MIGHT NOT\/? or, as i am a naggumite, i am willing to say just drop the suckers, and blame it on you :) M3. Also in Section 7: “…signed paths that are Not Valid and yet propagated…SHOULD have their signatures kept intact…” Section 4.2. (Constructing the BGPsec_Path Attribute) of draft-ietf-sidr-bgpsec-protocol says: “a Signature_Block which is not deemed 'Valid'…such Signature_Blocks MUST NOT be removed.” The “SHOULD” in this document is at odds with the “MUST NOT” in the BGPSec spec; please s\/SHOULD\/MUST, or (even better) s\/SHOULD\/should. Because of possible RPKI version skew, an AS Path which does not validate at router R0 might validate at R1. Therefore, signed paths that are Not Valid and yet propagated (because they are chosen as best path) should have their signatures left intact and MUST be signed if sent to external BGPsec speakers. M4. Still in Section 7: “To prevent exposure of the internals of BGP Confederations [RFC5065], a BGPsec speaker which is a Member-AS of a Confederation MUST NOT sign updates sent to another Member-AS of the same Confederation.” This is another case where the BGPSec spec says something different: Section 4.3. (Processing Instructions for Confederation Members) presents a mandatory mechanism that includes signing, but not necessarily validating. BTW, if the updates are not signed, then the signed path would be broken, even if all the routers in the path support BGPSec, right? Is that the recommendation? it is common for a bgp confederation to include private ASs for which there can be no unique authorative router credentials in the rpki. hence i am suspicious of the protocol spec. M5. In Section 8: “…routers' clocks MUST be correct…” What does this mean? Correct with respect to what? Later (2 paragraphs) you do mention RFC5905, should that be the reference here? Maybe make the clock topic one paragraph to avoid confusion. As a router must evaluate certificates and ROAs which are time dependent, routers' clocks MUST be correct to a tolerance of approximately an hour. The common approach is for operators to deploy servers that provide time service, such as [RFC5905], to client routers. R1. The reference to BGPsec should be draft-ietf-sidr-bgpsec-protocol (and not I-D.ietf-sidr-bgpsec-overview). I think it is ok to reference I-D.ietf-sidr-bgpsec-overview in the Suggested Reading as an Informative reference. Similarly, rfc6480, rfc6481 and rfc6482 should be made Informative as well. ack R2. Section 7: “This implies that the route server creates signatures per client including its own AS in the BGPsec_Path and the target ASes, see 2.2.2 of [I-D.ietf-idr-ix-bgp-route-server].” I think this reference is not correct because I-D.ietf-idr-ix-bgp-route-server doesn’t say anything about BGPSec. That section does say the opposite: “the route server SHOULD NOT prepend its own AS number to the AS_PATH segment nor modify the AS_PATH segment in any other way”. Maybe point at 4.2 of draft-ietf-sidr-bgpsec-protocol instead. A route server is usually 'transparent', i.e. does not insert an AS into the path so as not to increase the AS hop count and thereby affect downstream path choices. But, with BGPsec, a client router R needs to be able to validate paths which are forward signed to R. But the sending router can not generate signatures to all the possible clients. Therefore a BGPsec-aware route server needs to validate the incoming BGPsec_Path, and to forward updates which can be validated by clients which must therefore know the route server's AS. This implies that the route server creates signatures per client including its own AS in the BGPsec_Path, forward signing to each client AS, see [I-D.ietf-sidr-bgpsec-protocol]. The route server uses pCount of zero to not increase the effective AS hop count, thereby retaining the intent of 'transparency'. R3. RFC6811 should be a Normative reference. ack Minor: m1. The IPv4 examples in Section 7 should use addressed from rfc6890. can't. need more than a \/24. we went through this in origin validation. m2. In Section 7: “Therefore, unless local policy ensures otherwise, a signed path learned via iBGP MAY be Not Valid.” That “MAY” is not normative in this context, but it is stating a fact: s\/MAY\/may. ack m3. Also in Section 7: “If it is known that a BGPsec neighbor is not a transparent route server, and the router provides a knob to disallow a received pCount (prepend count, zero for transparent route servers) of zero, that knob SHOULD be applied.” There are other cases when pCount 0 is ok, draft-ietf-sidr-as-migration for example. I know that “SHOULD” allows other cases, but maybe working in the router server as an example might be an improvement. If it is known that a BGPsec neighbor is not a transparent route server, or is otherwise validly using pCount=0 (e,g, see [I-D.ietf-sidr-as-migration]), and the router provides a knob to disallow a received pCount of zero, that knob SHOULD be applied. Routers should disallow pCount 0 by default. m4. Section 9. (Security Considerations): “The major security considerations for the BGPsec protocol are described in [I-D.ietf-sidr-bgpsec-protocol].” Are there other security considerations not mentioned there? uh, none come to mind with only one cuppa. Nits: n1. Introduction: “…origin validation…will occur over the next two to three years and that BGPsec will start to deploy well after that.” Recommendation: avoid specific timeframes, be a little vaguer (short\/medium\/long term). I noticed that the first version of draft-ymbk-bgpsec-ops also mentioned “two to five years” (in 2011!). well, we were using the ipv6 time service, clearly a mistake :) BGPsec, [I-D.ietf-sidr-bgpsec-protocol], is a new protocol with many operational considerations. It is expected to be deployed incrementally over a number of years. As core BGPsec-capable routers may require large memory and\/or modern CPUs, it is thought that origin validation based on the RPKI, [RFC6811], will occur over some years and that BGPsec will start to deploy after that. n2. s\/ client cone, i.e. an RR client or the transitive closure of their customers' customers' customers' etc.\/ client cone, i.e. an RR client or reachable transitively through one of them. In a fully BGPsec enabled AS, Route Reflectors MUST have BGPsec enabled if and only if there are eBGP speakers in their client cone, i.e. an RR client or the transitive closure of a client's customers' customers' customers' etc. n3. “As the vast majority (84%) of ASs are stubs, and they announce the majority of prefixes…” A reference would be nice. lost in time. removed. should rerun measurement, but not today. n4. “Because of possible RPKI version skew…” I guess you mean lack of sync… i don't think so. i take lack of sync meaning i can not reach a cache or publisher. version skew could occur when timers have not yet fired. but it's fuzzy. n5. Security Considerations. Please write something along the lines of: “This document describes operational considerations for the deployment of BGPsec. The security considerations for BGPsec are…” 9. Security Considerations This document describes operational considerations for the deployment of BGPsec. The security considerations for BGPsec are described in [I-D.ietf-sidr-bgpsec-protocol]. i do not plan to push the button until you and chairs say we're converged. randy"}
{"_id":"doc-en-sidr-CKiyQfrgc4oaYxECNAKfkHP0FNk","title":"","text":"[sidr] Last Call: <draft-ietf-sidr-bgpsec-protocol-19.txt> (BGPsec\n Protocol Specification) to Proposed Standard\nThe IESG has received a request from the Secure Inter-Domain Routing WG (sidr) to consider the following document: - 'BGPsec Protocol Specification' <draft-ietf-sidr-bgpsec-protocol-19.txt> as Proposed Standard The IESG plans to make a decision in the next few weeks, and solicits final comments on this action. Please send substantive comments to the ietf@ietf.org mailing lists by 2016-12-16. Exceptionally, comments may be sent to iesg@ietf.org instead. In either case, please retain the beginning of the Subject line to allow automated sorting. Abstract This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The file can be obtained via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ IESG discussion can be tracked via https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ballot\/ No IPR declarations have been submitted directly on this I-D."}
{"_id":"doc-en-sidr-VRN_vzw6EX7yQbmu_I7UKhtP_Wo","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nJust noticed one more thing: the reference to I-D.ietf-sidr-rtr-keying is no longer needed. Thanks! Alvaro. On 12\/1\/16, 9:10 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com<mailto:aretana@cisco.com>> wrote: On 11\/27\/16, 12:21 PM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: Sriram: Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. … [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED than an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. … M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action”. … M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. … M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. ☹ 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network. … M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”? … M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved. [*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG. … m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹ I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation. … New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. N2. The references to RFC5226 and RFC6487 should be Normative. Just noticed one more thing: the reference to I-D.ietf-sidr-rtr-keying is no longer needed. Thanks! Alvaro. On 12\/1\/16, 9:10 PM, \"Alvaro Retana (aretana)\" <aretana@cisco.com> wrote: Sriram: Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. … [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED than an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. … M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action”. … M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. … M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. L 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network. … M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”? … M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved. [*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG. … m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹ I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation. … New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. N2. The references to RFC5226 and RFC6487 should be Normative."}
{"_id":"doc-en-sidr-VZM-rhEQke18MPRtn-iMZ-tSHLk","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nOn 11\/27\/16, 12:21 PM, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: Sriram: Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. … [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED than an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. … M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action”. … M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. … M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. ☹ 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network. … M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”? … M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved. [*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG. … m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹ I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation. … New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. N2. The references to RFC5226 and RFC6487 should be Normative. Sriram: Hi! Thanks for addressing my comments. I have some remaining comments below. I flagged a couple of items that I think the Chairs should consult the WG on, but I’ll leave it up to them to decide that – note that I don’t think we need to WGLC the whole document again, just a couple of decisions. I also added a couple of new comments at the end. I think we are closer, but there are still a couple of items where we’re not agreeing: treatment of duplicates and confederations. We can continue the discussion – I would love to hear other opinions as well (from the WG). In the meantime, I will start the IETF Last Call and request a RTG-Dir review as well. Addressing what we seem to agree on (I proposed some changes below for clarity) in the next few days would definitely help the process. Thanks! Alvaro. … [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Thanks for adding this Section. I think the essence of what we talked about is there, but the text needs some editing. I’m putting some suggestions below – keep in mind that this document is a specification, so you can be prescriptive with what you want to happen. OLD> Detailed recommendations concerning operations and management issues with BGPsec are provided in [I-D.ietf-sidr-bgpsec-ops]. NEW> The Best Current Practice concerning operational deployment of BGPSec is provided in [I-D.ietf-sidr-bgpsec-ops]. OLD> This document specifies BGPsec Version 0 only. What should the action be if the Version is not 0 in the BGPsec capability advertisement from a peer? If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. However, a BGP session is still negotiated and hence the ability to exchange routes is still there. BGP (unsigned) messages are exchanged. So the chain of ASNs is not broken, i.e. they may not be contiguous BGPsec peers but are still contiguous BGP peers. Let us say that BGPsec capability was negotiated successfully between two peers, and subsequently it was reset. In the meantime, assume that the 4-byte ASN capability or the multi-protocol capability was lost between the two peers. So now the BGPsec session reset results in failure of BGPsec capability negotiation and only a BGP session is established. Would the network operator be notified that this downgrade from BGPsec to BGP has happened? What if the operator always wants a secure session only? Can they require that no BGP session be established if BGPsec capability negotiation fails? Operators are advised to speak with their vendors to set up knobs and alerts to have such operations and management features in their BGPsec capable routers. NEW> Section 2.2 describes the negotiation required to establish a BGPsec-capable peering session. Not only must the BGPsec capability be exchanged (and agreed on), but the BGP multiprotocol extension [RFC4760] for the same AFI and the four-byte AS capability [RFC6793] must also be exchanged. Failure to properly negotiate a BGPsec session, due to a missing capability, for example, may still result in the exchange of BGP (unsigned) updates. While the BGP chain of ASNs is not broken, the security can be reduced and a contiguous set of BGPsec peers may not exist anymore. It is RECOMMENDED than an implementation log the failure to properly negotiate a BGPsec session if the local BGP speaker is configured for it. Also, an implementation MUST have ability to prevent a BGP session from being established if configured for BGPsec use. … M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. s\/Reserved\/Unassigned Given that there are only 3 unassigned bits and that changing versions should be a big deal, I think that “IETF Review” is not a strong enough registration procedure. Suggestion: use Standards Action instead. [*] Chairs: we don’t need to WGLC the whole document, but it would be a good idea to run the registration procedures by the WG once we settle on them – this could even be done in parallel with the IETF Last Call. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. Same comment as above about “IETF Review” vs “Standards Action”. … M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. I didn’t explain myself correctly. Section 4.3. (Processing Instructions for Confederation Members) covers only the processing for confederations, so putting text in there about any errors is good, but doesn’t cover the general case (for processing any update). OTOH, Section 5.2. (Validation Algorithm) doesn’t actually talk about “any error” (as referenced now from 4.3) – it only talks about “these errors”, which correspond to the list of checks in the section. IOW, there is no global specification that any error must result in treat-as-withdraw. Solution: take the text out of 4.3 and update the text in 5.2; suggestion: OLD> If any of these checks fail, it is an error in the BGPsec_Path attribute. Any of these errors in the BGPsec_Path attribute are handled as per RFC 7606 [RFC7606]. BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. NEW> If any of these checks fail, it is an error in the BGPsec_Path attribute. BGPsec speakers MUST handle any syntactical or protocol errors in the BGPsec_Path attribute using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606]. … M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. I saw the text, and have 3 questions\/comments: 1. “…it only implies that some bit errors occurred in the signatures.” What does that mean? Are you implying that the sender got the signature wrong? Or maybe that there was some corruption in-transit? Both cases are *bad*, but the case where the sender could get the signature wrong is specially so because if it wasn’t a duplicate update, then it would result “Not Valid” and there seems to be no way to determine if in fact the validity failed or if it is the case of some bit errors. L 2. “Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate.” No! This is not how BGP works…see below. 3. “…if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done.” Why is this not a “MUST”? IOW, if the original update was “Not Valid” when would it be ok to not perform validation on a new update? [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. In plain BGP, if a duplicate update (as defined above where everything is identical) is received, then the original one is replaced by the new one – in this specific case (where everything is identical), it may look like the router keeps what it already has…but the general rule is to replace the old update with a new one for the same prefix. What you are proposing above (“In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate.”) is a significant change with respect to BGP that is not explicitly called out. I haven’t seen this behavior mentioned anywhere in the draft – it has only come up now. IMHO, not only should the implicit withdraw behavior not change, but by ignoring the second update you’re ignoring a potentially important change in the topology\/structure of the network. … M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. Now 4.2 reads: “For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker SHOULD add a new Signature Segment to the Signature_Block” Should that “SHOULD” be a “MUST”? … M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. Personally, I would have preferred if you actually solved the problem. One solution is to borrow from draft-ietf-sidr-as-migration and forward sign from the Confederation AS (the public number) to the Member-AS with pCount=0. Note that this operation would take place inside the border Confederation router, so there are no issues with pCount=0 and the full path continuity is preserved. [*] Chairs: I think that this part (whether it is solved or not) should also be bounced by the WG. … m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. Honestly, using “Not Valid” updates makes no sense to me. We’re building all this machinery, changing BGP, etc.. just to end up using updates that are not valid anyway. Why are we doing all this work then?!? ☹ I understand that, specially at the beginning, people may want to use “Not Valid” updates…but that is an operational consideration (as you said above). Please take the text out from this document that recommends using “Not Valid”…and let I-D.ietf-sidr-bgpsec-ops deal with that recommendation. … New comment: N1. Section 2.2. (Negotiating BGPsec Support) says that because “BGPsec update messages can be quite large, therefore any BGPsec speaker…SHOULD also announce support for the capability to receive BGP extended messages [I-D.ietf-idr-bgp-extended-messages].” What does this mean with respect to the session establishment requirements? This capability is not mandatory (SHOULD is used and not MUST), but as BGPsec is deployed more and more, the system may not work anymore unless it is exchanged. Why wasn’t “MUST” used? I’m guessing that part of the reason may be availability of the feature… I think that the potential of having a properly negotiated BGPsec session still not work (because the messages are too big) should at least be mentioned in the new Operations and Management Considerations Section. N2. The references to RFC5226 and RFC6487 should be Normative."}
{"_id":"doc-en-sidr-1xAcOl3xIMN6EA3Q82jhKZ1bPvE","title":"","text":"Re: [sidr] Current document status && directionz\nOn Thu, Dec 1, 2016 at 1:51 AM, Declan Ma <madi@zdns.cn> wrote: Chris, I would like to take this thread to request for comments on how to move on SLURM. During the Seoul meeting, Tim suggested moving it to SIDROPS since SIDR is being closed. Yet I had the impression that the AD hopes keeping the list\/structure going until current work items are done. Considering the only issue facing SLURM is the file format that Tim and Rudiger mentioned in the MIC, IMHO, if this WG won’t plan to move SLURM to SIDROPS, WGLC is desirable to bring about inputs and comments to conclude this work. if we're just haggling on format... then let's try to finish here? How about we give it until ~monday for comments here, then start WGLC if no comments\/movement? Di 在 2016年12月1日，02:33，Christopher Morrow <morrowc.lists@gmail.com> 写道： And again, restarting... post meeting and post travel refocusing :) On Wed, Oct 26, 2016 at 11:35 AM, Christopher Morrow < morrowc.lists@gmail.com> wrote: Restarting this thread, with some updates :) Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :) Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis I had thought I sent validation-reconsidered forward for processing, I'm doing that today: draft-ietf-sidr-rpki-validation-reconsidered Currently still active documents (6 documents): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rtr-keying draft-ietf-sidr-slurm (this reflects the changes since the last email, included below) I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation which leaves to be dealt with by Chicago 2 documents: draft-ietf-sidr-slurm I think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up. I still think this is good, I will be sending a request to the OPS-AD folk today to move: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation to sidr-ops... If there are corrections\/additions please send them along :) -chris -chris On Fri, Sep 2, 2016 at 4:56 PM, Chris Morrow <morrowc@ops-netman.net> wrote: Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr On Thu, Dec 1, 2016 at 1:51 AM, Declan Ma <madi@zdns.cn> wrote:Chris, I would like to take this thread to request for comments on how to move on SLURM. During the Seoul meeting, Tim suggested moving it to SIDROPS since SIDR is being closed. Yet I had the impression that the AD hopes keeping the list\/structure going until current work items are done. Considering the only issue facing SLURM is the file format that Tim and Rudiger mentioned in the MIC, IMHO, if this WG won’t plan to move SLURM to SIDROPS, WGLC is desirable to bring about inputs and comments to conclude this work. if we're just haggling on format... then let's try to finish here?How about we give it until ~monday for comments here, then start WGLC if no comments\/movement? Di 在 2016年12月1日，02:33，Christopher Morrow <morrowc.lists@gmail.com> 写道： And again, restarting... post meeting and post travel refocusing :) On Wed, Oct 26, 2016 at 11:35 AM, Christopher Morrow <morrowc.lists@gmail.com> wrote: Restarting this thread, with some updates :) Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :) Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis I had thought I sent validation-reconsidered forward for processing, I'm doing that today: draft-ietf-sidr-rpki-validation-reconsidered Currently still active documents (6 documents): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rtr-keying draft-ietf-sidr-slurm (this reflects the changes since the last email, included below) I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation which leaves to be dealt with by Chicago 2 documents: draft-ietf-sidr-slurm I think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up. I still think this is good, I will be sending a request to the OPS-AD folk today to move: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation to sidr-ops... If there are corrections\/additions please send them along :) -chris -chris Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-mtQQgr6rNoHugmmkd8-3AvH6o_c","title":"","text":"Re: [sidr] Current document status && directionz\nChris, I would like to take this thread to request for comments on how to move on SLURM. During the Seoul meeting, Tim suggested moving it to SIDROPS since SIDR is being closed. Yet I had the impression that the AD hopes keeping the list\/structure going until current work items are done. Considering the only issue facing SLURM is the file format that Tim and Rudiger mentioned in the MIC, IMHO, if this WG won’t plan to move SLURM to SIDROPS, WGLC is desirable to bring about inputs and comments to conclude this work. Di 在 2016年12月1日，02:33，Christopher Morrow <morrowc.lists@gmail.com> 写道： And again, restarting... post meeting and post travel refocusing :) On Wed, Oct 26, 2016 at 11:35 AM, Christopher Morrow <morrowc.lists@gmail.com> wrote: Restarting this thread, with some updates :) Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :) Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis I had thought I sent validation-reconsidered forward for processing, I'm doing that today: draft-ietf-sidr-rpki-validation-reconsidered Currently still active documents (6 documents): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rtr-keying draft-ietf-sidr-slurm (this reflects the changes since the last email, included below) I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation which leaves to be dealt with by Chicago 2 documents: draft-ietf-sidr-slurm I think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up. I still think this is good, I will be sending a request to the OPS-AD folk today to move: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation to sidr-ops... If there are corrections\/additions please send them along :) -chris -chris Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-vYCCs5A7fPifGp-ST1TWWnRyt3k","title":"","text":"Re: [sidr] Current document status && directionz\nAnd again, restarting... post meeting and post travel refocusing :) On Wed, Oct 26, 2016 at 11:35 AM, Christopher Morrow < morrowc.lists@gmail.com> wrote: Restarting this thread, with some updates :) Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :) Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis I had thought I sent validation-reconsidered forward for processing, I'm doing that today: draft-ietf-sidr-rpki-validation-reconsidered Currently still active documents (6 documents): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rtr-keying draft-ietf-sidr-slurm (this reflects the changes since the last email, included below) I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation which leaves to be dealt with by Chicago 2 documents: draft-ietf-sidr-slurm I think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up. I still think this is good, I will be sending a request to the OPS-AD folk today to move: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation to sidr-ops... If there are corrections\/additions please send them along :) -chris -chris On Fri, Sep 2, 2016 at 4:56 PM, Chris Morrow <morrowc@ops-netman.net> wrote: Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr And again, restarting... post meeting and post travel refocusing :)On Wed, Oct 26, 2016 at 11:35 AM, Christopher Morrow <morrowc.lists@gmail.com> wrote:Restarting this thread, with some updates :)Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :)Currently we have the following in IESG\/pub-request status (13 documents):draft-ietf-sidr-adverse-actionsdraft-ietf-sidr-as-migrationdraft-ietf-sidr-bgpsec-algsdraft-ietf-sidr-bgpsec-opsdraft-ietf-sidr-bgpsec-overviewdraft-ietf-sidr-bgpsec-pki-profilesdraft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-origin-validation-signalingdraft-ietf-sidr-publicationdraft-ietf-sidr-rpki-oob-setupdraft-ietf-sidr-rpki-rtr-rfc6810-bisI had thought I sent validation-reconsidered forward for processing, I'm doing that today:draft-ietf-sidr-rpki-validation-reconsidered Currently still active documents (6 documents): draft-ietf-sidr-bgpsec-rolloverdraft-ietf-sidr-lta-use-casesdraft-ietf-sidr-route-server-rpki-lightdraft-ietf-sidr-rpki-tree-validationdraft-ietf-sidr-rtr-keyingdraft-ietf-sidr-slurm(this reflects the changes since the last email, included below)I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validation which leaves to be dealt with by Chicago 2 documents:draft-ietf-sidr-slurmI think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up.I still think this is good, I will be sending a request to the OPS-AD folk today to move: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying draft-ietf-sidr-rpki-tree-validationto sidr-ops... If there are corrections\/additions please send them along :)-chris -chris Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-saYCWZAu_BTXCjnPSrQGx9GM1D4","title":"","text":"Re: [sidr] Fw: New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-19.txt\nAt Sun, 27 Nov 2016 14:53:17 +0000, \"Sriram, Kotikalapudi (Fed)\" <kotikalapudi.sriram@nist.gov> wrote: This new version of the BGPsec specification draft incorporates Alvaro's (Routing AD) comments. Another email follows that provides responses to the comments and clarifies how each of the comments were incorporated in the revision. Great, thanks! (for getting this done in short order, and after a long week away) -chris Sriram ________________________________________ From: internet-drafts@ietf.org <internet-drafts@ietf.org> Sent: Sunday, November 27, 2016 9:30 AM To: Matthew Lepinski; Sriram, Kotikalapudi (Fed) Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-19.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-19.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 19 Title: BGPsec Protocol Specification Document date: 2016-11-27 Group: sidr Pages: 40 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-19.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-19 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-19 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. The IETF Secretariat"}
{"_id":"doc-en-sidr-VcjM0D9j0EtJ3Rx-BlLPNgmr0bs","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nHi Alvaro, Thank you very much for this thorough and detailed set of comments. They greatly help improve the clarity, accuracy, and presentation in the document. I have worked with each of the comments and incorporated changes accordingly in the document. Please see version-19 that was just submitted. Many thanks to Sean Turner for his help with the updated IANA considerations section. My responses to your individual comments are shown below and are marked with [Sriram]. Let me know if the pdf opens OK for you. Also, please let me know if I missed anything. Regards, Sriram P.S. I tried to send this message with a pdf attachment earlier to the SIDR list. But looks like that post was not accepted by the IETF email exploder due to the attachment, may be? So I have copied and pasted here the text from the pdf. There may be line-wrap issue -- let us see. ----------- Dear authors: Hi! First of all, thank you for taking on the duties of editing this document. I have several comments (see below). For the most part, I think they should be easy to solve as many are related to clarifications. Most of the comments I classified as Major are due to the use of Normative language. The biggest concern I have with this document is the lack of an Operations and Management Considerations Section – please take a look at RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions). Some of the information suggested there is present in draft-ietf-sidr-bgpsec-ops, and (ironically) in the “Design and Deployment Considerations” section of draft-ietf-sidr-bgpsec-overview. However, important items such as migration or management are missing. I would like to see a well thought out Operations and Management Section in this document before moving it forward. Note that I’m not suggesting that a YANG model (for example) is required to move forward, but I would like to see considerations about migration, and the impact on network operations, to mention two items, all in one place in the document. I would like the authors\/Chairs\/Shepherd\/WG to consider even merging in draft-ietf-sidr-bgpsec-ops as the base for this new section (or at least reference it prominently). [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Additional responses noted here below under your specific comments. Thanks! Alvaro. Major: M1. Registry Definitions M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. M2. Error Handling — Several sections don't have proper error handling procedures specified. (This is a management issue that I think is underspecified.) [Sriram] Now there is management and operations section (Section 7) added where error handling and other ops\/mgmt. issues are discussed. M2.1. Section 2.2. (Negotiating BGPsec Support) doesn't fully specify the error handling behavior of the Capability, and it fails open. [Sriram] See my responses below for M2.1.1. The new management and operations section (Section 7) covers this case. M2.1.1. What should the action be if the Version is not 0? [Sriram]: From Section 2.2: “BGP update messages without the BGPsec_Path attribute MAY be sent within a session regardless of whether or not the use of BGPsec is successfully negotiated.” [Sriram] Based on the above, there is a possibility that BGPsec is not successfully negotiated but BGP is session is established – I think that is what you are calling fail open. If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. But a BGP session is still negotiated and BGP (unsigned) messages are exchanged. I have now included this wording in the new ops\/mgmt. Section 7. M2.1.2. \"…a BGP speaker MUST NOT advertise the capability of BGPsec support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI [RFC4760].\" What should happen if it does advertise an AFI that is not covered by the multiprotocol extension capability? Or if the multi-protocol capability is not advertised at all? To clarify: if the multi-protocol capability is not advertised then support for BGPsec can’t be advertised either – does that mean that a BGP speaker configured to use BGPsec must not use it if not negotiated? I know the answer is “yes”, but I’m trying to get to the point of provisioning and expectations – why configure BGPsec if no one is expected to support it? [Sriram]: See response to 2.1.1 above. Also, during early phase of deployment, small groups of (consisting of 2 or more) ASes are likely to coordinate and deploy BGPsec over contiguous regions (ASes). These regions will grow over time and conjoin. Also based on clarifications you provided in Seoul, I have also included error handling considerations for the case when BGPsec resets and some necessary condition (like 4-byte ASN or MP-NLRI capability) got dropped in the meantime. M2.1.3. Missing the four-byte AS capability results in BGPsec not working (\"BGPsec has not been successfully negotiated\"), but the ability of exchanging routes is still there, leaving the system in a fail open state and potentially breaking the chain of ASNs. Personally, it doesn't seem like a good result — please at least include some text about this in the Security Considerations section. [Sriram] Even though BGPsec is not successfully negotiated, the ability of exchanging routes is still there – BGP messages are exchanged though not BGPsec; it so the chain of ASNs in not really broken (they are not contiguous for BGPsec but still contiguous for BGP). This observation is included in the new Section 7 (ops\/mgmt. section). M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. M2.2.1. There are multiple places in the BGPsec_Path Attribute that could end up in an error, everything from setting bits in the Flags field to wrong Length fields. Should all errors result in the same behavior? [Sriram] Any errors that are syntactical errors or detected to be protocol violation errors in the BGPsec_Path attribute should result in the same behavior (see above comment). I think the updated Section 5.2 enumerates them reasonably well now. But bit errors that may result in change in the value of an ASN or a signature would not fall in that category. M3. Section 4.1. (General Guidance): \"When propagating a received route advertisement to an internal peer, the BGPsec speaker typically populates the BGPsec_Path attribute by copying the BGPsec_Path attribute from the received update message. That is, the BGPsec_Path attribute is copied verbatim…. Note that when a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec.\" The first part of the guidance says that a new BGPsec_Path attribute is created by copying the received attribute (which is then presumably removed), but the second part says that the received attribute SHOULD NOT be removed. Please clarify so that there is consistency -- I understand that the result is the same, but the description is not and we should try to avoid confusion. Parts of Section 4.2. (Constructing the BGPsec_Path Attribute) also talk about actions like \"…and there is an existing BGPsec_Path attribute, then the BGPsec speaker prepends its new Secure_Path Segment (places in first position) onto the existing Secure_Path\", which hint at propagating a received BGPsec_Path attribute (and not creating a new one). [Sriram] Yes, agree. We’ll remove redundant and confusing statements and simply state the stuff in the first set of quotes as follows (here we avoid using the word copying which causes some confusion): [Sriram] When a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec_Path attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec. In the case when an iBGP peer doesn't support BGPsec, then the BGPsec update is reconstructed to a BGP update with AS_PATH and then forwarded (see Section 4.4). In particular, when forwarding to a BGPsec capable iBGP peer, the BGPsec_Path attribute SHOULD NOT be removed even in the case where the BGPsec update message has not been successfully validated. M4. Section 4.2. (Constructing the BGPsec_Path Attribute) says that \"The AS number in this Secure_Path segment MUST match the AS number in the AS number resource extension field of the Resource PKI router certificate(s) that will be used to verify the digital signature(s) constructed by this BGPsec speaker [I-D.ietf-sidr-bgpsec-pki-profiles].\" However, there is no extension field or certificate in I-D.ietf-sidr-bgpsec-pki-profiles with that name. Please be precise with the names. [Sriram] Modified as follows: The AS number in this Secure_Path segment MUST match the AS number in the Subject field of the Resource PKI router certificate that will be used to verify the digital signature constructed by this BGPsec speaker (see Section 3.1.1.1 in [I-D.ietf-sidr-bgpsec-pki-profiles] and RFC 6487 [RFC6487]). M5. In 4.2: “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This text seems to assume some kind of configuration\/provisioning. Note that Section 5.2. (Validation Algorithm) also has similar text about receiving an UPDATE “from a peer that is not expected to set pCount equal to zero”. [Sriram] A peer that is an Internet Exchange Point (IXP) (i.e. Route Server) with a transparent AS is expected to set pCount = 0 in its Secure_Path segment while forwarding an update to a peer (see Section 4.2). Clearly, such an IXP SHOULD configure itself to set its own pCount = 0. As stated in Section 4.2, “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This means that a BGPsec speaker SHOULD be configured so that it permits pCount =0 from an IXP peer and never permits pCount = 0 from a peer that is not an IXP. Added the above paragraph in the new Section 7. M6. In 4.2: “If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker SHOULD include both of the Signature_Blocks.” Why is this “SHOULD” not a “MUST”? When\/why would a speaker remove one or the 2? If one is removed, should there be a requirement that the one that was used to successfully validate the update be kept? Note that Section 7.2 later talks about the problems of removing signatures… [Sriram] See below. M6.1. Note that later in this section the text says that “a 'Valid' BGPsec update message may contain a Signature_Block which is not deemed 'Valid' (e.g., contains signatures that BGPsec does not successfully verify). Nonetheless, such Signature_Blocks MUST NOT be removed.” Taking this “MUST NOT” along with the “SHOULD” above, the door is open to remove the Signature_Block used to verify the validity and just forward the one not used (which may itself not be valid). [Sriram] Your observations are right. Therefore, we made the following change (SHOULD --> MUST): If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker MUST include both of the Signature_Blocks. M6.2. Section 5.2. (Validation Algorithm) opens this door even more when saying that “If at least one Signature_Block is marked as 'Valid', then the validation algorithm terminates and the BGPsec update message is deemed to be 'Valid'.” The text here doesn’t require that both Signature_Blocks be verified, but implies that as long as the first one is valid then the second one doesn’t really need to be verified. Is that the intent? [Sriram] Yes. There is no problem with early termination since both algorithms are in use in parallel and either one can be used for verification. In fact, it helps with route processor performance to terminate early on a ‘Valid’ outcome after successfully verifying one of the Signature_Blocks. [Sriram] We have added a para in the new Section 7 on performance enhancement during BGPsec update validation. M7. Section 5. (Processing a Received BGPsec Update) talks about “duplicate update messages” (one where “it differs from the first update message only in the Signature fields (within the BGPsec_Path attribute)”). [Sriram] ECDSA P256 algorithm produces a different set of signature bits when it signs the same data again at a later time. M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. M8. Section 5.1. (Overview of BGPsec Validation) says that \"BGPsec specifies no changes to the BGP decision process.\" However, Section 5. (Processing a Received BGPsec Update) also says that \"a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute.\" I'm assuming that the Decision Process is included in \"all cases\". Even though 5.1 refers to the use the validation state in the decision process, please make sure that it is clear that the decision process is modified by the use of the different attribute. [Sriram] I agree that making use of validation state in BGPsec implies a change in the decision process. So we will remove the sentence that says \"BGPsec specifies no changes to the BGP decision process.\" M8.1. Please specifically include a section (or text somewhere) about how the information in the BGPsec_Path attribute is used in the Decision Process. For example, how should the \"number of AS numbers\" in the path be calculated for 9.1.2.2. (Breaking Ties (Phase 2)) in rfc4271? The text talks about the \"effective length\" being the sum of the pCount values, but the \"effective length\" (at least with that name) is not what is used in rfc4172 — please be clear and consistent. [Sriram] Done the following: s\/ effective length of the AS path\/ length of the AS path\/ [Sriram] Paragraph in Section 3.1 updated as follows: [Sriram] The pCount field contains the number of repetitions of the associated autonomous system number that the signature covers. This field enables a BGPsec speaker to mimic the semantics of prepending multiple copies of their AS to the AS_PATH without requiring the speaker to generate multiple signatures. Note that Section 9.1.2.2 (\"Breaking Ties\") in [RFC4271] mentions \"number of AS numbers\" in the AS_PATH attribute that is used in the route selection process. This metric (number of AS numbers) is the same as the AS path length obtained in BGPsec by summing the pCount values in the BGPsec_Path attribute. M8.2. [minor] Section 3. (The BGPsec_Path Attribute) reads: \"The information in Secure_Path is used by BGPsec speakers in the same way that information from the AS_PATH is used by non-BGPsec speakers.\" This is pretty much the same information that is in Section 5, but with more specificity. It would help if the more specific case was the one normatively called out. [Sriram] Made the change -- more specific language (Secure_Path as opposed to BGPsec_Path attribute) is now used in Section 5 also. M9. Section 5.2. (Validation Algorithm). RFC4271 also specifies a series of validity checks when an UPDATE is received (Section 6.3) – should that check be run before or after the algorithm specified here? The algorithm focuses on verifying the validity of the BGPsec_Path attribute (and not the whole UPDATE), so I’m assuming it should be executed instead of checking the AS_PATH. Please include some text about the interaction\/changes. [Sriram] Section 5.2 has been updated to reflect the above comment. M9.1. Section 5.2. (Validation Algorithm): “…then the BGPsec speaker MUST treat the update message in the same manner that the BGPsec speaker would treat an (unsigned) update message that arrived without a BGPsec_Path attribute.” What exactly does this mean? If the BGPsec_Path attribute is not received, then the AS_PATH should be – does the text imply that the AS_PATH should be reconstructed? I guess it should be if the update is to be propagated – but the question is while the update is being processed, which AS path information is used, the one in a reconstructed AS_PATH or the one in the BGPsec_Path while assuming that all the signatures are correct? [Sriram] Changed the wording. The corrected wording in Section 5.2 is as follows: [Sriram] Next, the BGPsec speaker examines the Signature_Blocks in the BGPsec_Path attribute. A Signature_Block corresponding to an algorithm suite that the BGPsec speaker does not support is not considered in validation. If there is no Signature_Block corresponding to an algorithm suite that the BGPsec speaker supports, then the BGPsec speaker MUST strip the Signature_Block(s), reconstruct the AS_PATH (see Section 4.4), from the Secure_Path, and treat the update as if it was received as an unsigned BGP update. M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. M11. The Figures (which are not numbered) in 4.2. (Constructing the BGPsec_Path Attribute) and 5.2. (Validation Algorithm) present the sequence of octets to be hashed. I’m guessing that the order of the Signature and Secure_Path Segments may be important, is it? The order in the Figures is not clear to me, if the order is important, please be clear about it; if not, please also say so. [Sriram] Yes, the order of the Signature and Secure_Path Segments is important. I have put in additional wording for clarifying\/rationale and emphasized that the order is important – in both sections. [Sriram] Figures are numbered now in the document. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. M13. What about replay attacks? There is no mention of the risk or potential mitigation anywhere. Please include in the Security Considerations section. [Sriram]: Added a new paragraph and reference to ietf-sidr-bgpsec-rollover in Section 8.4. Minor: m1. The use of SKI, Subject Key Identifier without a qualifier (field, extension) is confusing at times. Please expand SKI on first use. An example: (from 3.2) “The Subject Key Identifier contains the value in the Subject Key Identifier extension of the RPKI…” The first mention should include “field”, like similar text in 4.2. [Sriram]: Done. m2. Section 4. (BGPsec Update Messages) says: \"A BGPsec speaker that is not a member of such a confederation MUST set the Flags field of the Secure_Path Segment to zero in all BGPsec update messages it sends.\" While only one flag is defined, the correct statement is \"…set the Confed_Segment flag…\". [Sriram]: Done. m3. Section 4.1. (General Guidance): s\/\"A BGPsec update message MUST advertise a route to only a single NLRI.\"\/\"A BGPsec update message MUST advertise a route to only a single prefix.\" This section contains other places where the NLRI term is not used correctly. In short, the NLRI in a BGP Update contains one or more prefixes — so the text should talk about a single prefix, not a single NLRI. [Sriram] Replaced “NLRI” with “prefix” in all places in the document where appropriate. m4. In between the text above, the following is written: \"However, in the case that the BGPsec speaker is performing an AS Migration, the BGPsec speaker may add an additional signature on ingress before copying the BGPsec_Path attribute (see [I-D.ietf-sidr-as-migration] for more details).\" Because I-D.ietf-sidr-as-migration is marked as Updating this document, I suggest you remove this text (and the one in 4.2) -- note that the statements made in this document are not normative anyway and I-D.ietf-sidr-as-migration can stand on its own by clearly specifying what is needed for AS Migration. [Sriram] Yes, good suggestion – removed the text. Done. m5. In 4.2: “To prevent unnecessary processing load…a BGPsec speaker SHOULD NOT produce multiple consecutive Secure_Path Segments with the same AS number. This means that to achieve the semantics of prepending the same AS number k times, a BGPsec speaker SHOULD produce a single Secure_Path Segment – with pCount of k...” Given pCount, I’m wondering why these SHOULDs are not MUSTs, especially given the expected additional load. [Sriram] We had thought about it. Decided to leave it as SHOULD rather than MUST. Most implementations will do it right. We thought -- just make it a strong recommendation rather than enforce strictly. m6. Section 4.3. (Processing Instructions for Confederation Members) explains the process of adding Secure_Path and Signature segments that may or may not be used at all (given that the verification is optional), only to remove them later. Why isn’t the process of adding Secure_Path and Signature segments optional itself (instead of just the validation)? [Sriram] In a confederation, the update is crossing AS boundaries and ASNs of the members are included (cannot be omitted). It was felt that it is not a good idea to have mixed signed and unsigned segments. Also, the same security risks may exit (e.g. illegal path shortening) between confed ASes as do between regular ASes. m7. In 4.4. (Reconstructing the AS_PATH Attribute), what should happen if the Confed_Segment flag is set to zero and the most-recently added segment in the AS_PATH is of type AS_CONFED_SEQUENCE? Theoretically this can’t occur because it means that someone accepted an update that it shouldn’t have, but please include some text about this case being an error. [Sriram] This comment is related to m11. Added a new error check in Section 5.2 that reads, “If the update message was received from a BGPsec peer that is a member of the BGPsec speaker's AS confederation, check to ensure that the Secure_Path segment corresponding to that peer contains a Flags field with the Confed_Sequence flag set to one.” This takes care of m7 and m11. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. m9. Section 5.1 contains these references: “…the trusted cache could deliver the necessary validity information to the BGPsec speaker using the router key PDU [I-D.ietf-sidr-rtr-keying] for the RPKI-to-Router protocol [I-D.ietf-sidr-rpki-rtr-rfc6810-bis].” The reference to I-D.ietf-sidr-rtr-keying seems to be related to the “router key PDU”, but that is defined in I-D.ietf-sidr-rpki-rtr-rfc6810-bis, so it looks like the first reference is not needed. [Sriram] Yes. Fixed. m10. In 5.1: “As discussed in Section 4, when a BGPsec speaker chooses to forward…, it SHOULD be forwarded with its BGPsec_Path attribute…” That “SHOULD” is pointing at a fact, not acting normatively in this sentence so please change it to “should”. [Sriram] Yes. Fixed. m11. Section 5.2. (Validation Algorithm) mentions this check: ‘update..from a peer that is not a member of the BGPsec speaker's AS confederation, check to ensure that none of the Secure_Path segments contain a Flags field with the Confed_Sequence flag set to one.” I’m sure that the check for the flag set if the peer is a Confederation peer is also needed, but not mentioned in this section (where the normative MUST for the validation algorithm) is present. Section 4.3. (Processing Instructions for Confederation Members) does say this: “…when a confederation member runs the algorithm in Section 5.2, the confederation member, during processing of a Signature Segment, first checks whether the Confed_Sequence flag in the corresponding Secure_Path segment is set to one.” I would like to see the full algorithm specified in one place (even if, like in Section 4.3, pieces of it are explained elsewhere). Also, the text in 4.3 says that the check is performed “during processing of a Signature Segment”, which is fine, but probably late in the process (compared to the text in 5.2 that seems to require the check when the updates are received). [Sriram] Thanks for catching this. It is all fixed now. Wording changes have been made in Section 4.3 to say that the check is made during error checking rather than “during processing of a Signature Segment”. Also, in the error checking list in Section 5.2, we have added a new check that reads: “If the update message was received from a BGPsec peer that is a member of the BGPsec speaker's AS confederation, check to ensure that the Secure_Path segment corresponding to that peer contains a Flags field with the Confed_Sequence flag set to one.” m12. In Section 7.4. (Additional Security Considerations), please add a reference to point at “appropriate transport security mechanisms.”, and\/or point at the Security Considerations from rfc4271. [Sriram] Done. Nits: n1. In several places the text uses “we” (for example: “we expect…”). It’s just a matter of style, but using the third person may be more appropriate (for example: “it is expected…”). [Sriram] Done. Changes made per your suggestion. n2. The use of “Target AS Number” is inconsistent: sometimes the “number” is capitalized, others it isn’t, and sometimes it is not even mentioned. [Sriram] Now the document used ‘Target AS Number’ consistently. n3. I don’t think we need Section 6.2. (Extensibility Considerations). [Sriram] Leaving it as is for now. Can be removed later if there seems greater conviction about it during the IESG review process. Hi Alvaro, Thank you very much for this thorough and detailed set of comments. They greatly help improve the clarity, accuracy, and presentation in the document. I have worked with each of the comments and incorporated changes accordingly in the document. Please see version-19 that was just submitted. Many thanks to Sean Turner for his help with the updated IANA considerations section. My responses to your individual comments are shown below and are marked with [Sriram]. Let me know if the pdf opens OK for you. Also, please let me know if I missed anything. Regards, Sriram P.S. I tried to send this message with a pdf attachment earlier to the SIDR list. But looks like that post was not accepted by the IETF email exploder due to the attachment, may be? So I have copied and pasted here the text from the pdf. There may be line-wrap issue -- let us see. ----------- Dear authors: Hi! First of all, thank you for taking on the duties of editing this document. I have several comments (see below). For the most part, I think they should be easy to solve as many are related to clarifications. Most of the comments I classified as Major are due to the use of Normative language. The biggest concern I have with this document is the lack of an Operations and Management Considerations Section – please take a look at RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions). Some of the information suggested there is present in draft-ietf-sidr-bgpsec-ops, and (ironically) in the “Design and Deployment Considerations” section of draft-ietf-sidr-bgpsec-overview. However, important items such as migration or management are missing. I would like to see a well thought out Operations and Management Section in this document before moving it forward. Note that I’m not suggesting that a YANG model (for example) is required to move forward, but I would like to see considerations about migration, and the impact on network operations, to mention two items, all in one place in the document. I would like the authors\/Chairs\/Shepherd\/WG to consider even merging in draft-ietf-sidr-bgpsec-ops as the base for this new section (or at least reference it prominently). [Sriram] Following the clarifications and additional guidance you provided in Seoul (when you, Chris, and I met), I have added a new Section 7 (Operations and Management Considerations). The topics you mention above are all covered in the new Section 7. Additional responses noted here below under your specific comments. Thanks! Alvaro. Major: M1. Registry Definitions M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. [Sriram] Done. Please see the updated IANA Considerations section. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. [Sriram] It is the MSB (left most bit) and that is now clarified in Section 3.1. Set up of the registry for the Flags field is now included in the updated IANA Considerations section. M2. Error Handling — Several sections don't have proper error handling procedures specified. (This is a management issue that I think is underspecified.) [Sriram] Now there is management and operations section (Section 7) added where error handling and other ops\/mgmt. issues are discussed. M2.1. Section 2.2. (Negotiating BGPsec Support) doesn't fully specify the error handling behavior of the Capability, and it fails open. [Sriram] See my responses below for M2.1.1. The new management and operations section (Section 7) covers this case. M2.1.1. What should the action be if the Version is not 0? [Sriram]: From Section 2.2: “BGP update messages without the BGPsec_Path attribute MAY be sent within a session regardless of whether or not the use of BGPsec is successfully negotiated.” [Sriram] Based on the above, there is a possibility that BGPsec is not successfully negotiated but BGP is session is established – I think that is what you are calling fail open. If the intersection of BGPsec capability advertisements from both sides does not include Version 0, then BGPsec Version 0 has not been successfully negotiated. But a BGP session is still negotiated and BGP (unsigned) messages are exchanged. I have now included this wording in the new ops\/mgmt. Section 7. M2.1.2. \"…a BGP speaker MUST NOT advertise the capability of BGPsec support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI [RFC4760].\" What should happen if it does advertise an AFI that is not covered by the multiprotocol extension capability? Or if the multi-protocol capability is not advertised at all? To clarify: if the multi-protocol capability is not advertised then support for BGPsec can’t be advertised either – does that mean that a BGP speaker configured to use BGPsec must not use it if not negotiated? I know the answer is “yes”, but I’m trying to get to the point of provisioning and expectations – why configure BGPsec if no one is expected to support it? [Sriram]: See response to 2.1.1 above. Also, during early phase of deployment, small groups of (consisting of 2 or more) ASes are likely to coordinate and deploy BGPsec over contiguous regions (ASes). These regions will grow over time and conjoin. Also based on clarifications you provided in Seoul, I have also included error handling considerations for the case when BGPsec resets and some necessary condition (like 4-byte ASN or MP-NLRI capability) got dropped in the meantime. M2.1.3. Missing the four-byte AS capability results in BGPsec not working (\"BGPsec has not been successfully negotiated\"), but the ability of exchanging routes is still there, leaving the system in a fail open state and potentially breaking the chain of ASNs. Personally, it doesn't seem like a good result — please at least include some text about this in the Security Considerations section. [Sriram] Even though BGPsec is not successfully negotiated, the ability of exchanging routes is still there – BGP messages are exchanged though not BGPsec; it so the chain of ASNs in not really broken (they are not contiguous for BGPsec but still contiguous for BGP). This observation is included in the new Section 7 (ops\/mgmt. section). M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) [Sriram] s \/As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].\/ As discussed in Section 5.2, any syntactical or protocol violation errors in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\/ [Sriram] Section 4.3 has been updated accordingly. M2.2.1. There are multiple places in the BGPsec_Path Attribute that could end up in an error, everything from setting bits in the Flags field to wrong Length fields. Should all errors result in the same behavior? [Sriram] Any errors that are syntactical errors or detected to be protocol violation errors in the BGPsec_Path attribute should result in the same behavior (see above comment). I think the updated Section 5.2 enumerates them reasonably well now. But bit errors that may result in change in the value of an ASN or a signature would not fall in that category. M3. Section 4.1. (General Guidance): \"When propagating a received route advertisement to an internal peer, the BGPsec speaker typically populates the BGPsec_Path attribute by copying the BGPsec_Path attribute from the received update message. That is, the BGPsec_Path attribute is copied verbatim…. Note that when a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec.\" The first part of the guidance says that a new BGPsec_Path attribute is created by copying the received attribute (which is then presumably removed), but the second part says that the received attribute SHOULD NOT be removed. Please clarify so that there is consistency -- I understand that the result is the same, but the description is not and we should try to avoid confusion. Parts of Section 4.2. (Constructing the BGPsec_Path Attribute) also talk about actions like \"…and there is an existing BGPsec_Path attribute, then the BGPsec speaker prepends its new Secure_Path Segment (places in first position) onto the existing Secure_Path\", which hint at propagating a received BGPsec_Path attribute (and not creating a new one). [Sriram] Yes, agree. We’ll remove redundant and confusing statements and simply state the stuff in the first set of quotes as follows (here we avoid using the word copying which causes some confusion): [Sriram] When a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec_Path attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec. In the case when an iBGP peer doesn't support BGPsec, then the BGPsec update is reconstructed to a BGP update with AS_PATH and then forwarded (see Section 4.4). In particular, when forwarding to a BGPsec capable iBGP peer, the BGPsec_Path attribute SHOULD NOT be removed even in the case where the BGPsec update message has not been successfully validated. M4. Section 4.2. (Constructing the BGPsec_Path Attribute) says that \"The AS number in this Secure_Path segment MUST match the AS number in the AS number resource extension field of the Resource PKI router certificate(s) that will be used to verify the digital signature(s) constructed by this BGPsec speaker [I-D.ietf-sidr-bgpsec-pki-profiles].\" However, there is no extension field or certificate in I-D.ietf-sidr-bgpsec-pki-profiles with that name. Please be precise with the names. [Sriram] Modified as follows: The AS number in this Secure_Path segment MUST match the AS number in the Subject field of the Resource PKI router certificate that will be used to verify the digital signature constructed by this BGPsec speaker (see Section 3.1.1.1 in [I-D.ietf-sidr-bgpsec-pki-profiles] and RFC 6487 [RFC6487]). M5. In 4.2: “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This text seems to assume some kind of configuration\/provisioning. Note that Section 5.2. (Validation Algorithm) also has similar text about receiving an UPDATE “from a peer that is not expected to set pCount equal to zero”. [Sriram] A peer that is an Internet Exchange Point (IXP) (i.e. Route Server) with a transparent AS is expected to set pCount = 0 in its Secure_Path segment while forwarding an update to a peer (see Section 4.2). Clearly, such an IXP SHOULD configure itself to set its own pCount = 0. As stated in Section 4.2, “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This means that a BGPsec speaker SHOULD be configured so that it permits pCount =0 from an IXP peer and never permits pCount = 0 from a peer that is not an IXP. Added the above paragraph in the new Section 7. M6. In 4.2: “If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker SHOULD include both of the Signature_Blocks.” Why is this “SHOULD” not a “MUST”? When\/why would a speaker remove one or the 2? If one is removed, should there be a requirement that the one that was used to successfully validate the update be kept? Note that Section 7.2 later talks about the problems of removing signatures… [Sriram] See below. M6.1. Note that later in this section the text says that “a 'Valid' BGPsec update message may contain a Signature_Block which is not deemed 'Valid' (e.g., contains signatures that BGPsec does not successfully verify). Nonetheless, such Signature_Blocks MUST NOT be removed.” Taking this “MUST NOT” along with the “SHOULD” above, the door is open to remove the Signature_Block used to verify the validity and just forward the one not used (which may itself not be valid). [Sriram] Your observations are right. Therefore, we made the following change (SHOULD --> MUST): If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker MUST include both of the Signature_Blocks. M6.2. Section 5.2. (Validation Algorithm) opens this door even more when saying that “If at least one Signature_Block is marked as 'Valid', then the validation algorithm terminates and the BGPsec update message is deemed to be 'Valid'.” The text here doesn’t require that both Signature_Blocks be verified, but implies that as long as the first one is valid then the second one doesn’t really need to be verified. Is that the intent? [Sriram] Yes. There is no problem with early termination since both algorithms are in use in parallel and either one can be used for verification. In fact, it helps with route processor performance to terminate early on a ‘Valid’ outcome after successfully verifying one of the Signature_Blocks. [Sriram] We have added a para in the new Section 7 on performance enhancement during BGPsec update validation. M7. Section 5. (Processing a Received BGPsec Update) talks about “duplicate update messages” (one where “it differs from the first update message only in the Signature fields (within the BGPsec_Path attribute)”). [Sriram] ECDSA P256 algorithm produces a different set of signature bits when it signs the same data again at a later time. M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? [Sriram] Definition of duplicate update for BGPsec: A BGPsec update is a duplicate if it is identical to another update in the Adj-RIB-in, including SKIs and Algorithm ID, but not including the signatures. If the first update message (having the *same SKIs* as the duplicate) is *Valid*, then the duplicate’s validity state need not be computed. If validity of the duplicate were computed and found 'Valid', then it gives the router no new information. Alternatively, if it were found 'Not Valid', then it only implies that some bit errors occurred in the signatures. Therefore, the BGPsec speaker should keep the 'Valid' original update and ignore the duplicate. However, if the original update were 'Not Valid', then performing validation of the duplicate is relevant and SHOULD be done. [Sriram] Added a paragraph in the new Section 7 (Operations and Management Considerations) to include the above observations. [Sriram] Note that the above applies to both non-deterministic and deterministic signature algorithms. M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the router currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? [Sriram] In RFC 4271, when there is a duplicate update, the NRLI and path and all other attributes are identical. There is no implicit withdraw. The router keeps what it already has. In the case of BGPsec, a router keeps the original if it was valid, and ignores the duplicate. It checks the validity of the duplicate only if the original were invalid. M8. Section 5.1. (Overview of BGPsec Validation) says that \"BGPsec specifies no changes to the BGP decision process.\" However, Section 5. (Processing a Received BGPsec Update) also says that \"a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute.\" I'm assuming that the Decision Process is included in \"all cases\". Even though 5.1 refers to the use the validation state in the decision process, please make sure that it is clear that the decision process is modified by the use of the different attribute. [Sriram] I agree that making use of validation state in BGPsec implies a change in the decision process. So we will remove the sentence that says \"BGPsec specifies no changes to the BGP decision process.\" M8.1. Please specifically include a section (or text somewhere) about how the information in the BGPsec_Path attribute is used in the Decision Process. For example, how should the \"number of AS numbers\" in the path be calculated for 9.1.2.2. (Breaking Ties (Phase 2)) in rfc4271? The text talks about the \"effective length\" being the sum of the pCount values, but the \"effective length\" (at least with that name) is not what is used in rfc4172 — please be clear and consistent. [Sriram] Done the following: s\/ effective length of the AS path\/ length of the AS path\/ [Sriram] Paragraph in Section 3.1 updated as follows: [Sriram] The pCount field contains the number of repetitions of the associated autonomous system number that the signature covers. This field enables a BGPsec speaker to mimic the semantics of prepending multiple copies of their AS to the AS_PATH without requiring the speaker to generate multiple signatures. Note that Section 9.1.2.2 (\"Breaking Ties\") in [RFC4271] mentions \"number of AS numbers\" in the AS_PATH attribute that is used in the route selection process. This metric (number of AS numbers) is the same as the AS path length obtained in BGPsec by summing the pCount values in the BGPsec_Path attribute. M8.2. [minor] Section 3. (The BGPsec_Path Attribute) reads: \"The information in Secure_Path is used by BGPsec speakers in the same way that information from the AS_PATH is used by non-BGPsec speakers.\" This is pretty much the same information that is in Section 5, but with more specificity. It would help if the more specific case was the one normatively called out. [Sriram] Made the change -- more specific language (Secure_Path as opposed to BGPsec_Path attribute) is now used in Section 5 also. M9. Section 5.2. (Validation Algorithm). RFC4271 also specifies a series of validity checks when an UPDATE is received (Section 6.3) – should that check be run before or after the algorithm specified here? The algorithm focuses on verifying the validity of the BGPsec_Path attribute (and not the whole UPDATE), so I’m assuming it should be executed instead of checking the AS_PATH. Please include some text about the interaction\/changes. [Sriram] Section 5.2 has been updated to reflect the above comment. M9.1. Section 5.2. (Validation Algorithm): “…then the BGPsec speaker MUST treat the update message in the same manner that the BGPsec speaker would treat an (unsigned) update message that arrived without a BGPsec_Path attribute.” What exactly does this mean? If the BGPsec_Path attribute is not received, then the AS_PATH should be – does the text imply that the AS_PATH should be reconstructed? I guess it should be if the update is to be propagated – but the question is while the update is being processed, which AS path information is used, the one in a reconstructed AS_PATH or the one in the BGPsec_Path while assuming that all the signatures are correct? [Sriram] Changed the wording. The corrected wording in Section 5.2 is as follows: [Sriram] Next, the BGPsec speaker examines the Signature_Blocks in the BGPsec_Path attribute. A Signature_Block corresponding to an algorithm suite that the BGPsec speaker does not support is not considered in validation. If there is no Signature_Block corresponding to an algorithm suite that the BGPsec speaker supports, then the BGPsec speaker MUST strip the Signature_Block(s), reconstruct the AS_PATH (see Section 4.4), from the Secure_Path, and treat the update as if it was received as an unsigned BGP update. M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. [Sriram] Yes, agree. Fixed the wording per your suggestion in both places (Sections 4.2 and 7.2). Added reference to Section 4.2 in Section 7.2. M11. The Figures (which are not numbered) in 4.2. (Constructing the BGPsec_Path Attribute) and 5.2. (Validation Algorithm) present the sequence of octets to be hashed. I’m guessing that the order of the Signature and Secure_Path Segments may be important, is it? The order in the Figures is not clear to me, if the order is important, please be clear about it; if not, please also say so. [Sriram] Yes, the order of the Signature and Secure_Path Segments is important. I have put in additional wording for clarifying\/rationale and emphasized that the order is important – in both sections. [Sriram] Figures are numbered now in the document. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. [Sriram] See the new second paragraph in Section 7.4. The security consideration that you mention here about with the way confederations are handled is described and discussed there. M13. What about replay attacks? There is no mention of the risk or potential mitigation anywhere. Please include in the Security Considerations section. [Sriram]: Added a new paragraph and reference to ietf-sidr-bgpsec-rollover in Section 8.4. Minor: m1. The use of SKI, Subject Key Identifier without a qualifier (field, extension) is confusing at times. Please expand SKI on first use. An example: (from 3.2) “The Subject Key Identifier contains the value in the Subject Key Identifier extension of the RPKI…” The first mention should include “field”, like similar text in 4.2. [Sriram]: Done. m2. Section 4. (BGPsec Update Messages) says: \"A BGPsec speaker that is not a member of such a confederation MUST set the Flags field of the Secure_Path Segment to zero in all BGPsec update messages it sends.\" While only one flag is defined, the correct statement is \"…set the Confed_Segment flag…\". [Sriram]: Done. m3. Section 4.1. (General Guidance): s\/\"A BGPsec update message MUST advertise a route to only a single NLRI.\"\/\"A BGPsec update message MUST advertise a route to only a single prefix.\" This section contains other places where the NLRI term is not used correctly. In short, the NLRI in a BGP Update contains one or more prefixes — so the text should talk about a single prefix, not a single NLRI. [Sriram] Replaced “NLRI” with “prefix” in all places in the document where appropriate. m4. In between the text above, the following is written: \"However, in the case that the BGPsec speaker is performing an AS Migration, the BGPsec speaker may add an additional signature on ingress before copying the BGPsec_Path attribute (see [I-D.ietf-sidr-as-migration] for more details).\" Because I-D.ietf-sidr-as-migration is marked as Updating this document, I suggest you remove this text (and the one in 4.2) -- note that the statements made in this document are not normative anyway and I-D.ietf-sidr-as-migration can stand on its own by clearly specifying what is needed for AS Migration. [Sriram] Yes, good suggestion – removed the text. Done. m5. In 4.2: “To prevent unnecessary processing load…a BGPsec speaker SHOULD NOT produce multiple consecutive Secure_Path Segments with the same AS number. This means that to achieve the semantics of prepending the same AS number k times, a BGPsec speaker SHOULD produce a single Secure_Path Segment – with pCount of k...” Given pCount, I’m wondering why these SHOULDs are not MUSTs, especially given the expected additional load. [Sriram] We had thought about it. Decided to leave it as SHOULD rather than MUST. Most implementations will do it right. We thought -- just make it a strong recommendation rather than enforce strictly. m6. Section 4.3. (Processing Instructions for Confederation Members) explains the process of adding Secure_Path and Signature segments that may or may not be used at all (given that the verification is optional), only to remove them later. Why isn’t the process of adding Secure_Path and Signature segments optional itself (instead of just the validation)? [Sriram] In a confederation, the update is crossing AS boundaries and ASNs of the members are included (cannot be omitted). It was felt that it is not a good idea to have mixed signed and unsigned segments. Also, the same security risks may exit (e.g. illegal path shortening) between confed ASes as do between regular ASes. m7. In 4.4. (Reconstructing the AS_PATH Attribute), what should happen if the Confed_Segment flag is set to zero and the most-recently added segment in the AS_PATH is of type AS_CONFED_SEQUENCE? Theoretically this can’t occur because it means that someone accepted an update that it shouldn’t have, but please include some text about this case being an error. [Sriram] This comment is related to m11. Added a new error check in Section 5.2 that reads, “If the update message was received from a BGPsec peer that is a member of the BGPsec speaker's AS confederation, check to ensure that the Secure_Path segment corresponding to that peer contains a Flags field with the Confed_Sequence flag set to one.” This takes care of m7 and m11. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? [Sriram] If only a ‘Not Valid’ update is available for a prefix, then the update is used since otherwise the prefix would be unreachable. Both BGPsec and RPKI\/origin validation are expected to depref invalid updates rather than ignore them. This is driven by operator policy and can vary. Hence, we are deliberately not using any normative language here. m9. Section 5.1 contains these references: “…the trusted cache could deliver the necessary validity information to the BGPsec speaker using the router key PDU [I-D.ietf-sidr-rtr-keying] for the RPKI-to-Router protocol [I-D.ietf-sidr-rpki-rtr-rfc6810-bis].” The reference to I-D.ietf-sidr-rtr-keying seems to be related to the “router key PDU”, but that is defined in I-D.ietf-sidr-rpki-rtr-rfc6810-bis, so it looks like the first reference is not needed. [Sriram] Yes. Fixed. m10. In 5.1: “As discussed in Section 4, when a BGPsec speaker chooses to forward…, it SHOULD be forwarded with its BGPsec_Path attribute…” That “SHOULD” is pointing at a fact, not acting normatively in this sentence so please change it to “should”. [Sriram] Yes. Fixed. m11. Section 5.2. (Validation Algorithm) mentions this check: ‘update..from a peer that is not a member of the BGPsec speaker's AS confederation, check to ensure that none of the Secure_Path segments contain a Flags field with the Confed_Sequence flag set to one.” I’m sure that the check for the flag set if the peer is a Confederation peer is also needed, but not mentioned in this section (where the normative MUST for the validation algorithm) is present. Section 4.3. (Processing Instructions for Confederation Members) does say this: “…when a confederation member runs the algorithm in Section 5.2, the confederation member, during processing of a Signature Segment, first checks whether the Confed_Sequence flag in the corresponding Secure_Path segment is set to one.” I would like to see the full algorithm specified in one place (even if, like in Section 4.3, pieces of it are explained elsewhere). Also, the text in 4.3 says that the check is performed “during processing of a Signature Segment”, which is fine, but probably late in the process (compared to the text in 5.2 that seems to require the check when the updates are received). [Sriram] Thanks for catching this. It is all fixed now. Wording changes have been made in Section 4.3 to say that the check is made during error checking rather than “during processing of a Signature Segment”. Also, in the error checking list in Section 5.2, we have added a new check that reads: “If the update message was received from a BGPsec peer that is a member of the BGPsec speaker's AS confederation, check to ensure that the Secure_Path segment corresponding to that peer contains a Flags field with the Confed_Sequence flag set to one.” m12. In Section 7.4. (Additional Security Considerations), please add a reference to point at “appropriate transport security mechanisms.”, and\/or point at the Security Considerations from rfc4271. [Sriram] Done. Nits: n1. In several places the text uses “we” (for example: “we expect…”). It’s just a matter of style, but using the third person may be more appropriate (for example: “it is expected…”). [Sriram] Done. Changes made per your suggestion. n2. The use of “Target AS Number” is inconsistent: sometimes the “number” is capitalized, others it isn’t, and sometimes it is not even mentioned. [Sriram] Now the document used ‘Target AS Number’ consistently. n3. I don’t think we need Section 6.2. (Extensibility Considerations). [Sriram] Leaving it as is for now. Can be removed later if there seems greater conviction about it during the IESG review process."}
{"_id":"doc-en-sidr-1bKbIWx-2gqMqlW95ZtibzT5I4s","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nHi Alvaro, Thank you very much for this thorough and detailed set of comments. They greatly help improve the clarity, accuracy, and presentation in the document. I have worked with each of the comments and incorporated changes accordingly in the document. Please see version-19 that was just submitted. Many thanks to Sean Turner for his help with the updated IANA considerations section. My responses to your individual comments are included in the attached pdf and are marked with [Sriram] and in blue. Let me know if the pdf opens OK for you. Also, please let me know if I missed anything. Regards, Sriram"}
{"_id":"doc-en-sidr-sGuis3yRSVn5p1tvGTs4t975x80","title":"","text":"[sidr] Fw: New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-19.txt\nThis new version of the BGPsec specification draft incorporates Alvaro's (Routing AD) comments. Another email follows that provides responses to the comments and clarifies how each of the comments were incorporated in the revision. Sriram ________________________________________ From: internet-drafts@ietf.org <internet-drafts@ietf.org> Sent: Sunday, November 27, 2016 9:30 AM To: Matthew Lepinski; Sriram, Kotikalapudi (Fed) Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-19.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-19.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 19 Title: BGPsec Protocol Specification Document date: 2016-11-27 Group: sidr Pages: 40 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-19.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-19 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-19 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. The IETF Secretariat"}
{"_id":"doc-en-sidr-sdFfPUReOlSuwcxXuI3gD8sJxOI","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-19.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-19.txt Pages : 40 Date : 2016-11-27 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-19 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-19 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-hBAC-PAHNAsJHcNXj56lTZkVu-0","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-ops-10\ni think the plan is to shift the -ops document (this one) to the sidrops group...I meant to ask about: \"how do we do that?\" I'll do that in person tonight. At Wed, 2 Nov 2016 15:35:18 +0000, \"Alvaro Retana (aretana)\" <aretana@cisco.com> wrote: Randy: Hi! Thanks for working on this document! I have two issues I want to highlight upfront, and then some comments (below). I would like to see these two issues addressed, along with the Major comments below, before moving the document forward. These two upfront issues are probably more questions for the Chairs\/Shepherd. 1. Why is this document a BCP? A BCP is a document that describes “the community's best current thinking…on what is believed to be the best way to perform some operations” [rfc2026]. This document meets that bar of the description, but there is clearly not a lot of practice behind the considerations – which I think is reflected in the lack of significant comments from the WG. I would prefer if this document as Informational, pending some actual experience. But I’ll settle for a good explanation (to be also included in the Shepherd’s write-up) of why BCP. i think the intent of this document is to write down (document) the inteded 'best practices' for running bgpsec enabled networks. viewed in that light, there aren't any of these things out there today, but as a place to start looking and planning for deployment operations folk (me) want some guidance on what thingsto expect\/do\/fix as we roll out. i think bcp fits for that... much like bcp 17. I have updated the shepherds doc to reflect the above paragraph's intent\/ideas. 2. This document, as a companion of draft-ietf-sidr-bgpsec-protocol, is the only place where Operational (or Management) Considerations are discussed. However, important items recommended in RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions), such as migration or fault management are not covered anywhere. Given the tone and current Ideally the migration is covered in the protocol document, I see it only talk about as migrations (business events), which seems ok. Migrations of keys or algorithms are covered in other documents and mentioned in this document. which migrations are you referring to? content of this document, I don’t think extending it is the way forward -- so, in my review of draft-ietf-sidr-bgpsec-protocol [1], I asked the authors to include an Operations and Management Section there and to consider using this document as the base. Merging I'm not sure I'd stick more into the protocol document though, especially things which don't explicitly describe the protocol itself. I think keeping the protocol description\/design in one document and the operations of the system in a seperate document isn't unreasonable. I expect the set of ops documents to change\/evolve over time, I'd hate to -bis the protocol for operational work later. this document into draft-ietf-sidr-bgpsec-protocol is an action that the WG\/authors\/Chairs\/Shepherds should consider. While that is my preferred solution, I will move forward with publication of this document if that is the consensus. Thanks! Alvaro. [1] https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/UOSfI4drrFvnO7271ivU3j9RFm4 Major: M1. In Section 5, you wrote: “As they are not formally verifiable, an eBGP listener SHOULD NOT strongly trust unsigned security markings such as communities received across a trust boundary.” After reading this piece of text several times, I think I picked up on the subtle message: don’t trust unsigned *security markings* -- vs what I got from the first n-1 readings: don’t trust communities. I think that this paragraph would greatly benefit from more details or an example related to security markings. M2. In Section 7. (Routing Policy): “As BGPsec will be rolled out over…a long time. Hence a normal operator's policy SHOULD NOT be overly strict, perhaps preferring Valid paths and giving very low preference, but still using, Not Valid paths.” This recommendation concerns me because “Not Valid” talks directly to the fact that the announcement is, well, not valid – vs just unable to be verified (because there’s no BGPsec_Path attribute, for example). The next sentence is a reflection of my concern: “Operators should be aware that accepting Not Valid announcements…will often be the equivalent of treating them as fully Valid.” I-D.sidr-bgpsec-protocol suggests the same thing (in 5.1, pointing to this document). I am left with the question: why validate at all if the BCP recommendation is to use all announcements no matter the state? I obviously realize that it is still early days – maybe it is too early for a BCP document if the “practice” is not there yet… M3. Also in Section 7: “…signed paths that are Not Valid and yet propagated…SHOULD have their signatures kept intact…” Section 4.2. (Constructing the BGPsec_Path Attribute) of draft-ietf-sidr-bgpsec-protocol says: “a Signature_Block which is not deemed 'Valid'…such Signature_Blocks MUST NOT be removed.” The “SHOULD” in this document is at odds with the “MUST NOT” in the BGPSec spec; please s\/SHOULD\/MUST, or (even better) s\/SHOULD\/should. M4. Still in Section 7: “To prevent exposure of the internals of BGP Confederations [RFC5065], a BGPsec speaker which is a Member-AS of a Confederation MUST NOT sign updates sent to another Member-AS of the same Confederation.” This is another case where the BGPSec spec says something different: Section 4.3. (Processing Instructions for Confederation Members) presents a mandatory mechanism that includes signing, but not necessarily validating. BTW, if the updates are not signed, then the signed path would be broken, even if all the routers in the path support BGPSec, right? Is that the recommendation? M5. In Section 8: “…routers' clocks MUST be correct…” What does this mean? Correct with respect to what? Later (2 paragraphs) you do mention RFC5905, should that be the reference here? Maybe make the clock topic one paragraph to avoid confusion. References: R1. The reference to BGPsec should be draft-ietf-sidr-bgpsec-protocol (and not I-D.ietf-sidr-bgpsec-overview). I think it is ok to reference I-D.ietf-sidr-bgpsec-overview in the Suggested Reading as an Informative reference. Similarly, rfc6480, rfc6481 and rfc6482 should be made Informative as well. R2. Section 7: “This implies that the route server creates signatures per client including its own AS in the BGPsec_Path and the target ASes, see 2.2.2 of [I-D.ietf-idr-ix-bgp-route-server].” I think this reference is not correct because I-D.ietf-idr-ix-bgp-route-server doesn’t say anything about BGPSec. That section does say the opposite: “the route server SHOULD NOT prepend its own AS number to the AS_PATH segment nor modify the AS_PATH segment in any other way”. Maybe point at 4.2 of draft-ietf-sidr-bgpsec-protocol instead. R3. RFC6811 should be a Normative reference. Minor: m1. The IPv4 examples in Section 7 should use addressed from rfc6890. m2. In Section 7: “Therefore, unless local policy ensures otherwise, a signed path learned via iBGP MAY be Not Valid.” That “MAY” is not normative in this context, but it is stating a fact: s\/MAY\/may. m3. Also in Section 7: “If it is known that a BGPsec neighbor is not a transparent route server, and the router provides a knob to disallow a received pCount (prepend count, zero for transparent route servers) of zero, that knob SHOULD be applied.” There are other cases when pCount 0 is ok, draft-ietf-sidr-as-migration for example. I know that “SHOULD” allows other cases, but maybe working in the router server as an example might be an improvement. m4. Section 9. (Security Considerations): “The major security considerations for the BGPsec protocol are described in [I-D.ietf-sidr-bgpsec-protocol].” Are there other security considerations not mentioned there? Nits: n1. Introduction: “…origin validation…will occur over the next two to three years and that BGPsec will start to deploy well after that.” Recommendation: avoid specific timeframes, be a little vaguer (short\/medium\/long term). I noticed that the first version of draft-ymbk-bgpsec-ops also mentioned “two to five years” (in 2011!). n2. s\/ client cone, i.e. an RR client or the transitive closure of their customers' customers' customers' etc.\/ client cone, i.e. an RR client or reachable transitively through one of them. n3. “As the vast majority (84%) of ASs are stubs, and they announce the majority of prefixes…” A reference would be nice. n4. “Because of possible RPKI version skew…” I guess you mean lack of sync… n5. Security Considerations. Please write something along the lines of: “This document describes operational considerations for the deployment of BGPsec. The security considerations for BGPsec are…”"}
{"_id":"doc-en-sidr-MYeCA8tgYthEJCXrRjghQVeKS74","title":"","text":"Re: [sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nHi Alvaro, Thank you for the review and the excellent set of comments. We (editors\/authors) will consider all you comments and respond \/ make changes in the document soon. The biggest concern I have with this document is the lack of an Operations and Management Considerations Section – It would be nice if we can discuss this suggestion in particular in Seoul next week. Sriram"}
{"_id":"doc-en-sidr-OEIzTnCiPeomrkPpI2asbFZcB8Y","title":"","text":"[sidr] AD Review of draft-ietf-sidr-bgpsec-ops-10\nRandy: Hi! Thanks for working on this document! I have two issues I want to highlight upfront, and then some comments (below). I would like to see these two issues addressed, along with the Major comments below, before moving the document forward. These two upfront issues are probably more questions for the Chairs\/Shepherd. 1. Why is this document a BCP? A BCP is a document that describes “the community's best current thinking…on what is believed to be the best way to perform some operations” [rfc2026]. This document meets that bar of the description, but there is clearly not a lot of practice behind the considerations – which I think is reflected in the lack of significant comments from the WG. I would prefer if this document as Informational, pending some actual experience. But I’ll settle for a good explanation (to be also included in the Shepherd’s write-up) of why BCP. 2. This document, as a companion of draft-ietf-sidr-bgpsec-protocol, is the only place where Operational (or Management) Considerations are discussed. However, important items recommended in RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions), such as migration or fault management are not covered anywhere. Given the tone and current content of this document, I don’t think extending it is the way forward -- so, in my review of draft-ietf-sidr-bgpsec-protocol [1], I asked the authors to include an Operations and Management Section there and to consider using this document as the base. Merging this document into draft-ietf-sidr-bgpsec-protocol is an action that the WG\/authors\/Chairs\/Shepherds should consider. While that is my preferred solution, I will move forward with publication of this document if that is the consensus. Thanks! Alvaro. [1] https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/UOSfI4drrFvnO7271ivU3j9RFm4 Major: M1. In Section 5, you wrote: “As they are not formally verifiable, an eBGP listener SHOULD NOT strongly trust unsigned security markings such as communities received across a trust boundary.” After reading this piece of text several times, I think I picked up on the subtle message: don’t trust unsigned *security markings* -- vs what I got from the first n-1 readings: don’t trust communities. I think that this paragraph would greatly benefit from more details or an example related to security markings. M2. In Section 7. (Routing Policy): “As BGPsec will be rolled out over…a long time. Hence a normal operator's policy SHOULD NOT be overly strict, perhaps preferring Valid paths and giving very low preference, but still using, Not Valid paths.” This recommendation concerns me because “Not Valid” talks directly to the fact that the announcement is, well, not valid – vs just unable to be verified (because there’s no BGPsec_Path attribute, for example). The next sentence is a reflection of my concern: “Operators should be aware that accepting Not Valid announcements…will often be the equivalent of treating them as fully Valid.” I-D.sidr-bgpsec-protocol suggests the same thing (in 5.1, pointing to this document). I am left with the question: why validate at all if the BCP recommendation is to use all announcements no matter the state? I obviously realize that it is still early days – maybe it is too early for a BCP document if the “practice” is not there yet… M3. Also in Section 7: “…signed paths that are Not Valid and yet propagated…SHOULD have their signatures kept intact…” Section 4.2. (Constructing the BGPsec_Path Attribute) of draft-ietf-sidr-bgpsec-protocol says: “a Signature_Block which is not deemed 'Valid'…such Signature_Blocks MUST NOT be removed.” The “SHOULD” in this document is at odds with the “MUST NOT” in the BGPSec spec; please s\/SHOULD\/MUST, or (even better) s\/SHOULD\/should. M4. Still in Section 7: “To prevent exposure of the internals of BGP Confederations [RFC5065], a BGPsec speaker which is a Member-AS of a Confederation MUST NOT sign updates sent to another Member-AS of the same Confederation.” This is another case where the BGPSec spec says something different: Section 4.3. (Processing Instructions for Confederation Members) presents a mandatory mechanism that includes signing, but not necessarily validating. BTW, if the updates are not signed, then the signed path would be broken, even if all the routers in the path support BGPSec, right? Is that the recommendation? M5. In Section 8: “…routers' clocks MUST be correct…” What does this mean? Correct with respect to what? Later (2 paragraphs) you do mention RFC5905, should that be the reference here? Maybe make the clock topic one paragraph to avoid confusion. References: R1. The reference to BGPsec should be draft-ietf-sidr-bgpsec-protocol (and not I-D.ietf-sidr-bgpsec-overview). I think it is ok to reference I-D.ietf-sidr-bgpsec-overview in the Suggested Reading as an Informative reference. Similarly, rfc6480, rfc6481 and rfc6482 should be made Informative as well. R2. Section 7: “This implies that the route server creates signatures per client including its own AS in the BGPsec_Path and the target ASes, see 2.2.2 of [I-D.ietf-idr-ix-bgp-route-server].” I think this reference is not correct because I-D.ietf-idr-ix-bgp-route-server doesn’t say anything about BGPSec. That section does say the opposite: “the route server SHOULD NOT prepend its own AS number to the AS_PATH segment nor modify the AS_PATH segment in any other way”. Maybe point at 4.2 of draft-ietf-sidr-bgpsec-protocol instead. R3. RFC6811 should be a Normative reference. Minor: m1. The IPv4 examples in Section 7 should use addressed from rfc6890. m2. In Section 7: “Therefore, unless local policy ensures otherwise, a signed path learned via iBGP MAY be Not Valid.” That “MAY” is not normative in this context, but it is stating a fact: s\/MAY\/may. m3. Also in Section 7: “If it is known that a BGPsec neighbor is not a transparent route server, and the router provides a knob to disallow a received pCount (prepend count, zero for transparent route servers) of zero, that knob SHOULD be applied.” There are other cases when pCount 0 is ok, draft-ietf-sidr-as-migration for example. I know that “SHOULD” allows other cases, but maybe working in the router server as an example might be an improvement. m4. Section 9. (Security Considerations): “The major security considerations for the BGPsec protocol are described in [I-D.ietf-sidr-bgpsec-protocol].” Are there other security considerations not mentioned there? Nits: n1. Introduction: “…origin validation…will occur over the next two to three years and that BGPsec will start to deploy well after that.” Recommendation: avoid specific timeframes, be a little vaguer (short\/medium\/long term). I noticed that the first version of draft-ymbk-bgpsec-ops also mentioned “two to five years” (in 2011!). n2. s\/ client cone, i.e. an RR client or the transitive closure of their customers' customers' customers' etc.\/ client cone, i.e. an RR client or reachable transitively through one of them. n3. “As the vast majority (84%) of ASs are stubs, and they announce the majority of prefixes…” A reference would be nice. n4. “Because of possible RPKI version skew…” I guess you mean lack of sync… n5. Security Considerations. Please write something along the lines of: “This document describes operational considerations for the deployment of BGPsec. The security considerations for BGPsec are…” Randy: Hi! Thanks for working on this document! I have two issues I want to highlight upfront, and then some comments (below). I would like to see these two issues addressed, along with the Major comments below, before moving the document forward. These two upfront issues are probably more questions for the Chairs\/Shepherd. 1. Why is this document a BCP? A BCP is a document that describes “the community's best current thinking…on what is believed to be the best way to perform some operations” [rfc2026]. This document meets that bar of the description, but there is clearly not a lot of practice behind the considerations – which I think is reflected in the lack of significant comments from the WG. I would prefer if this document as Informational, pending some actual experience. But I’ll settle for a good explanation (to be also included in the Shepherd’s write-up) of why BCP. 2. This document, as a companion of draft-ietf-sidr-bgpsec-protocol, is the only place where Operational (or Management) Considerations are discussed. However, important items recommended in RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions), such as migration or fault management are not covered anywhere. Given the tone and current content of this document, I don’t think extending it is the way forward -- so, in my review of draft-ietf-sidr-bgpsec-protocol [1], I asked the authors to include an Operations and Management Section there and to consider using this document as the base. Merging this document into draft-ietf-sidr-bgpsec-protocol is an action that the WG\/authors\/Chairs\/Shepherds should consider. While that is my preferred solution, I will move forward with publication of this document if that is the consensus. Thanks! Alvaro. [1] https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/UOSfI4drrFvnO7271ivU3j9RFm4 Major: M1. In Section 5, you wrote: “As they are not formally verifiable, an eBGP listener SHOULD NOT strongly trust unsigned security markings such as communities received across a trust boundary.” After reading this piece of text several times, I think I picked up on the subtle message: don’t trust unsigned *security markings* -- vs what I got from the first n-1 readings: don’t trust communities. I think that this paragraph would greatly benefit from more details or an example related to security markings. M2. In Section 7. (Routing Policy): “As BGPsec will be rolled out over…a long time. Hence a normal operator's policy SHOULD NOT be overly strict, perhaps preferring Valid paths and giving very low preference, but still using, Not Valid paths.” This recommendation concerns me because “Not Valid” talks directly to the fact that the announcement is, well, not valid – vs just unable to be verified (because there’s no BGPsec_Path attribute, for example). The next sentence is a reflection of my concern: “Operators should be aware that accepting Not Valid announcements…will often be the equivalent of treating them as fully Valid.” I-D.sidr-bgpsec-protocol suggests the same thing (in 5.1, pointing to this document). I am left with the question: why validate at all if the BCP recommendation is to use all announcements no matter the state? I obviously realize that it is still early days – maybe it is too early for a BCP document if the “practice” is not there yet… M3. Also in Section 7: “…signed paths that are Not Valid and yet propagated…SHOULD have their signatures kept intact…” Section 4.2. (Constructing the BGPsec_Path Attribute) of draft-ietf-sidr-bgpsec-protocol says: “a Signature_Block which is not deemed 'Valid'…such Signature_Blocks MUST NOT be removed.” The “SHOULD” in this document is at odds with the “MUST NOT” in the BGPSec spec; please s\/SHOULD\/MUST, or (even better) s\/SHOULD\/should. M4. Still in Section 7: “To prevent exposure of the internals of BGP Confederations [RFC5065], a BGPsec speaker which is a Member-AS of a Confederation MUST NOT sign updates sent to another Member-AS of the same Confederation.” This is another case where the BGPSec spec says something different: Section 4.3. (Processing Instructions for Confederation Members) presents a mandatory mechanism that includes signing, but not necessarily validating. BTW, if the updates are not signed, then the signed path would be broken, even if all the routers in the path support BGPSec, right? Is that the recommendation? M5. In Section 8: “…routers' clocks MUST be correct…” What does this mean? Correct with respect to what? Later (2 paragraphs) you do mention RFC5905, should that be the reference here? Maybe make the clock topic one paragraph to avoid confusion. References: R1. The reference to BGPsec should be draft-ietf-sidr-bgpsec-protocol (and not I-D.ietf-sidr-bgpsec-overview). I think it is ok to reference I-D.ietf-sidr-bgpsec-overview in the Suggested Reading as an Informative reference. Similarly, rfc6480, rfc6481 and rfc6482 should be made Informative as well. R2. Section 7: “This implies that the route server creates signatures per client including its own AS in the BGPsec_Path and the target ASes, see 2.2.2 of [I-D.ietf-idr-ix-bgp-route-server].” I think this reference is not correct because I-D.ietf-idr-ix-bgp-route-server doesn’t say anything about BGPSec. That section does say the opposite: “the route server SHOULD NOT prepend its own AS number to the AS_PATH segment nor modify the AS_PATH segment in any other way”. Maybe point at 4.2 of draft-ietf-sidr-bgpsec-protocol instead. R3. RFC6811 should be a Normative reference. Minor: m1. The IPv4 examples in Section 7 should use addressed from rfc6890. m2. In Section 7: “Therefore, unless local policy ensures otherwise, a signed path learned via iBGP MAY be Not Valid.” That “MAY” is not normative in this context, but it is stating a fact: s\/MAY\/may. m3. Also in Section 7: “If it is known that a BGPsec neighbor is not a transparent route server, and the router provides a knob to disallow a received pCount (prepend count, zero for transparent route servers) of zero, that knob SHOULD be applied.” There are other cases when pCount 0 is ok, draft-ietf-sidr-as-migration for example. I know that “SHOULD” allows other cases, but maybe working in the router server as an example might be an improvement. m4. Section 9. (Security Considerations): “The major security considerations for the BGPsec protocol are described in [I-D.ietf-sidr-bgpsec-protocol].” Are there other security considerations not mentioned there? Nits: n1. Introduction: “…origin validation…will occur over the next two to three years and that BGPsec will start to deploy well after that.” Recommendation: avoid specific timeframes, be a little vaguer (short\/medium\/long term). I noticed that the first version of draft-ymbk-bgpsec-ops also mentioned “two to five years” (in 2011!). n2. s\/ client cone, i.e. an RR client or the transitive closure of their customers' customers' customers' etc.\/ client cone, i.e. an RR client or reachable transitively through one of them. n3. “As the vast majority (84%) of ASs are stubs, and they announce the majority of prefixes…” A reference would be nice. n4. “Because of possible RPKI version skew…” I guess you mean lack of sync… n5. Security Considerations. Please write something along the lines of: “This document describes operational considerations for the deployment of BGPsec. The security considerations for BGPsec are…”"}
{"_id":"doc-en-sidr-UOSfI4drrFvnO7271ivU3j9RFm4","title":"","text":"[sidr] AD Review of draft-ietf-sidr-bgpsec-protocol-18\nDear authors: Hi! First of all, thank you for taking on the duties of editing this document. I have several comments (see below). For the most part, I think they should be easy to solve as many are related to clarifications. Most of the comments I classified as Major are due to the use of Normative language. The biggest concern I have with this document is the lack of an Operations and Management Considerations Section – please take a look at RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions). Some of the information suggested there is present in draft-ietf-sidr-bgpsec-ops, and (ironically) in the “Design and Deployment Considerations” section of draft-ietf-sidr-bgpsec-overview. However, important items such as migration or management are missing. I would like to see a well thought out Operations and Management Section in this document before moving it forward. Note that I’m not suggesting that a YANG model (for example) is required to move forward, but I would like to see considerations about migration, and the impact on network operations, to mention two items, all in one place in the document. I would like the authors\/Chairs\/Shepherd\/WG to consider even merging in draft-ietf-sidr-bgpsec-ops as the base for this new section (or at least reference it prominently). Thanks! Alvaro. Major: M1. Registry Definitions M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. M2. Error Handling — Several sections don't have proper error handling procedures specified. (This is a management issue that I think is underspecified.) M2.1. Section 2.2. (Negotiating BGPsec Support) doesn't fully specify the error handling behavior of the Capability, and it fails open. M2.1.1. What should the action be if the Version is not 0? M2.1.2. \"…a BGP speaker MUST NOT advertise the capability of BGPsec support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI [RFC4760].\" What should happen if it does advertise an AFI that is not covered by the multiprotocol extension capability? Or if the multi-protocol capability is not advertised at all? To clarify: if the multi-protocol capability is not advertised then support for BGPsec can’t be advertised either – does that mean that a BGP speaker configured to use BGPsec must not use it if not negotiated? I know the answer is “yes”, but I’m trying to get to the point of provisioning and expectations – why configure BGPsec if no one is expected to support it? M2.1.3. Missing the four-byte AS capability results in BGPsec not working (\"BGPsec has not been successfully negotiated\"), but the ability of exchanging routes is still there, leaving the system in a fail open state and potentially breaking the chain of ASNs. Personally, it doesn't seem like a good result — please at least include some text about this in the Security Considerations section. M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) M2.2.1. There are multiple places in the BGPsec_Path Attribute that could end up in an error, everything from setting bits in the Flags field to wrong Length fields. Should all errors result in the same behavior? M3. Section 4.1. (General Guidance): \"When propagating a received route advertisement to an internal peer, the BGPsec speaker typically populates the BGPsec_Path attribute by copying the BGPsec_Path attribute from the received update message. That is, the BGPsec_Path attribute is copied verbatim…. Note that when a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec.\" The first part of the guidance says that a new BGPsec_Path attribute is created by copying the received attribute (which is then presumably removed), but the second part says that the received attribute SHOULD NOT be removed. Please clarify so that there is consistency -- I understand that the result is the same, but the description is not and we should try to avoid confusion. Parts of Section 4.2. (Constructing the BGPsec_Path Attribute) also talk about actions like \"…and there is an existing BGPsec_Path attribute, then the BGPsec speaker prepends its new Secure_Path Segment (places in first position) onto the existing Secure_Path\", which hint at propagating a received BGPsec_Path attribute (and not creating a new one). M4. Section 4.2. (Constructing the BGPsec_Path Attribute) says that \"The AS number in this Secure_Path segment MUST match the AS number in the AS number resource extension field of the Resource PKI router certificate(s) that will be used to verify the digital signature(s) constructed by this BGPsec speaker [I-D.ietf-sidr-bgpsec-pki-profiles].\" However, there is no extension field or certificate in I-D.ietf-sidr-bgpsec-pki-profiles with that name. Please be precise with the names. M5. In 4.2: “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This text seems to assume some kind of configuration\/provisioning. Note that Section 5.2. (Validation Algorithm) also has similar text about receiving an UPDATE “from a peer that is not expected to set pCount equal to zero”. M6. In 4.2: “If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker SHOULD include both of the Signature_Blocks.” Why is this “SHOULD” not a “MUST”? When\/why would a speaker remove one or the 2? If one is removed, should there be a requirement that the one that was used to successfully validate the update be kept? Note that Section 7.2 later talks about the problems of removing signatures… M6.1. Note that later in this section the text says that “a 'Valid' BGPsec update message may contain a Signature_Block which is not deemed 'Valid' (e.g., contains signatures that BGPsec does not successfully verify). Nonetheless, such Signature_Blocks MUST NOT be removed.” Taking this “MUST NOT” along with the “SHOULD” above, the door is open to remove the Signature_Block used to verify the validity and just forward the one not used (which may itself not be valid). M6.2. Section 5.2. (Validation Algorithm) opens this door even more when saying that “If at least one Signature_Block is marked as 'Valid', then the validation algorithm terminates and the BGPsec update message is deemed to be 'Valid'.” The text here doesn’t require that both Signature_Blocks be verified, but implies that as long as the first one is valid then the second one doesn’t really need to be verified. Is that the intent? M7. Section 5. (Processing a Received BGPsec Update) talks about “duplicate update messages” (one where “it differs from the first update message only in the Signature fields (within the BGPsec_Path attribute)”). M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the route currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? M8. Section 5.1. (Overview of BGPsec Validation) says that \"BGPsec specifies no changes to the BGP decision process.\" However, Section 5. (Processing a Received BGPsec Update) also says that \"a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute.\" I'm assuming that the Decision Process is included in \"all cases\". Even though 5.1 refers to the use the validation state in the decision process, please make sure that it is clear that the decision process is modified by the use of the different attribute. M8.1. Please specifically include a section (or text somewhere) about how the information in the BGPsec_Path attribute is used in the Decision Process. For example, how should the \"number of AS numbers\" in the path be calculated for 9.1.2.2. (Breaking Ties (Phase 2)) in rfc4271? The text talks about the \"effective length\" being the sum of the pCount values, but the \"effective length\" (at least with that name) is not what is used in rfc4172 — please be clear and consistent. M8.2. [minor] Section 3. (The BGPsec_Path Attribute) reads: \"The information in Secure_Path is used by BGPsec speakers in the same way that information from the AS_PATH is used by non-BGPsec speakers.\" This is pretty much the same information that is in Section 5, but with more specificity. It would help if the more specific case was the one normatively called out. M9. Section 5.2. (Validation Algorithm). RFC4271 also specifies a series of validity checks when an UPDATE is received (Section 6.3) – should that check be run before or after the algorithm specified here? The algorithm focuses on verifying the validity of the BGPsec_Path attribute (and not the whole UPDATE), so I’m assuming it should be executed instead of checking the AS_PATH. Please include some text about the interaction\/changes. M9.1. Section 5.2. (Validation Algorithm): “…then the BGPsec speaker MUST treat the update message in the same manner that the BGPsec speaker would treat an (unsigned) update message that arrived without a BGPsec_Path attribute.” What exactly does this mean? If the BGPsec_Path attribute is not received, then the AS_PATH should be – does the text imply that the AS_PATH should be reconstructed? I guess it should be if the update is to be propagated – but the question is while the update is being processed, which AS path information is used, the one in a reconstructed AS_PATH or the one in the BGPsec_Path while assuming that all the signatures are correct? M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. M11. The Figures (which are not numbered) in 4.2. (Constructing the BGPsec_Path Attribute) and 5.2. (Validation Algorithm) present the sequence of octets to be hashed. I’m guessing that the order of the Signature and Secure_Path Segments may be important, is it? The order in the Figures is not clear to me, if the order is important, please be clear about it; if not, please also say so. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. M13. What about replay attacks? There is no mention of the risk or potential mitigation anywhere. Please include in the Security Considerations section. Minor: m1. The use of SKI, Subject Key Identifier without a qualifier (field, extension) is confusing at times. Please expand SKI on first use. An example: (from 3.2) “The Subject Key Identifier contains the value in the Subject Key Identifier extension of the RPKI…” The first mention should include “field”, like similar text in 4.2. m2. Section 4. (BGPsec Update Messages) says: \"A BGPsec speaker that is not a member of such a confederation MUST set the Flags field of the Secure_Path Segment to zero in all BGPsec update messages it sends.\" While only one flag is defined, the correct statement is \"…set the Confed_Segment flag…\". m3. Section 4.1. (General Guidance): s\/\"A BGPsec update message MUST advertise a route to only a single NLRI.\"\/\"A BGPsec update message MUST advertise a route to only a single prefix.\" This section contains other places where the NLRI term is not used correctly. In short, the NLRI in a BGP Update contains one or more prefixes — so the text should talk about a single prefix, not a single NLRI. m4. In between the text above, the following is written: \"However, in the case that the BGPsec speaker is performing an AS Migration, the BGPsec speaker may add an additional signature on ingress before copying the BGPsec_Path attribute (see [I-D.ietf-sidr-as-migration] for more details).\" Because I-D.ietf-sidr-as-migration is marked as Updating this document, I suggest you remove this text (and the one in 4.2) -- note that the statements made in this document are not normative anyway and I-D.ietf-sidr-as-migration can stand on its own by clearly specifying what is needed for AS Migration. m5. In 4.2: “To prevent unnecessary processing load…a BGPsec speaker SHOULD NOT produce multiple consecutive Secure_Path Segments with the same AS number. This means that to achieve the semantics of prepending the same AS number k times, a BGPsec speaker SHOULD produce a single Secure_Path Segment – with pCount of k...” Given pCount, I’m wondering why these SHOULDs are not MUSTs, especially given the expected additional load. m6. Section 4.3. (Processing Instructions for Confederation Members) explains the process of adding Secure_Path and Signature segments that may or may not be used at all (given that the verification is optional), only to remove them later. Why isn’t the process of adding Secure_Path and Signature segments optional itself (instead of just the validation)? m7. In 4.4. (Reconstructing the AS_PATH Attribute), what should happen if the Confed_Segment flag is set to zero and the most-recently added segment in the AS_PATH is of type AS_CONFED_SEQUENCE? Theoretically this can’t occur because it means that someone accepted an update that it shouldn’t have, but please include some text about this case being an error. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? m9. Section 5.1 contains these references: “…the trusted cache could deliver the necessary validity information to the BGPsec speaker using the router key PDU [I-D.ietf-sidr-rtr-keying] for the RPKI-to-Router protocol [I-D.ietf-sidr-rpki-rtr-rfc6810-bis].” The reference to I-D.ietf-sidr-rtr-keying seems to be related to the “router key PDU”, but that is defined in I-D.ietf-sidr-rpki-rtr-rfc6810-bis, so it looks like the first reference is not needed. m10. In 5.1: “As discussed in Section 4, when a BGPsec speaker chooses to forward…, it SHOULD be forwarded with its BGPsec_Path attribute…” That “SHOULD” is pointing at a fact, not acting normatively in this sentence so please change it to “should”. m11. Section 5.2. (Validation Algorithm) mentions this check: ‘update..from a peer that is not a member of the BGPsec speaker's AS confederation, check to ensure that none of the Secure_Path segments contain a Flags field with the Confed_Sequence flag set to one.” I’m sure that the check for the flag set if the peer is a Confederation peer is also needed, but not mentioned in this section (where the normative MUST for the validation algorithm) is present. Section 4.3. (Processing Instructions for Confederation Members) does say this: “…when a confederation member runs the algorithm in Section 5.2, the confederation member, during processing of a Signature Segment, first checks whether the Confed_Sequence flag in the corresponding Secure_Path segment is set to one.” I would like to see the full algorithm specified in one place (even if, like in Section 4.3, pieces of it are explained elsewhere). Also, the text in 4.3 says that the check is performed “during processing of a Signature Segment”, which is fine, but probably late in the process (compared to the text in 5.2 that seems to require the check when the updates are received). m12. In Section 7.4. (Additional Security Considerations), please add a reference to point at “appropriate transport security mechanisms.”, and\/or point at the Security Considerations from rfc4271. Nits: n1. In several places the text uses “we” (for example: “we expect…”). It’s just a matter of style, but using the third person may be more appropriate (for example: “it is expected…”). n2. The use of “Target AS Number” is inconsistent: sometimes the “number” is capitalized, others it isn’t, and sometimes it is not even mentioned. n3. I don’t think we need Section 6.2. (Extensibility Considerations). Dear authors: Hi! First of all, thank you for taking on the duties of editing this document. I have several comments (see below). For the most part, I think they should be easy to solve as many are related to clarifications. Most of the comments I classified as Major are due to the use of Normative language. The biggest concern I have with this document is the lack of an Operations and Management Considerations Section – please take a look at RFC5706 (Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions). Some of the information suggested there is present in draft-ietf-sidr-bgpsec-ops, and (ironically) in the “Design and Deployment Considerations” section of draft-ietf-sidr-bgpsec-overview. However, important items such as migration or management are missing. I would like to see a well thought out Operations and Management Section in this document before moving it forward. Note that I’m not suggesting that a YANG model (for example) is required to move forward, but I would like to see considerations about migration, and the impact on network operations, to mention two items, all in one place in the document. I would like the authors\/Chairs\/Shepherd\/WG to consider even merging in draft-ietf-sidr-bgpsec-ops as the base for this new section (or at least reference it prominently). Thanks! Alvaro. Major: M1. Registry Definitions M1.1. Section 2.1. (The BGPsec Capability) includes a Version field and some Reserved bits, but there are no IANA registries defined for how to manage these spaces. Please define the registries and the corresponding registration procedures. M1.2. Section 3.1. (Secure_Path) defines the Flags field and assigns the first bit (BTW, is that the MSB or the LSB, please clarify), but doesn't set up the registry or registration procedures. M2. Error Handling — Several sections don't have proper error handling procedures specified. (This is a management issue that I think is underspecified.) M2.1. Section 2.2. (Negotiating BGPsec Support) doesn't fully specify the error handling behavior of the Capability, and it fails open. M2.1.1. What should the action be if the Version is not 0? M2.1.2. \"…a BGP speaker MUST NOT advertise the capability of BGPsec support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI [RFC4760].\" What should happen if it does advertise an AFI that is not covered by the multiprotocol extension capability? Or if the multi-protocol capability is not advertised at all? To clarify: if the multi-protocol capability is not advertised then support for BGPsec can’t be advertised either – does that mean that a BGP speaker configured to use BGPsec must not use it if not negotiated? I know the answer is “yes”, but I’m trying to get to the point of provisioning and expectations – why configure BGPsec if no one is expected to support it? M2.1.3. Missing the four-byte AS capability results in BGPsec not working (\"BGPsec has not been successfully negotiated\"), but the ability of exchanging routes is still there, leaving the system in a fail open state and potentially breaking the chain of ASNs. Personally, it doesn't seem like a good result — please at least include some text about this in the Security Considerations section. M2.2. The definition of the BGPsec_Path Attribute (and its details) don't have clear error handling procedures defined (RFC7606). Section 4.3. (Processing Instructions for Confederation Members) does say this: \"(As discussed in Section 5.2, any error in the BGPsec_Path attribute MUST be handled using the \"treat-as-withdraw\", approach as defined in RFC 7606 [RFC7606].)\" (including the parentheses). However, 5,2 only says: \"BGPsec speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC 7606 [RFC7606].\" Note: \"these errors\" is not the same as \"any error\". Please discuss error handling in a more prominent place. (Hint: it may fit in a fault management discussion in the Operations and Management Section.) M2.2.1. There are multiple places in the BGPsec_Path Attribute that could end up in an error, everything from setting bits in the Flags field to wrong Length fields. Should all errors result in the same behavior? M3. Section 4.1. (General Guidance): \"When propagating a received route advertisement to an internal peer, the BGPsec speaker typically populates the BGPsec_Path attribute by copying the BGPsec_Path attribute from the received update message. That is, the BGPsec_Path attribute is copied verbatim…. Note that when a BGPsec speaker chooses to forward a BGPsec update message to an iBGP peer, the BGPsec attribute SHOULD NOT be removed, unless the peer doesn't support BGPsec.\" The first part of the guidance says that a new BGPsec_Path attribute is created by copying the received attribute (which is then presumably removed), but the second part says that the received attribute SHOULD NOT be removed. Please clarify so that there is consistency -- I understand that the result is the same, but the description is not and we should try to avoid confusion. Parts of Section 4.2. (Constructing the BGPsec_Path Attribute) also talk about actions like \"…and there is an existing BGPsec_Path attribute, then the BGPsec speaker prepends its new Secure_Path Segment (places in first position) onto the existing Secure_Path\", which hint at propagating a received BGPsec_Path attribute (and not creating a new one). M4. Section 4.2. (Constructing the BGPsec_Path Attribute) says that \"The AS number in this Secure_Path segment MUST match the AS number in the AS number resource extension field of the Resource PKI router certificate(s) that will be used to verify the digital signature(s) constructed by this BGPsec speaker [I-D.ietf-sidr-bgpsec-pki-profiles].\" However, there is no extension field or certificate in I-D.ietf-sidr-bgpsec-pki-profiles with that name. Please be precise with the names. M5. In 4.2: “BGPsec speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPsec speaker does not expect its peer to set pCount to zero.” This text seems to assume some kind of configuration\/provisioning. Note that Section 5.2. (Validation Algorithm) also has similar text about receiving an UPDATE “from a peer that is not expected to set pCount equal to zero”. M6. In 4.2: “If the received BGPsec update message contains two Signature_Blocks and the BGPsec speaker supports both of the corresponding algorithm suites, then the new update message generated by the BGPsec speaker SHOULD include both of the Signature_Blocks.” Why is this “SHOULD” not a “MUST”? When\/why would a speaker remove one or the 2? If one is removed, should there be a requirement that the one that was used to successfully validate the update be kept? Note that Section 7.2 later talks about the problems of removing signatures… M6.1. Note that later in this section the text says that “a 'Valid' BGPsec update message may contain a Signature_Block which is not deemed 'Valid' (e.g., contains signatures that BGPsec does not successfully verify). Nonetheless, such Signature_Blocks MUST NOT be removed.” Taking this “MUST NOT” along with the “SHOULD” above, the door is open to remove the Signature_Block used to verify the validity and just forward the one not used (which may itself not be valid). M6.2. Section 5.2. (Validation Algorithm) opens this door even more when saying that “If at least one Signature_Block is marked as 'Valid', then the validation algorithm terminates and the BGPsec update message is deemed to be 'Valid'.” The text here doesn’t require that both Signature_Blocks be verified, but implies that as long as the first one is valid then the second one doesn’t really need to be verified. Is that the intent? M7. Section 5. (Processing a Received BGPsec Update) talks about “duplicate update messages” (one where “it differs from the first update message only in the Signature fields (within the BGPsec_Path attribute)”). M7.1. “With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different).” Even though a discussion about non-deterministic signature algorithms precedes this text, the validation is still not run. How can the validity of the Path be guaranteed in this case? Should this be the action for all algorithms or only ones known to be non-deterministic? M7.2. rfc4271 (in Section 9. (UPDATE Message Handling) talks about the implicit withdraw of a route “if the NLRI of the new route is identical to the one the route currently has stored…”. The same NLRI case seems to be a particular condition of the “duplicate update” described here. It might be a good idea to mention that a “duplicate update” results in the implicit withdraw of the original update. What happens if a third duplicate route is received (the first one was valid, the second one was not validated), should it be validated? M8. Section 5.1. (Overview of BGPsec Validation) says that \"BGPsec specifies no changes to the BGP decision process.\" However, Section 5. (Processing a Received BGPsec Update) also says that \"a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute.\" I'm assuming that the Decision Process is included in \"all cases\". Even though 5.1 refers to the use the validation state in the decision process, please make sure that it is clear that the decision process is modified by the use of the different attribute. M8.1. Please specifically include a section (or text somewhere) about how the information in the BGPsec_Path attribute is used in the Decision Process. For example, how should the \"number of AS numbers\" in the path be calculated for 9.1.2.2. (Breaking Ties (Phase 2)) in rfc4271? The text talks about the \"effective length\" being the sum of the pCount values, but the \"effective length\" (at least with that name) is not what is used in rfc4172 — please be clear and consistent. M8.2. [minor] Section 3. (The BGPsec_Path Attribute) reads: \"The information in Secure_Path is used by BGPsec speakers in the same way that information from the AS_PATH is used by non-BGPsec speakers.\" This is pretty much the same information that is in Section 5, but with more specificity. It would help if the more specific case was the one normatively called out. M9. Section 5.2. (Validation Algorithm). RFC4271 also specifies a series of validity checks when an UPDATE is received (Section 6.3) – should that check be run before or after the algorithm specified here? The algorithm focuses on verifying the validity of the BGPsec_Path attribute (and not the whole UPDATE), so I’m assuming it should be executed instead of checking the AS_PATH. Please include some text about the interaction\/changes. M9.1. Section 5.2. (Validation Algorithm): “…then the BGPsec speaker MUST treat the update message in the same manner that the BGPsec speaker would treat an (unsigned) update message that arrived without a BGPsec_Path attribute.” What exactly does this mean? If the BGPsec_Path attribute is not received, then the AS_PATH should be – does the text imply that the AS_PATH should be reconstructed? I guess it should be if the update is to be propagated – but the question is while the update is being processed, which AS path information is used, the one in a reconstructed AS_PATH or the one in the BGPsec_Path while assuming that all the signatures are correct? M10. In Section 7.2. (On the Removal of BGPsec Signatures): “…the protocol specifies that a BGPsec speaker choosing to propagate the route advertisement in such an update message SHOULD add its signature to each of the Signature_Blocks.” I believe the reference is Section 4.2 (please add it). However, that Section doesn’t use normative language (“For each Signature_Block corresponding to an algorithm suite that the BGPsec speaker does support, the BGPsec speaker adds a new Signature Segment to the Signature_Block.”) In any case, the “SHOULD” in 7.2 is out of place because it is referencing a fact (pointing at the other section) and not being used normatively – if you want the “SHOULD” to be normative, then it should be back in 4.2. M11. The Figures (which are not numbered) in 4.2. (Constructing the BGPsec_Path Attribute) and 5.2. (Validation Algorithm) present the sequence of octets to be hashed. I’m guessing that the order of the Signature and Secure_Path Segments may be important, is it? The order in the Figures is not clear to me, if the order is important, please be clear about it; if not, please also say so. M12. The mandatory addition of Secure_Path and Signature segments in a Confederation results in the inconsistent authorization chain mentioned in Section 4.3. (Processing Instructions for Confederation Members): “For a signature produced by a peer BGPsec speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number.” It seems to me that this discontinuity in the ASN list breaks the “cryptographic assurance that…Every AS on the path of ASes listed in the update message has explicitly authorized the advertisement of the route to the subsequent AS in the path” because there is no way to verify that the Member-AS in the first Secure_Path segment is in fact the one peering with the external neighbor. I realize that the risk may be minimized by an “internal trust” factor, but I would like to see a discussion about this issue in the Security Considerations. M13. What about replay attacks? There is no mention of the risk or potential mitigation anywhere. Please include in the Security Considerations section. Minor: m1. The use of SKI, Subject Key Identifier without a qualifier (field, extension) is confusing at times. Please expand SKI on first use. An example: (from 3.2) “The Subject Key Identifier contains the value in the Subject Key Identifier extension of the RPKI…” The first mention should include “field”, like similar text in 4.2. m2. Section 4. (BGPsec Update Messages) says: \"A BGPsec speaker that is not a member of such a confederation MUST set the Flags field of the Secure_Path Segment to zero in all BGPsec update messages it sends.\" While only one flag is defined, the correct statement is \"…set the Confed_Segment flag…\". m3. Section 4.1. (General Guidance): s\/\"A BGPsec update message MUST advertise a route to only a single NLRI.\"\/\"A BGPsec update message MUST advertise a route to only a single prefix.\" This section contains other places where the NLRI term is not used correctly. In short, the NLRI in a BGP Update contains one or more prefixes — so the text should talk about a single prefix, not a single NLRI. m4. In between the text above, the following is written: \"However, in the case that the BGPsec speaker is performing an AS Migration, the BGPsec speaker may add an additional signature on ingress before copying the BGPsec_Path attribute (see [I-D.ietf-sidr-as-migration] for more details).\" Because I-D.ietf-sidr-as-migration is marked as Updating this document, I suggest you remove this text (and the one in 4.2) -- note that the statements made in this document are not normative anyway and I-D.ietf-sidr-as-migration can stand on its own by clearly specifying what is needed for AS Migration. m5. In 4.2: “To prevent unnecessary processing load…a BGPsec speaker SHOULD NOT produce multiple consecutive Secure_Path Segments with the same AS number. This means that to achieve the semantics of prepending the same AS number k times, a BGPsec speaker SHOULD produce a single Secure_Path Segment – with pCount of k...” Given pCount, I’m wondering why these SHOULDs are not MUSTs, especially given the expected additional load. m6. Section 4.3. (Processing Instructions for Confederation Members) explains the process of adding Secure_Path and Signature segments that may or may not be used at all (given that the verification is optional), only to remove them later. Why isn’t the process of adding Secure_Path and Signature segments optional itself (instead of just the validation)? m7. In 4.4. (Reconstructing the AS_PATH Attribute), what should happen if the Confed_Segment flag is set to zero and the most-recently added segment in the AS_PATH is of type AS_CONFED_SEQUENCE? Theoretically this can’t occur because it means that someone accepted an update that it shouldn’t have, but please include some text about this case being an error. m8. Section 5.1. (Overview of BGPsec Validation): “It is expected that BGP peers will generally prefer routes received via 'Valid' BGPsec update messages over both routes received via 'Not Valid' BGPsec update messages and routes received via update messages that do not contain the BGPsec_Path attribute…(See [I-D.ietf-sidr-bgpsec-ops]…” I read this piece of text as saying that routes in Not Valid updates are expected to be used (even though they are not valid). Besides the fact that I-D.ietf-sidr-bgpsec-ops does recommend using Not Valid announcements (in Section 7), are there other reasons for this document to expect their use? m9. Section 5.1 contains these references: “…the trusted cache could deliver the necessary validity information to the BGPsec speaker using the router key PDU [I-D.ietf-sidr-rtr-keying] for the RPKI-to-Router protocol [I-D.ietf-sidr-rpki-rtr-rfc6810-bis].” The reference to I-D.ietf-sidr-rtr-keying seems to be related to the “router key PDU”, but that is defined in I-D.ietf-sidr-rpki-rtr-rfc6810-bis, so it looks like the first reference is not needed. m10. In 5.1: “As discussed in Section 4, when a BGPsec speaker chooses to forward…, it SHOULD be forwarded with its BGPsec_Path attribute…” That “SHOULD” is pointing at a fact, not acting normatively in this sentence so please change it to “should”. m11. Section 5.2. (Validation Algorithm) mentions this check: ‘update..from a peer that is not a member of the BGPsec speaker's AS confederation, check to ensure that none of the Secure_Path segments contain a Flags field with the Confed_Sequence flag set to one.” I’m sure that the check for the flag set if the peer is a Confederation peer is also needed, but not mentioned in this section (where the normative MUST for the validation algorithm) is present. Section 4.3. (Processing Instructions for Confederation Members) does say this: “…when a confederation member runs the algorithm in Section 5.2, the confederation member, during processing of a Signature Segment, first checks whether the Confed_Sequence flag in the corresponding Secure_Path segment is set to one.” I would like to see the full algorithm specified in one place (even if, like in Section 4.3, pieces of it are explained elsewhere). Also, the text in 4.3 says that the check is performed “during processing of a Signature Segment”, which is fine, but probably late in the process (compared to the text in 5.2 that seems to require the check when the updates are received). m12. In Section 7.4. (Additional Security Considerations), please add a reference to point at “appropriate transport security mechanisms.”, and\/or point at the Security Considerations from rfc4271. Nits: n1. In several places the text uses “we” (for example: “we expect…”). It’s just a matter of style, but using the third person may be more appropriate (for example: “it is expected…”). n2. The use of “Target AS Number” is inconsistent: sometimes the “number” is capitalized, others it isn’t, and sometimes it is not even mentioned. n3. I don’t think we need Section 6.2. (Extensibility Considerations)."}
{"_id":"doc-en-sidr-pJl948JltpaZm4SSsy5uqWM1HiU","title":"","text":"Re: [sidr] Current document status && directionz\nOn Wed, Oct 26, 2016 at 11:18 PM, Randy Bush <randy@psg.com> wrote: Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-rpki-validation-reconsidered (10\/26 sent forward) an interesting view on progress of these documents is visible in https:\/\/datatracker.ietf.org\/doc\/ad\/alvaro.retana\/ yes, the chairs posed the question: \"Err, did we sink your battleship with too many docks?\" to alvaro, he's still using his snorkel to swim out of the trench... he'll get there he says :) (and basically we did our job pushing documents forward and working through the discussions.... 'we' here == 'working-group' not 'me' Thanks to the WG folk for doing some hard work and focusing) -chris > Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-rpki-validation-reconsidered (10\/26 sent forward) an interesting view on progress of these documents is visible in https:\/\/datatracker.ietf.org\/doc\/ad\/alvaro.retana\/yes, the chairs posed the question: \"Err, did we sink your battleship with too many docks?\" to alvaro, he's still using his snorkel to swim out of the trench... he'll get there he says :)(and basically we did our job pushing documents forward and working through the discussions.... 'we' here == 'working-group' not 'me' Thanks to the WG folk for doing some hard work and focusing)-chris"}
{"_id":"doc-en-sidr-AewYIis0q4GTs9IoGpcRvEVjB08","title":"","text":"Re: [sidr] Current document status && directionz\nCurrently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-rpki-validation-reconsidered (10\/26 sent forward) an interesting view on progress of these documents is visible in https:\/\/datatracker.ietf.org\/doc\/ad\/alvaro.retana\/ randy"}
{"_id":"doc-en-sidr-lKQVPHWjYe0UGIisH1Mz3IRcITk","title":"","text":"Re: [sidr] Current document status && directionz\nRestarting this thread, with some updates :) Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :) Currently we have the following in IESG\/pub-request status (13 documents): draft-ietf-sidr-adverse-actions draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup draft-ietf-sidr-rpki-rtr-rfc6810-bis draft-ietf-sidr-delta-protocol (10\/26 sent forward) draft-ietf-sidr-rpki-validation-reconsidered (10\/26 sent forward) Currently still active documents (8 documents): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-rtr-keying draft-ietf-sidr-slurm (this reflects the changes since the last email, included below) I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keying which leaves to be dealt with by Chicago 2 documents: draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-slurm I think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up. -chris On Fri, Sep 2, 2016 at 4:56 PM, Chris Morrow <morrowc@ops-netman.net> wrote: Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Restarting this thread, with some updates :)Preparing for Seoul in a few weeks time, with the intent that we do not meet face-to-face in Chicago, have all current 'protocol' related docs to the IESG\/done and meet instead in sidr-ops if there are agenda items at that time :)Currently we have the following in IESG\/pub-request status (13 documents):draft-ietf-sidr-adverse-actionsdraft-ietf-sidr-as-migrationdraft-ietf-sidr-bgpsec-algsdraft-ietf-sidr-bgpsec-opsdraft-ietf-sidr-bgpsec-overviewdraft-ietf-sidr-bgpsec-pki-profilesdraft-ietf-sidr-bgpsec-protocoldraft-ietf-sidr-origin-validation-signalingdraft-ietf-sidr-publicationdraft-ietf-sidr-rpki-oob-setupdraft-ietf-sidr-rpki-rtr-rfc6810-bisdraft-ietf-sidr-delta-protocol (10\/26 sent forward)draft-ietf-sidr-rpki-validation-reconsidered (10\/26 sent forward)Currently still active documents (8 documents):draft-ietf-sidr-bgpsec-rolloverdraft-ietf-sidr-lta-use-casesdraft-ietf-sidr-route-server-rpki-lightdraft-ietf-sidr-rpki-tree-validationdraft-ietf-sidr-rpki-validation-reconsidereddraft-ietf-sidr-rtr-keyingdraft-ietf-sidr-slurm(this reflects the changes since the last email, included below)I believe we're still planning to move (and have agreement from authors): draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light draft-ietf-sidr-rtr-keyingwhich leaves to be dealt with by Chicago 2 documents:draft-ietf-sidr-rpki-tree-validationdraft-ietf-sidr-slurmI think this is good, I believe (and of course I should be corrected if wrong) slurm - more work inbound and discussion planned in Seoul tree-validation - I thought moved to sidr-ops, but don't have docs to back that up.-chris Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-fMNI742Z2EsiuRAE8UE4NQkJoFI","title":"","text":"Re: [sidr] Current document status && directionz\nHi Chris, With regards to \"draft-rir-rpki-allres-ta-app-statement², the question for the WG acceptance should go back to the authors on their willingness to take WG feedback. If the aim is to work with the WG, I think the document describes a current problem with inter-RIR address transfers and one (but maybe not the one the WG would finally document) solution. If the aim is for the RIRs to inform the rest of the world of a decision they have taken, this should be an individual draft submission into the Independent Submission Editor and not a SIDR WG item. Regards, Roque On 06\/09\/16 18:06, \"sidr on behalf of Chris Morrow\" <sidr-bounces@ietf.org on behalf of morrowc@ops-netman.net> wrote: At Sat, 3 Sep 2016 14:06:25 -0700, joel jaeggli <joelja@bogus.com> wrote: [1 Re: Current document status && directionz <multipart\/mixed (7bit)>] [1.1 <text\/plain; windows-1252 (quoted-printable)>] Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying I think we good good feeback on the draft of a charter, I will start work on taking this to the IESG, but as some point soon the time will come to ask for community review of that proposal. I also forgot to mention the all-res draft: draft-rir-rpki-allres-ta-app-statement is waiting for some AD comments to complete (with chairs I mean) to set location\/direction. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-r7TY-x2HCgDRN84kDz32o8Y9mPk","title":"","text":"Re: [sidr] Current document status && directionz\nCarlos, I guess what the RIRs are going to do is to create a CA hierarchy: RIR_CA_0\/0_(probably a hidden HSM) ‹> RIR_CA_RIR_RESOURCES (online HSM) ‹> member_CA This means that not much changed from the current situation multiple self-signed certs, other than instead of getting the list of resources for each RIR from the first CA certificated, I need to fetch the second level CA cert. Is this how you plan to implement this change? Regards, Roque ‹ Roque Gagliano Tail-f Solutions Architect Southern Europe +41 76 449 8867 On 06\/09\/16 00:54, \"sidr on behalf of Carlos M. Martinez\" <sidr-bounces@ietf.org on behalf of carlosm3011@gmail.com> wrote: Here is the pointer to the document: https:\/\/tools.ietf.org\/html\/draft-rir-rpki-allres-ta-app-statement-01 Apologies for my earlier laziness. On 9\/5\/2016 3:32 PM, Carlos M. Martinez wrote: Hi Chris, I know we already discussed this over private email, but perhaps you can comment on the list on the future of the requested WG adoption call for the Œall resources¹ applicability statement draft. thanks! -Carlos Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-9_TEFweDxogbOkg5S_-3kmUsOZQ","title":"","text":"Re: [sidr] Current document status && directionz\nAt Sat, 3 Sep 2016 14:06:25 -0700, joel jaeggli <joelja@bogus.com> wrote: [1 Re: Current document status && directionz <multipart\/mixed (7bit)>] [1.1 <text\/plain; windows-1252 (quoted-printable)>] Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying I think we good good feeback on the draft of a charter, I will start work on taking this to the IESG, but as some point soon the time will come to ask for community review of that proposal. I also forgot to mention the all-res draft: draft-rir-rpki-allres-ta-app-statement is waiting for some AD comments to complete (with chairs I mean) to set location\/direction."}
{"_id":"doc-en-sidr-565qkC8uceRPbFxYX4HUdrGpi1g","title":"","text":"Re: [sidr] Current document status && directionz\nAt Mon, 5 Sep 2016 19:54:53 -0300, \"Carlos M. Martinez\" <carlosm3011@gmail.com> wrote: Here is the pointer to the document: https:\/\/tools.ietf.org\/html\/draft-rir-rpki-allres-ta-app-statement-01 Apologies for my earlier laziness. no worries, yes Sandy and I chatted about this... err, I think the end result was: \"is this an ops thing? should this go to ops? or should we just adopt it in SIDR and jam it through?\" I think sandy was due to send 'authors'(you\/andy\/etc) a mail about this... oh and we're waiting on Alvaro to reply to this as well. I'll mail an update to the list. On 9\/5\/2016 3:32 PM, Carlos M. Martinez wrote: Hi Chris, I know we already discussed this over private email, but perhaps you can comment on the list on the future of the requested WG adoption call for the ‘all resources’ applicability statement draft. thanks! -Carlos Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-BIOA2cW3-frvrWRabc-LzAcC_jM","title":"","text":"Re: [sidr] Current document status && directionz\nHere is the pointer to the document: https:\/\/tools.ietf.org\/html\/draft-rir-rpki-allres-ta-app-statement-01 Apologies for my earlier laziness. On 9\/5\/2016 3:32 PM, Carlos M. Martinez wrote: Hi Chris, I know we already discussed this over private email, but perhaps you can comment on the list on the future of the requested WG adoption call for the ‘all resources’ applicability statement draft. thanks! -Carlos Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-XxKsVnX6GdFD8v25XnKmMQY98Go","title":"","text":"Re: [sidr] Current document status && directionz\nHi Chris, I know we already discussed this over private email, but perhaps you can comment on the list on the future of the requested WG adoption call for the ‘all resources’ applicability statement draft. thanks! -Carlos Howdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-E60euJUbuJk5djob9wuyEWN5f7c","title":"","text":"Re: [sidr] Current document status && directionz\nHowdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying I think we good good feeback on the draft of a charter, I will start work on taking this to the IESG, but as some point soon the time will come to ask for community review of that proposal. regards joel documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris"}
{"_id":"doc-en-sidr-dP6ICBBIqnjmEUSObajb6q9ADu0","title":"","text":"[sidr] Current document status && directionz\nHowdy SIDR peeps, (+bonus ops ad) Following on the Berlin meeting we were trying to accomplish two things: 1) get all documents related to sidr protocols into wglc and then publication 2) get all documents which are more operationally focused moved along to an ops group (sidr-ops or something akin to that) With that in mind there are 8 documents in the publication queue: draft-ietf-sidr-as-migration draft-ietf-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-ops draft-ietf-sidr-bgpsec-overview draft-ietf-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-protocol draft-ietf-sidr-origin-validation-signaling draft-ietf-sidr-rpki-rtr-rfc6810-bis and 11 still in progress. Of the 11 left Sandy and I think they roughly break down like: Documents which should move to the ops group: draft-ietf-sidr-bgpsec-rollover draft-ietf-sidr-lta-use-cases draft-ietf-sidr-route-server-rpki-light - authors notified\/queried about this draft-ietf-sidr-rtr-keying documents which should finish out in sidr: draft-ietf-sidr-delta-protocol draft-ietf-sidr-publication draft-ietf-sidr-rpki-oob-setup - pub request in flight draft-ietf-sidr-rpki-tree-validation draft-ietf-sidr-rpki-validation-reconsidered draft-ietf-sidr-slurm - authors recently updated draft-ietf-sidr-adverse-actions - wglc imminent I think if there's no meaningful discussion on change for these between now and 9\/16\/2016 (Sept 16th) we will assume this list is correct. For documents in the 'move' list, if progress to publication happens 'good!'. For all documents in the 'stays' list: 1) we aim to have wglc by Seoul 2) publication requests started on as many as possible We plan to meet in Seoul, but not in Chicago (Mar 2017) where we expect the ops group to exist and meet. We can progress documents in SIDR after Seoul, but the WG should close out shortly after the new year. (or that's the goal). Thoughts? -chris"}
{"_id":"doc-en-sidr-ikgG7UUbaYR6xKJAl2C8t5HC8-A","title":"","text":"[sidr] FW: New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-18.txt\nThe source file of this draft was previously formatted in nroff. We have now converted it to xml. This new version submission is for that reason. The xml source facilitates listing and citation of references in the proper RFC style. It also makes editing a bit easier for any future revisions. Sriram -----Original Message----- From: internet-drafts@ietf.org [mailto:internet-drafts@ietf.org] Sent: Thursday, August 18, 2016 10:33 AM To: Matthew Lepinski <mlepinski@ncf.edu>; Sriram, Kotikalapudi (Fed) <kotikalapudi.sriram@nist.gov> Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-18.txt A new version of I-D, draft-ietf-sidr-bgpsec-protocol-18.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-ietf-sidr-bgpsec-protocol Revision: 18 Title: BGPsec Protocol Specification Document date: 2016-08-18 Group: sidr Pages: 35 URL: https:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-18.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Htmlized: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-18 Diff: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-18 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. The IETF Secretariat"}
{"_id":"doc-en-sidr-LOQgzbmeR2LtuU_TiTDvkDG61Bk","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-18.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-18.txt Pages : 35 Date : 2016-08-18 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-18 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-18 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-_iwGevVxjL9eO4wAwkME-zYRRd4","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-bgpsec-ops - ENDS: 2016-06-14\n (June 14 2016)\nmatthias, one more: Can you please replace \"Invalid\" by \"Not Valid\", because this is the notation defined in draft-ietf-sidr-bgpsec-protocol-17. done. randy"}
{"_id":"doc-en-sidr-S8YOXXEnGCJaSkw55UFT2aJdqMQ","title":"","text":"Re: [sidr] WGLC: draft-ietf-sidr-bgpsec-ops - ENDS: 2016-06-14\n (June 14 2016)\nHi Randy, one more: Can you please replace \"Invalid\" by \"Not Valid\", because this is the notation defined in draft-ietf-sidr-bgpsec-protocol-17. Thanks matthias On Thu, 16 Jun 2016, Matthias Waehlisch wrote: Hi, I read v09. No objections only minor comments: line 102: BGPsec need*s* *to* be spoken only line 104: s\/by small edge routers\/by resource constrained edge routers\/ line 119: *see* [RFC4271] line 159: s\/....\/etc.\/ lines 200-206 seem redudant to lines 208-213 line 202 s\/smallish\/resource constrained\/ line 215: I don't know where the 84% comes from, I suppose it's just a more or less arbitrary illustration of \"vast majority\". I would remove the number. line 234: I would be more explicit: \"How this is used in routing is up to the operator's local policy, similar to origin validation [RFC6811].\" lines 243-250: This paragraph confused me. What about: Operators should be aware that controlling Invalid announcements by local preference might be delusive. Local preference affects only routes to the same set of destinations. Consider having a Valid announcement from neighbor V for prefix 10.0.0.0\/16 and an Invalid announcement for 10.0.66.0\/24 from neighbor I. If the local policy on a router is configured to accept Invalid announcements, then both routes will be installed, no matter of the value of local preference. (Btw, I suppose that routes to .666 will be discarded anyway ;) line 252: It sounds that only edge routers are allowed to speak BGPsec. I would weaken and say \"Validation of signed paths is usually deployed at the eBGP edge.\" line 292: s\/BGPSEC_Path\/BGPsec_Path\/ lines 288-295: The paragraph seems to mix transparent operation and the question of validation. What about: A route server is usually 'transparent'. To operate transparently in an environment in which the route server connects BGPsec-enabled peers, the route server needs to run BGPsec as well. This implies that the route server creates signatures per client including its own AS in the BGPsec_Path and the target ASes. However, increasing the AS hop count reduces the likelihood of best path selection. See 2.2.2 of [I-D.ietf-idr-ix-bgp-route-server]. To overcome this problem, the route server uses pCount of zero to not increase the effective AS hop count. Furthermore, a BGPsec-aware route server needs to validate the incoming BGPsec_Path but should not drop invalids. In case the client speaks BGPsec the route server should just forward updates to clients which then validate . In case the client does not speak BGPsec, the route server reconstructs the AS_PATH and may signal the validation outcome using communities. line 300: s\/Routers should default to this knob disallowing pCount 0.\/Routers should disallow pCount 0 by default.\/ line 346: I would rephrase: \"Operators should deploy servers that provide time service, such as [RFC5905], to client routers.\" Cheers matthias On Wed, 15 Jun 2016, Sandra Murphy wrote: It is a short document. The sentences are not complicated. It reads quickly. There’s been little\/no wg comment on this, certainly no controversy, over the lifetime of the draft. But still. Please. Pretty please. Pretty please with sugar on top. Pretty please with a cherry on top. Could we get some feedback that this document is ready for publication? —Sandy, speaking as one of the wg co-chairs On Jun 8, 2016, at 10:19 PM, Sandra Murphy <sandy@tislabs.com> wrote: No responses at all. Come on folks. It’s a short document, like Chris says. You should be able to read and comment without much trouble. —Sandy, speaking as one of the wg co-chairs Howdy WG folks, Please take this note as the start of the 2wk WGLC period for: <https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops-07> Abstract: \"Deployment of the BGPsec architecture and protocols has many operational considerations. This document attempts to collect and present the most critical and universal. It is expected to evolve as BGPsec is formalized and initially deployed.\" This is a relatively short document, 8 pages, full of wonder and excitement! I hope that the wg members have read it (it's been through 8+ revisions) and that they will re-read it quickly, provide comments as appropriate and ideas on preparedness for publication or not. Thanks for you time and attention to this matter, -Chris co-chair-persona _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr -- Dr. Matthias Waehlisch . Freie Universitaet Berlin, Inst. fuer Informatik, AG CST . Takustr. 9, D-14195 Berlin, Germany .. mailto:m.waehlisch@fu-berlin.de .. http:\/\/www.inf.fu-berlin.de\/~waehl :. Also: http:\/\/inet.haw-hamburg.de .. http:\/\/www.link-lab.net"}
{"_id":"doc-en-sidr-9lU5ZkOQvAieq7DNEtlQxDy9tg8","title":"","text":"Re: [sidr] FW: I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt\nthanks! :) On Thu, Jun 23, 2016 at 10:42 AM, Sriram, Kotikalapudi (Fed) < kotikalapudi.sriram@nist.gov> wrote: Many thanks to John Scudder for a very careful review of version-15 of the draft. He offered an excellent set of editorial comments to the document editors and shepherd. His email came in literally milliseconds after I had uploaded version-16 two days ago. Matthias asked if the editors could make another pass at updating the draft in accordance with John's comments before he submits his shepherd report. The answer was - yes. This new version-17 incorporates John's comments (all editorial in nature). Sriram -----Original Message----- From: sidr [mailto:sidr-bounces@ietf.org] On Behalf Of internet-drafts@ietf.org Sent: Thursday, June 23, 2016 10:34 AM To: i-d-announce@ietf.org Cc: sidr@ietf.org Subject: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-17.txt Pages : 34 Date : 2016-06-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-17 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-17 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr thanks! :) Many thanks to John Scudder for a very careful review of version-15 of the draft. He offered an excellent set of editorial comments to the document editors and shepherd. His email came in literally milliseconds after I had uploaded version-16 two days ago. Matthias asked if the editors could make another pass at updating the draft in accordance with John's comments before he submits his shepherd report. The answer was - yes. This new version-17 incorporates John's comments (all editorial in nature). Sriram -----Original Message----- From: sidr [mailto:sidr-bounces@ietf.org] On Behalf Of internet-drafts@ietf.org Sent: Thursday, June 23, 2016 10:34 AM To: i-d-announce@ietf.org Cc: sidr@ietf.org Subject: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-17.txt Pages : 34 Date : 2016-06-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-17 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-17 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-QJD6FUi4GocMidsVeeN8FHafqZI","title":"","text":"[sidr] FW:  I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt\nMany thanks to John Scudder for a very careful review of version-15 of the draft. He offered an excellent set of editorial comments to the document editors and shepherd. His email came in literally milliseconds after I had uploaded version-16 two days ago. Matthias asked if the editors could make another pass at updating the draft in accordance with John's comments before he submits his shepherd report. The answer was - yes. This new version-17 incorporates John's comments (all editorial in nature). Sriram -----Original Message----- From: sidr [mailto:sidr-bounces@ietf.org] On Behalf Of internet-drafts@ietf.org Sent: Thursday, June 23, 2016 10:34 AM To: i-d-announce@ietf.org Cc: sidr@ietf.org Subject: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-17.txt Pages : 34 Date : 2016-06-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-17 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-17 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-PniCS_W9U5G8L471voo2jyCs6Bc","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-17.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-17.txt Pages : 34 Date : 2016-06-23 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via an optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-17 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-17 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-6x0JHGi2UKq-pKwO_3j8166DNCw","title":"","text":"[sidr] Fw:  I-D Action: draft-ietf-sidr-bgpsec-protocol-16.txt\nThis new version incorporates some editorial changes based on comments received from Matthias Waehlisch (shepherd for this document). All the references have been updated. In couple of places, there were repetitions of some sentences. That has also been fixed. Sriram ________________________________________ From: sidr <sidr-bounces@ietf.org> on behalf of internet-drafts@ietf.org <internet-drafts@ietf.org> Sent: Tuesday, June 21, 2016 4:24 PM To: i-d-announce@ietf.org Cc: sidr@ietf.org Subject: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-16.txt A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-16.txt Pages : 34 Date : 2016-06-21 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-16 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-16"}
{"_id":"doc-en-sidr-z5MS3uTvz7HUE8Ll7j5O3SQpzGA","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-16.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-16.txt Pages : 34 Date : 2016-06-21 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-16 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-16 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-Ws7aUS26IjmasdGQ0lR9llA17GA","title":"","text":"[sidr] Kathleen Moriarty's Discuss on\n draft-ietf-sidr-as-migration-05: (with DISCUSS and COMMENT)\nKathleen Moriarty has entered the following ballot position for draft-ietf-sidr-as-migration-05: Discuss When responding, please keep the subject line intact and reply to all email addresses included in the To and CC lines. (Feel free to cut this introductory paragraph, however.) Please refer to https:\/\/www.ietf.org\/iesg\/statement\/discuss-criteria.html for more information about IESG DISCUSS and COMMENT positions. The document, along with other ballot positions, can be found here: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-as-migration\/ ---------------------------------------------------------------------- DISCUSS: ---------------------------------------------------------------------- I'm wondering a few things that I think are important to discuss. If this is all fine, I may have more comments as I think I'll need to dig into the BGPsec draft first and then this one again. 1. Why is this document preceding the BGP spec? Shouldn't this be part of the BGPSec protocol document? If BGPSec isn't getting deployed because of the AS path migration problem and this gets us a little further, but not quite as secure, maybe that's a trade off we need to accept. But this document coming through first is a little concerning even though the protocol spec is a normative reference. 2. The introduction makes this sound rather innocuous, but the security considerations section is more explicit that this is a work around BGPSec and isn't quite as secure. I'd like to see some text explaining this better in the introduction, more similar to what's in the first paragraph of the security considerations section. See comments below too with some text. Sandy said she was working on this section as well, thanks for that! Thank you ---------------------------------------------------------------------- COMMENT: ---------------------------------------------------------------------- I think the Abstract & introduction are too brief. A lot of concerns might have been avoided with a little more explanation up front. --- Standards Track *is* right for this document, but it takes a little to understand that while the document doesn't make any changes to the protocol, it does describe how implementations use the protocol to deliver a specific function. --- Some rewording of the introduction could go a long way in helping with document clarity: Possibly: \"This document describes how ASN migration may be performed securely using the RPKI and BGPSec mechanisms. It defines the implementation behavior during ASN migration, but does not define any changes to the BGPSec protocol.\" *Note - if the last part remains true --- 1.2 refers to \"private ASNs\" and this term is well understood. But the referenced RFC 1930 doesn't use that term. It uses the term \"Reserved AS Numbers\" and describes them as \"reserved for private use\". --- Section 2 has \"...merging two or more ASNs...\" I think it is ASes that are being merged. Ditto \"...is not enabled between the ASNs...\" --- Section 3 has Since they are using methods to migrate that do not require coordination with customers, they do not have a great deal of control over the length of the transition period as they might with something completely under their administrative control I can't parse this. If the methods do NOT require coordination with customers, surely the methods are wholly under the control of the operator. Is there a typo: s\/do not require\/require\/ ? Or is there some other message? --- Section 3 As solutions were being proposed for RPKI implementations to solve this transition case, operational complexity and hardware scaling considerations associated with maintaining multiple legacy ASN keys on routers throughout the combined network have been carefully considered. As worded (passive voice) it demands a citation. Possibly it is meant to say that operators have carefully considered this. Maybe that the SIDR WG has done the consideration. --- Section 3 It would be helpful to add a final sentence saying what this section goes on to do. I think it examines the basic functions of RPKI to determine whether they already handle ASN migration and to identify any issues that might arise when an ASN changes. --- 3.1 Route Origin Validation as defined by RFC 6480 [RFC6480] does not need a unique solution to enable AS migration, as the existing protocol and procedure allows for a solution. That doesn't read too well to me at least, do you mean something like: Route Origin Validation as defined by RFC 6480 [RFC6480] does not need modification to enable AS migration, as the existing protocol and procedure allows for a solution as follows. --- 3.1 In the scenario discussed, AS64510 is being replaced by AS64500. s\/discussed\/discussed in RFC 7705\/ --- There are some abbreviations that will need to be expanded (e.g., ROA) --- 3.2.1 has... However, there is currently no guidance in the BGPSec protocol specification [I-D.ietf-sidr-bgpsec-protocol] on whether or not the forward-signed ASN value is required to match the configured remote AS to validate properly \"currently\" looks unlikely to change at this stage given the status of draft-ietf-sidr-bgpsec-protocol. So, either - make the changes to draft-ietf-sidr-bgpsec-protocol while you can or - change this text to reflect reality as... \"However, there is no guidance...\" --- 3.2.1 s\/remote as 64510\/remote AS 64510\/ s\/local as 64510\/local AS 64510\/ --- 3.2.1 It took me several attempts to parse... Assuming that this mismatch will be allowed by vendor implementations and using it as a means to solve this migration case is likely to be problematic. Did you mean: If we assume that this mismatch will be allowed by vendor implementations and that using it as a means to solve this migration case, then we are likely to see problems when implementations disallow the mismatch. --- 3.2.2 However, if the updates are left intact, this will cause the AS Path length to be increased, which is undesirable as discussed in RFC7705 [RFC7705]. On reading this I thought: \"Undesirable is OK for a short transition period,\" but I went and read 7705. There, in the introduction, it says \"it is critical that the ISP does not increase AS_PATH length during or after ASN migration\". So I would s\/is undesirable\/must be avoided\/ (Note: Section 4 has this as MUST NOT.) --- The text before the bullets in section 4 should... s\/listed in no particular order:\/listed in no particular order. BGPSec:\/ Then \"BGPSec\" can be deleted from the first bullet. --- In section 5... Since that PE has been moved to AS64500, it is not possible for it to forward-sign AS64510 with pCount=0 without some minor changes to the BGPSec implementation to address this use case. I know what this is saying, but it is a bit skewed since implementations are not normally in scope for our specs. Perhaps... Since that PE has been moved to AS64500, this described a new behavior for implementations to forward-sign AS64510 with pCount=0. --- Section 5 This document proposes applying a similar technique Too late! If this is to be an RFC on the Standards Track then This document describes how to apply a similar technique --- Section 5 has (see section 4.4 of the above-referenced draft) Really? Too tired to actually include the reference? But by the time this document is published the reference will be an RFC and this text will be left dangling. ---- 5.2 The requirement to sign updates in iBGP represents a change to the normal behavior for this specific AS-migration implementation only. s\/implementation\/scenario\/ --- I always love it when the Acknowledgements section thanks one of the authors :-) --- Section 8 This has happened before, but it usually leads the IESG to say \"Hang on, why don't you just fix the protocol spec?\" At the least, the Abstract and Introduction need to include the right text that would be present for an \"Update\". That is: what document is updated and what change is made. --- Section 9 Is \"reasonably secure\" should be replaced with something more accurate. Maybe this will come with the new text Sandy is working on. this is not fundamentally altering the existing security risks for BGPSec. That seems to say \"...is somewhat (or marginally) altering...\" which doesn't sound good. --- I hope the more detailed review is helpful. I still need to look at BGPsec to feel more comfortable with this one."}
{"_id":"doc-en-sidr-EnXQVaLsyVJ5ItXEYrJzLAkOIP8","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nThe wglc is ended and the wg consensus supports publication. The chairs will be requesting publication shortly. —Sandy, speaking as wg co-chair This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-xrAv7bf6q_uASyE0wwsMUVVytbM","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nOn Mon, Mar 28, 2016 at 8:54 AM Sean Turner <sean@sn3rd.com> wrote: I re-read the draft and looked at the diffs from -14 and I think this draft is ready to progress. Yup. I read it on the plane, looks goot to me. W spt On Mar 17, 2016, at 09:33, Sandra Murphy <sandra.murphy@parsons.com> wrote: This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr On Mon, Mar 28, 2016 at 8:54 AM Sean Turner <sean@sn3rd.com> wrote:I re-read the draft and looked at the diffs from -14 and I think this draft is ready to progress.Yup. I read it on the plane, looks goot to me.W spt This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-BFoP7_L7ccTEI7covMLhZm3muYo","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nOn Thu, 17 Mar 2016 09:33:41 -0400, Sandra Murphy <sandra.murphy@parsons.com> said: SM> This starts a two week wglc for draft-ietf-sidr-bgpsec-15. SM> The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. SM> Please respond with your opinion of the draft’s readiness for publication. SM> Remember that positive replies are needed, so please do provide comments to the list. SM> —Sandy, speaking as one of the wg co-chairs I have read the draft and I think it's good to go forward. -Mike -- Michael Baer baerm@tislabs.com PARSONS"}
{"_id":"doc-en-sidr-nSd6Mh2vqBNg11FdGjGIiuB7xVw","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nI re-read the draft and looked at the diffs from -14 and I think this draft is ready to progress. spt This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-8TUaw-CtZF5WYKKIDDtcP6_gpt4","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nShip it. Thanks, Wes This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr ________________________________ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-Cr7113k6et0LqbVKqvUgjTlh_8k","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-15\nMatt, Thank you for incorporating the proposed changes regarding the Sequence of Octets to be Hashed. I looked over it and it looks good, Oliver This starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-wUWNbmsWRPJoOohUoTSiuaOfpf4","title":"","text":"[sidr] wglc for draft-ietf-sidr-bgpsec-15\nThis starts a two week wglc for draft-ietf-sidr-bgpsec-15. The draft is available at https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15. Please respond with your opinion of the draft’s readiness for publication. Remember that positive replies are needed, so please do provide comments to the list. —Sandy, speaking as one of the wg co-chairs"}
{"_id":"doc-en-sidr-2CPggct-3yuxPQPqb5pWb5Wb5L8","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-15.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing of the IETF. Title : BGPsec Protocol Specification Authors : Matthew Lepinski Kotikalapudi Sriram Filename : draft-ietf-sidr-bgpsec-protocol-15.txt Pages : 34 Date : 2016-03-16 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-15 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-15 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-kewpBK6yl6LDK4olGAYySlXQ8GE","title":"","text":"Re: [sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nI haven't seen any objections to this change on the list. I suspect that the benefits from this change are modest. However, I am happy to see us make a couple of small changes that will make things a bit easier for implementers. I have made the changes Oliver suggested in the next version of the document. I just need to roll in a few last editorial suggestions and then I will toss the new version into the draft repository. Thanks again to Oliver for providing this feedback. - Matt Lepinski On Wed, Feb 24, 2016 at 7:55 PM, Sean Turner <sean@sn3rd.com> wrote: Right - so after re-reading this I see it now. spt On Feb 24, 2016, at 11:19, Borchert, Oliver <oliver.borchert@nist.gov> wrote: Sean, The change relates to the \"Sequence of Octets to be Signed\" (SOS), not the signature blocks on the wire. For validation and signing, one needs to generate a separate SOS per algorithm \/ signature block which is the same as it always was - nothing changed here. The resulting signature (while signing) will be added to the appropriate signature block, and algorithm transfers are still dealt with in the same manner as before. I hope that helps. Oliver On 2\/23\/16, 10:07 PM, \"Sean Turner\" <sean@sn3rd.com> wrote: Oliver & Michael, I see that the Algorithm Suite Identifier is now included just once, which saves one byte per signature segment, and that’s great, but how’s this new structure going to work if there’s an an algorithm transition? How will you support indicating the “old” and “new” algorithm? spt On Feb 10, 2016, at 15:05, Borchert, Oliver <oliver.borchert@nist.gov> wrote: Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr I haven't seen any objections to this change on the list. I suspect that the benefits from this change are modest. However, I am happy to see us make a couple of small changes that will make things a bit easier for implementers. I have made the changes Oliver suggested in the next version of the document. I just need to roll in a few last editorial suggestions and then I will toss the new version into the draft repository.Thanks again to Oliver for providing this feedback.- Matt LepinskiOn Wed, Feb 24, 2016 at 7:55 PM, Sean Turner <sean@sn3rd.com> wrote:Right - so after re-reading this I see it now. spt On Feb 24, 2016, at 11:19, Borchert, Oliver <oliver.borchert@nist.gov> wrote: Sean, The change relates to the \"Sequence of Octets to be Signed\" (SOS), not the signature blocks on the wire. For validation and signing, one needs to generate a separate SOS per algorithm \/ signature block which is the same as it always was - nothing changed here. The resulting signature (while signing) will be added to the appropriate signature block, and algorithm transfers are still dealt with in the same manner as before. I hope that helps. Oliver On 2\/23\/16, 10:07 PM, \"Sean Turner\" <sean@sn3rd.com> wrote: Oliver & Michael, I see that the Algorithm Suite Identifier is now included just once, which saves one byte per signature segment, and that’s great, but how’s this new structure going to work if there’s an an algorithm transition? How will you support indicating the “old” and “new” algorithm? spt Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-dMIZVVYc70v0ZYbjybbYSzKmO0s","title":"","text":"Re: [sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nRight - so after re-reading this I see it now. spt On Feb 24, 2016, at 11:19, Borchert, Oliver <oliver.borchert@nist.gov> wrote: Sean, The change relates to the \"Sequence of Octets to be Signed\" (SOS), not the signature blocks on the wire. For validation and signing, one needs to generate a separate SOS per algorithm \/ signature block which is the same as it always was - nothing changed here. The resulting signature (while signing) will be added to the appropriate signature block, and algorithm transfers are still dealt with in the same manner as before. I hope that helps. Oliver On 2\/23\/16, 10:07 PM, \"Sean Turner\" <sean@sn3rd.com> wrote: Oliver & Michael, I see that the Algorithm Suite Identifier is now included just once, which saves one byte per signature segment, and that’s great, but how’s this new structure going to work if there’s an an algorithm transition? How will you support indicating the “old” and “new” algorithm? spt Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-ettDlvku43XxRuk7hW5QDEf0vb8","title":"","text":"Re: [sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nOn Tue, 23 Feb 2016 22:07:45 -0500, Sean Turner <sean@sn3rd.com> said: Sean> Oliver & Michael, Sean> I see that the Algorithm Suite Identifier is now included just once, Sean> which saves one byte per signature segment, and that’s great, but Sean> how’s this new structure going to work if there’s an an algorithm Sean> transition? How will you support indicating the “old” and “new” Sean> algorithm? Sean> spt I'm afraid that I'm not understanding the problem. Except for the reordering of data in the Secure_Path segments, the bits on the wire haven't changed in the proposal. The algorithm suite ID is still in the signature_block header. In draft 14, the algorithm suite ID is included as part of the entire signature_block in the sequence of octets to be signed (SOS) for each signature. The algo suite ID is also include in the SOS of each signature in the current proposal. I believe that the only information not signed over in the proposed SOS that was signed in draft 14's SOS (although not in previous drafts) is the Signature_Block length and the Secure_Path length. I don't think there would be any change in algorithm suite transition. -Mike >> >> >> Hello Matt, >> >> after reading version 14 of the BGPSec protocol draft and after discussing the >> update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) >> want to propose some changes for generation of the “Sequence of Octets to be >> Signed” (SOS) in the draft on pg. 15. This change would modify the order of >> information within the SOS as well as the order of attributes within the >> “Secure_Path” Segment listed on pg. 8. >> >> For your convenience I attached this email as pdf document as well. >> >> NONE of the changes has any impact on the information that is put on the wire >> in regards to adding or removing data. The only on the wire change is the >> ordering of the attributes within the Secure_Path Segment. >> >> As we are all aware, the most expensive operation within the BGPSEC protocol is >> the crypto operation, especially the Path verification. >> With the proposed modification of the SOS, implementers will be able to utilize >> more efficient and higher performing software mechanisms to validate the >> complete chain of signatures in an update. The current form makes this more >> difficult. >> >> Our request does remove some data from the previous SOS structure, changes the >> order of the remaining attributes within the SOS and includes the re-ordering >> of one data segment on the wire, which will facilitate the SOS generation. >> >> >> 1) Request for re-ordering the Secure_Path segment >> The first request deals with modifying the order of the Secure_Path segment. >> This modification will become more obvious later on when we explain our request >> for changes in the structure of “Sequence of Octets to be Signed” (SOS) on >> pg. 15. >> This is also the only change that has an affect on the data on the “wire” but >> again only regarding the order itself, NOT the content. >> >> The current format as it is shown on pg. 8 is as follows: >> >> +-------------------------------+ >> | AS Number (4 octets) | >> +-------------------------------+ >> | pCount (1 octet) | >> +-------------------------------+ >> | Flags (1 octet) | >> +-------------------------------+ >> >> We request to move the “AS Number” field to the end of the signature segment. >> This results in the following structure: >> >> +-------------------------------+ >> | pCount (1 octet) | >> +-------------------------------+ >> | Flags (1 octet) | >> +-------------------------------+ >> | AS Number (4 octets) | >> +-------------------------------+ >> >> The reason for this minor change becomes more clear when we explain our request >> for modifying the SOS structure. But as a little preview for where we want to >> go with this, consider the following: >> >> Having a set of Secure_Path segments, the last field of the following segment >> equals the “Target AS” needed in the SOS structure. But this becomes more >> obvious later on. >> >> >> 2) Modifying the SOS structure” >> >> The current structure as it is presented on pg. 15 of draft-14 is as follows: >> >> +-------------------------------+ >> | Target AS Number | >> +-------------------------------+ >> | AS Number | >> +-------------------------------+ >> | pCount | >> +-------------------------------+ >> | Flags | >> +-------------------------------+ >> | Previous Secure_Path | >> +-------------------------------+ >> | Previous Signature_Block | >> +-------------------------------+ >> | AFI | >> +-------------------------------+ >> | SAFI | >> +-------------------------------+ >> | NLRI | >> +-------------------------------+ >> >> This structure is very inefficient for signature validation because for each >> signature validation the structure needs to be newly regenerated. >> >> One major change in version-14 compared to the preceding drafts is the >> inclusion of all previous signatures to the SOS structure. In the previous >> draft only the directly preceding signature was part of the SOS. Version-14 >> introduces an additional overhead of approximately 91-93 bytes (69-71 for >> signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. >> >> This means that verifying a 10 hop path, the following additional overhead for >> signatures must be added to each SOS in comparison to draft 13: >> >> (assumed 92 bytes on average per signature) >> >> SOS overhead 10 signatures: +828 bytes >> SOS overhead 9 signatures: +736 bytes >> SOS overhead 8 signatures: +644 bytes >> SOS overhead 7 signatures: +552 bytes >> SOS overhead 6 signatures: +460 bytes >> SOS overhead 5 signatures: +368 bytes >> SOS overhead 4 signatures: +276 bytes >> SOS overhead 3 signatures: +184 bytes >> SOS overhead 2 signatures: + 92 bytes >> >> For sequential verification only the maximum memory overhead comes into place >> because each consecutive verification will have an SOS size less then the >> previous one. >> For parallel verification though each verification itself requires the >> necessary memory overhead to the SOS which will end up with: >> >> Cumulative overhead for a 10 hop path: 4,140 bytes >> >> And this is only the additional memory consumption added with the signatures. >> On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 >> bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for >> algo ID. >> >> Depending where the data is located during the hash generation (e.g. L2 cache) >> the additional memory accesses could further hinder performance and negatively >> affect convergence time. >> >> Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path >> Length and Signature_Block Length, both of which are overwritten at each hop. >> This imposes the additional burden of regenerating these length fields for the >> SOS corresponding to each signature verification. This again means that each >> parallel working thread is required to generate its own SOS for signature >> validation (see earlier discussion). Hence, it is not desirable to include >> these length fields in the SOS at the sender. Removing these will not create a >> security risk. >> >> The idea is to generate an SOS that can be re-used so that it only has to be >> generated once and then can be utilized without any modification for all >> signature verifications within an update – regardless if sequential or parallel >> processing is used. >> >> >> The proposed modification will result in the following SOS structure: >> For simplification we combine the signature and path segments shown below into >> a combined segment (in the SOS): >> >> +----------------------------+ >> | SKI (n-1) |\\ >> +----------------------------+ \\ >> | Signarture Length (n-1) |--- Signature Segment (n-1) >> +----------------------------+ \/ >> | Signature (n-1) |\/ >> +----------------------------+ >> | pCount (n) |\\ >> +----------------------------+ \\ >> | Flags (n) |--- Secure_Path Segment (n) >> +----------------------------+ \/ >> | AS Number (n) |\/ >> +----------------------------+ >> >> The simplification in imploded form looks as follows: >> >> +----------------------------+ >> | Signature Segment (n-1) | >> +----------------------------+ >> | Secure_Path Segment (n) | >> +----------------------------+ >> >> Proposed SOS Structure: (See example on next page for n=3) >> >> +---------------------------------------+ >> | Target AS Number | >> +---------------------------------------+\\ >> | Signature Segment (n-1) | \\ >> +---------------------------------------+ | >> | Secure_Path Segment (n) | | >> +---------------------------------------+ \\ >> ... > For n Hops >> +---------------------------------------+ \/ >> | Signature Segment (1 origin) | | >> +---------------------------------------+ | >> | Secure_Path Segment (2) | \/ >> +---------------------------------------+\/ >> | Secure_Path Segment (1 origin) | >> +---------------------------------------+ >> | Algorithm Suite Identifier | >> +---------------------------------------+ >> | AFI | >> +---------------------------------------+ >> | SAFI | >> +---------------------------------------+ >> | NLRI | >> +---------------------------------------+ >> >> This structure allows the generation of one single SOS that can be accessed >> simultaneously by multiple threads (one for each signature verification). >> >> With this structure an update containing 10 Signatures contains the same >> overhead of +828 bytes but here it does not need to be re-generated for each >> signature validation. Independent of whether the validation is performed >> sequential or parallel, the overhead remains the same and will NOT grow to an >> extra 4,140 bytes as outlined earlier. This will result in a net saving of >> +3,312 bytes for a path with 10 signatures in addition to the time saved >> generating the SOS for each validation separately. >> >> Example for generation and processing the new proposed SOS structure for a >> signed path from AS1 to AS4: >> AS1—AS2—AS3-AS4 >> >> +----------------------+ >> SOS 3----->| AS 4 | <- (Target AS for signature 3) >> | +----------------------+ >> | | Signature_Segment (2)| >> | +----------------------+ >> | | pCount (3)| \\ >> | +----------------------+ \\ >> | | Flags (3)| --- Secure_Path Segment (3) >> | +----------------------+ \/ >> SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) >> | | +----------------------+ >> | | | Signature_Segment (1)| >> | | +----------------------+ >> | | | pCount (2)| \\ >> | | +----------------------+ \\ >> | | | Flags (2)| --- Secure_Path Segment (2) >> | | +----------------------+ \/ >> SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) >> | | | +----------------------+ >> | | | | pCount (1)| \\ >> | | | +----------------------+ \\ >> | | | | Flags (1)| --- Secure_Path Segment (origin) >> | | | +----------------------+ \/ >> | | | | AS 1 (1)| \/ >> | | | +----------------------+ >> | | | | Algorithm Suite ID | >> | | | +----------------------+ >> | | | | AFI | >> | | | +----------------------+ >> | | | | SAFI | >> | | | +----------------------+ >> | | | | NLRI | >> END +-+-+>+----------------------+ >> >> >> As one can clearly observe the receiver needs only to generate one single >> SOS and can utilize it for validation of all previous signatures without >> the need to regenerate the SOS at each step. >> >> Better even, the new SOS allows: >> - sequential validation processing without the need to regenerate the >> SOS data for each validation process; just use pointer arithmetic to >> specify start of the structure >> - parallel validation processing using the same memory location. >> >> >> >> Thanks, >> >> Oliver Borchert (NIST) & Michael Baer (PARSONS) >> >> >> <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ >> sidr mailing list >> sidr@ietf.org >> https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Sean> _______________________________________________ Sean> sidr mailing list Sean> sidr@ietf.org Sean> https:\/\/www.ietf.org\/mailman\/listinfo\/sidr -- Michael Baer baerm@tislabs.com Senior Software Engineer Parsons Global Shared Services, Cyber Security Division C: 530.902.3131"}
{"_id":"doc-en-sidr-LC5CtU0HsBWNns9_pnLwG4mOknE","title":"","text":"Re: [sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nSean, The change relates to the \"Sequence of Octets to be Signed\" (SOS), not the signature blocks on the wire. For validation and signing, one needs to generate a separate SOS per algorithm \/ signature block which is the same as it always was - nothing changed here. The resulting signature (while signing) will be added to the appropriate signature block, and algorithm transfers are still dealt with in the same manner as before. I hope that helps. Oliver On 2\/23\/16, 10:07 PM, \"Sean Turner\" <sean@sn3rd.com> wrote: Oliver & Michael, I see that the Algorithm Suite Identifier is now included just once, which saves one byte per signature segment, and that’s great, but how’s this new structure going to work if there’s an an algorithm transition? How will you support indicating the “old” and “new” algorithm? spt Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-2eZ36RYD5jdTwzICUipbNDU3zok","title":"","text":"Re: [sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nOliver & Michael, I see that the Algorithm Suite Identifier is now included just once, which saves one byte per signature segment, and that’s great, but how’s this new structure going to work if there’s an an algorithm transition? How will you support indicating the “old” and “new” algorithm? spt Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) <BGPSEC-Draft14-ChangeRequest.pdf>_______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-8B_e4CNxQCUKeZ_AUzsdnn2f5MU","title":"","text":"[sidr] Modifiation request: draft-ietf-sidr-bgpsec-protocol-14\nHello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS) Hello Matt, after reading version 14 of the BGPSec protocol draft and after discussing the update between us, Michael Baer (BIRD implementer) and I (Quagga Implementer) want to propose some changes for generation of the “Sequence of Octets to be Signed” (SOS) in the draft on pg. 15. This change would modify the order of information within the SOS as well as the order of attributes within the “Secure_Path” Segment listed on pg. 8. For your convenience I attached this email as pdf document as well. NONE of the changes has any impact on the information that is put on the wire in regards to adding or removing data. The only on the wire change is the ordering of the attributes within the Secure_Path Segment. As we are all aware, the most expensive operation within the BGPSEC protocol is the crypto operation, especially the Path verification. With the proposed modification of the SOS, implementers will be able to utilize more efficient and higher performing software mechanisms to validate the complete chain of signatures in an update. The current form makes this more difficult. Our request does remove some data from the previous SOS structure, changes the order of the remaining attributes within the SOS and includes the re-ordering of one data segment on the wire, which will facilitate the SOS generation. 1) Request for re-ordering the Secure_Path segment The first request deals with modifying the order of the Secure_Path segment. This modification will become more obvious later on when we explain our request for changes in the structure of “Sequence of Octets to be Signed” (SOS) on pg. 15. This is also the only change that has an affect on the data on the “wire” but again only regarding the order itself, NOT the content. The current format as it is shown on pg. 8 is as follows: +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ We request to move the “AS Number” field to the end of the signature segment. This results in the following structure: +-------------------------------+ | pCount (1 octet) | +-------------------------------+ | Flags (1 octet) | +-------------------------------+ | AS Number (4 octets) | +-------------------------------+ The reason for this minor change becomes more clear when we explain our request for modifying the SOS structure. But as a little preview for where we want to go with this, consider the following: Having a set of Secure_Path segments, the last field of the following segment equals the “Target AS” needed in the SOS structure. But this becomes more obvious later on. 2) Modifying the SOS structure” The current structure as it is presented on pg. 15 of draft-14 is as follows: +-------------------------------+ | Target AS Number | +-------------------------------+ | AS Number | +-------------------------------+ | pCount | +-------------------------------+ | Flags | +-------------------------------+ | Previous Secure_Path | +-------------------------------+ | Previous Signature_Block | +-------------------------------+ | AFI | +-------------------------------+ | SAFI | +-------------------------------+ | NLRI | +-------------------------------+ This structure is very inefficient for signature validation because for each signature validation the structure needs to be newly regenerated. One major change in version-14 compared to the preceding drafts is the inclusion of all previous signatures to the SOS structure. In the previous draft only the directly preceding signature was part of the SOS. Version-14 introduces an additional overhead of approximately 91-93 bytes (69-71 for signature + 20 SKI + 2 signature length) or ~92 extra bytes per Signature. This means that verifying a 10 hop path, the following additional overhead for signatures must be added to each SOS in comparison to draft 13: (assumed 92 bytes on average per signature) SOS overhead 10 signatures: +828 bytes SOS overhead 9 signatures: +736 bytes SOS overhead 8 signatures: +644 bytes SOS overhead 7 signatures: +552 bytes SOS overhead 6 signatures: +460 bytes SOS overhead 5 signatures: +368 bytes SOS overhead 4 signatures: +276 bytes SOS overhead 3 signatures: +184 bytes SOS overhead 2 signatures: + 92 bytes For sequential verification only the maximum memory overhead comes into place because each consecutive verification will have an SOS size less then the previous one. For parallel verification though each verification itself requires the necessary memory overhead to the SOS which will end up with: Cumulative overhead for a 10 hop path: 4,140 bytes And this is only the additional memory consumption added with the signatures. On top of that comes the prefix information {AFI, SAFI, NLRI} -> (5...21 bytes), Path information {AS, pCount, Flags} -> 6 bytes each, and 1 byte for algo ID. Depending where the data is located during the hash generation (e.g. L2 cache) the additional memory accesses could further hinder performance and negatively affect convergence time. Furthermore, the newly proposed (version-14 draft) SOS includes Secure_Path Length and Signature_Block Length, both of which are overwritten at each hop. This imposes the additional burden of regenerating these length fields for the SOS corresponding to each signature verification. This again means that each parallel working thread is required to generate its own SOS for signature validation (see earlier discussion). Hence, it is not desirable to include these length fields in the SOS at the sender. Removing these will not create a security risk. The idea is to generate an SOS that can be re-used so that it only has to be generated once and then can be utilized without any modification for all signature verifications within an update – regardless if sequential or parallel processing is used. The proposed modification will result in the following SOS structure: For simplification we combine the signature and path segments shown below into a combined segment (in the SOS): +----------------------------+ | SKI (n-1) |\\ +----------------------------+ \\ | Signarture Length (n-1) |--- Signature Segment (n-1) +----------------------------+ \/ | Signature (n-1) |\/ +----------------------------+ | pCount (n) |\\ +----------------------------+ \\ | Flags (n) |--- Secure_Path Segment (n) +----------------------------+ \/ | AS Number (n) |\/ +----------------------------+ The simplification in imploded form looks as follows: +----------------------------+ | Signature Segment (n-1) | +----------------------------+ | Secure_Path Segment (n) | +----------------------------+ Proposed SOS Structure: (See example on next page for n=3) +---------------------------------------+ | Target AS Number | +---------------------------------------+\\ | Signature Segment (n-1) | \\ +---------------------------------------+ | | Secure_Path Segment (n) | | +---------------------------------------+ \\ ... > For n Hops +---------------------------------------+ \/ | Signature Segment (1 origin) | | +---------------------------------------+ | | Secure_Path Segment (2) | \/ +---------------------------------------+\/ | Secure_Path Segment (1 origin) | +---------------------------------------+ | Algorithm Suite Identifier | +---------------------------------------+ | AFI | +---------------------------------------+ | SAFI | +---------------------------------------+ | NLRI | +---------------------------------------+ This structure allows the generation of one single SOS that can be accessed simultaneously by multiple threads (one for each signature verification). With this structure an update containing 10 Signatures contains the same overhead of +828 bytes but here it does not need to be re-generated for each signature validation. Independent of whether the validation is performed sequential or parallel, the overhead remains the same and will NOT grow to an extra 4,140 bytes as outlined earlier. This will result in a net saving of +3,312 bytes for a path with 10 signatures in addition to the time saved generating the SOS for each validation separately. Example for generation and processing the new proposed SOS structure for a signed path from AS1 to AS4: AS1—AS2—AS3-AS4 +----------------------+ SOS 3----->| AS 4 | <- (Target AS for signature 3) | +----------------------+ | | Signature_Segment (2)| | +----------------------+ | | pCount (3)| \\ | +----------------------+ \\ | | Flags (3)| --- Secure_Path Segment (3) | +----------------------+ \/ SOS 2----+>| AS 3 (3)| \/ <- (Target AS for signature 2) | | +----------------------+ | | | Signature_Segment (1)| | | +----------------------+ | | | pCount (2)| \\ | | +----------------------+ \\ | | | Flags (2)| --- Secure_Path Segment (2) | | +----------------------+ \/ SOS 1--+-+>| AS 2 (2)| \/ <- (Target AS for signature 1) | | | +----------------------+ | | | | pCount (1)| \\ | | | +----------------------+ \\ | | | | Flags (1)| --- Secure_Path Segment (origin) | | | +----------------------+ \/ | | | | AS 1 (1)| \/ | | | +----------------------+ | | | | Algorithm Suite ID | | | | +----------------------+ | | | | AFI | | | | +----------------------+ | | | | SAFI | | | | +----------------------+ | | | | NLRI | END +-+-+>+----------------------+ As one can clearly observe the receiver needs only to generate one single SOS and can utilize it for validation of all previous signatures without the need to regenerate the SOS at each step. Better even, the new SOS allows: - sequential validation processing without the need to regenerate the SOS data for each validation process; just use pointer arithmetic to specify start of the structure - parallel validation processing using the same memory location. Thanks, Oliver Borchert (NIST) & Michael Baer (PARSONS)"}
{"_id":"doc-en-sidr-qh5i8DcVzE0FfcfuYnnD3gHbdbQ","title":"","text":"[sidr] comments on draft-ietf-sidr-bgpsec-protocol-14 -- editorial\nMatt, I hope you find these comments helpful. Comments\/Suggestions to help improve clarity\/presentation: -----------------------------------------------------¬-------------------------- Page 3, 3rd para: add [20] next to [19]; both are relevant references. Page 5, 1st para: s\/…for the same AFI combination…\/…for the same AFI …\/ Page 8, 1st para: s\/(i.e., the number of AS numbers in the path)\/ (i.e., the number of distinct AS numbers in the path)\/ Page 14, 1st para: At the end of this para, within the parentheses, I suggest adding: See Section 4.4 for an algorithm for reconstruction of AS_PATH attribute. Page 15: 2nd last para: s\/…populated with the length (in octets) of the Signature field\/ …populated with the length (in octets) of the value in the Signature field\/ Page 17, 2nd para from bottom: s\/ …if the next most recently added Secure_Path segment…\/ …if the immediately following Secure_Path segment…\/ Note that \"next most recently added Secure_Path segment\" connotes \"immediately preceding Secure_Path segment\" (i.e. going backward in time). It seems to me, that is not what was intended here. Page 18, 1st para: At the end, add the following: (see Section 5.2). Page 18, please append the following at the end of the 1st para: Before attempting to reconstruct an AS_PATH for the purpose of forwarding an unsigned (non-BGPsec) update to a peer, a BGPsec speaker MUST perform the basic integrity checks listed in Section 5.2 to ensure that the received BGPsec update is properly formed. Page 19, last para: s\/ via the RTR protocol\/ via the RPKI-to-Router (RTR) protocol [15]\/ Pages 20-21, Section 5.1: The mention of ROA and the second bullet item (top of page 21) are not needed here, because ROA is not used in BGPsec validation (origin validation does that). Page 22, last para: \"If there is no Signature_Block corresponding to an algorithm suite that the BGPsec speaker supports, then the BGPsec speaker MUST treat the update message in the same manner that the BGPsec speaker would treat an (unsigned) update…\" Note that the former (without supported algorithm suite) is not the same as unsigned, so they cannot be treated in the same manner. So I think it would be more precise to say it the following way: \"If there is no Signature_Block corresponding to an algorithm suite that the BGPsec speaker supports, then the BGPsec speaker MUST process the update message as follows: First, convert the Secure_PATH attribute to AS_PATH attribute, and then treat the update as if it was received unsigned (non-BGPsec).\" Page 23, in the Figure: s\/Rest of Secure_Path\/Preceding portion of Secure_Path\/ Note that \"Rest of Secure Path\" implies Secure_Path segments before and after the current one. Minor modifications in the text on page 24 also need to be made, wherever \"Rest of Secure_Path\" is mentioned. Page 25 (1st full para): \"If at least one Signature_Block is marked as 'Valid', then the validation algorithm terminates and the BGPsec update message is deemed to be 'Valid'. (That is, if a BGPsec update message contains two Signature_Blocks then the update message is deemed 'Valid' if the first Signature_Block is marked 'Valid' OR the second Signature_Block is marked 'Valid'.)\" I think we cannot say here \"…BGPsec update message is deemed to be 'Valid'.\" This document only specifies validation for Signature_Block (or Secure_Path). It is up to the operator to combine the result of RFC6811 (origin validation) with the results of this document (path validation) to decide about the overall validity of the BGPsec update message. So, instead of \"is deemed to be 'Valid' \", should we say \"is deemed to be 'Path Valid' \"? Page 27, 1st paragraph (below the bullet): \"That is, the recipient of a valid BGPsec Update message is assured that the Secure_Path portion of the BGPsec_Path attribute corresponds to a sequence of autonomous systems who have all agreed in principle to forward packets to the given prefix along the indicated path. (It should be noted that BGPsec does not offer any guarantee that the data packets would flow along the indicated path; it only guarantees that the BGP update conveying the path indeed propagated along the indicated path.)\" I find the first sentence problematic. In essence, it contradicts the second sentence. The first sentence says BGPsec assures something about the data plane. The second sentence says BGPsec does not guarantee anything about the data plane! I would reword the first sentence as follows: \"That is, the recipient of a valid BGPsec update message is assured that the update propagated via the sequences ASes listed in the Secure_Path portion of the BGPsec_Path attribute.\" Page 27, 1st paragraph (below the bullet), in the last sentence: s\/ the recipient is assured that this path terminates...\/ the recipient is assured, due to origin validation, that this path terminates…\/ Note: I suggest this wording because BGPsec does not provide this particular assurance; origin validation does. Page 30, 2nd para (last para of Section 7.4): This appears to be a carryover from v.13 draft since it refers to old Sections 4.1 and 4.2. It is also worth noting that the extremely unlikely attack being mentioned here is made even more unlikely due to more data that needs to be signed over at the second AS (based on this v-14 draft). =========== Typos, Nits: --------------- Page 12, 3rd para: s\/…update message has not been that has not successfully validated\/ …update message has not been successfully validated\/ Page 15, 1st para: same sentence twice in the same para … \"the Target AS Number is the AS to whom the BGPsec speaker intends to send the update message\" Similar sentence appeared earlier in the same para at bottom of page 14). Page 16, 1st para: The following phrase is repeated twice in the same para: \"when a confederation member sends a BGPsec update message to a peer that is a member of the same confederation\" Page 16, 1st para: The following phrase is repeated twice in the same sentence (last sentence): \"in a non-BGPsec update message\" Page 25, 2nd para in Section 6.1: s\/a mandatory algorithm suites document will be created\/ a mandatory algorithm suites document exists\/ References: [9] should have date of November 2015 (it shows Nov. 2014). Page 17 and p.22: s\/RFC WXYZ\/RFC 7606\/ Global substitution: s\/AS_Path\/AS_PATH\/g Global substitution: s\/BGPSEC\/BGPsec\/g Thank you. Sriram"}
{"_id":"doc-en-sidr-VkHpHbJIL0X5AcdL3uuiINaBrCE","title":"","text":"[sidr] comments on draft-ietf-sidr-bgpsec-protocol-14 -- data\n covered by signature\nHappy New Year! I have given it (version 14) a complete read. Thanks, Matt, once gain for all your efforts. My comments are split over two posts. This is the first post that seeks to clarify a technical point. My second post will have comments\/suggestions to help improve the clarity\/presentation in the document, and also lists some typos and nits. The following were the three possibilities for a protocol change to address the problem that David identified: 1. Signature protects the Target ASN, {ASN, pCounts, Flags} of the signer, Previous Secure_Path, and {AFI, SAFI, NLRI}. 2. Signature protects all of the data in #1 and the most recently added Signature_Segment (i.e. that of the eBGPsec speaker from whom the update was received). 3. Signature protects all of the data in #1 and the Previous Signature_Block (i.e. all previous Signature_Segments). David initially proposed #1. http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07258.html Following on that, Rob made a case for #2. http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07261.html I don’t think #3 was discussed in that thread. Nevertheless it is a solution candidate. #3 is what Matt has included in the revised draft. The relative merits of #2 and #3 are worth a little discussion. One thing to note is that ECDSA-P256 signature length is about 72 octets (including DER (ASN1) format overheads); plus 22 octets for SKI and Sig length. So a total of 94 octets of additional data (per signature) is to be included in the hashed data at BGPsec routers. In the case of #2, the *additional data* to be hashed would be a constant at 94 octets, (independent of the AS path length), while in the case of #3, it would be variable given by #AS (i.e. previous path length) x 94 octets. So, for example, 940 octets more (for #3 over #2) if the previous AS path length is 10. Is this of concern? One good thing is that the Signature_Segments to be added to the hashed data are adjacent (that helps in consideration of #3). Adjacency helps with lowering # CPU cycles consumed for marshaling the data for hash (for #3). We have preliminary measurement data which shows that the performance for SHA-256 hash operations on Intel NUC 3GHz (single threading) is as follows: (we will be conducting this study also on a 3.5 GHz server with a lot more RAM): Hash input data size | time per SHA-256 hash operation | hash operation speed | 50 octets | 0.34 usec | 2,923,662 hash ops\/s 100 octets | 0.58 usec | 1,716,556 hash ops\/s 500 octets | 2.02 usec | 493,969 hash ops\/s 1000 octets | 3.93 usec | 254,462 hash ops\/s 5000 octets | 17.21 usec | 58,109 hash ops\/s (Averaged over 1000 iterations; usec = microseconds) For a long previous-AS-path length of 10, with the choice of #2, we’ll be in 300 octets ballpark for hashed data size, and with the choice of #3, we’ll be around 1200 octets ballpark for hashed data size. So, to me it looks like #3 choice does not have a significant penalty over #2 choice in terms the performance of hashing operations for the range of hashed data sizes of our interest. It is true that the hash processing time more than doubles for #3 compared to #2 in the hash data size ranges of interest. However, since all other BGPsec update processing is likely to dominate over the hash processing time, the concern with regard to hash performance may not be huge when comparing #3 with #2. The adjacency assumption of the multiple Signature_Segments for hashing is important for #3, and should hold (hopefully) in the implementations. Your thoughts\/inputs on the merits\/trade-offs of #2 vs. #3? Please share them. Thank you. Sriram"}
{"_id":"doc-en-sidr-WCqMTqBW1sfbwHr5-fhCNyMG_v0","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-14.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPsec Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-14.txt Pages : 34 Date : 2015-12-08 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-14 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-14 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-4U9Ky6oZ2XkuNFmuAvNIlUHD7wA","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-13.txt\nAh, I see. I agree your interpretation is the correct one. So no change is necessary. Thank you. Sriram ________________________________________ From: Sandra Murphy <sandy@tislabs.com> Sent: Saturday, October 17, 2015 11:30 AM To: Sriram, Kotikalapudi Cc: Sandra Murphy; Matthew Lepinski; sidr wg list Subject: Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-13.txt speaking as a regular ol’ member Substantive comment .... Looking at this on page 23, \"BGPsec update messages do not contain an AS_PATH attribute. Therefore, a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute. The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" What is being said in the second sentence above is not clear. No exception applies if the peer is BGPsec capable and negotiated BGPsec. So is the exception for the case when the peer is non-BGPsec? May the fix is to replace this (current): \"The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" with the following (proposed): The only exception to this rule is when AS path information must be re-formatted to AS_PATH in order to propagate a route to a non-BGPsec peer (in which case the BGPsec speaker follows the instructions in Section 4.4). I read that sentence differently. When BGP is propagating a route to a neighbor, it ordinarily appends its AS to the AS_PATH. The “in all cases” would imply the same would happen in BPGsec, whether the neighbor is bpgsec capable or not. The exception is that, in the propagating case, BGPsec will instead follow section 4 - which covers bgpsec capable neighbors (embed AS in BGPsec_Path) and bgpsec incapable neighbors (reconstruct AS_PATH). I think your statement is correct, but I don’t think it is what is meant here. —Sandy, speaking as a regular ol’ member"}
{"_id":"doc-en-sidr-e59vHmSa87DTAbWQ5Ung9EGHiyw","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-13.txt\nspeaking as a regular ol’ member Substantive comment .... Looking at this on page 23, \"BGPsec update messages do not contain an AS_PATH attribute. Therefore, a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute. The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" What is being said in the second sentence above is not clear. No exception applies if the peer is BGPsec capable and negotiated BGPsec. So is the exception for the case when the peer is non-BGPsec? May the fix is to replace this (current): \"The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" with the following (proposed): The only exception to this rule is when AS path information must be re-formatted to AS_PATH in order to propagate a route to a non-BGPsec peer (in which case the BGPsec speaker follows the instructions in Section 4.4). I read that sentence differently. When BGP is propagating a route to a neighbor, it ordinarily appends its AS to the AS_PATH. The “in all cases” would imply the same would happen in BPGsec, whether the neighbor is bpgsec capable or not. The exception is that, in the propagating case, BGPsec will instead follow section 4 - which covers bgpsec capable neighbors (embed AS in BGPsec_Path) and bgpsec incapable neighbors (reconstruct AS_PATH). I think your statement is correct, but I don’t think it is what is meant here. —Sandy, speaking as a regular ol’ member"}
{"_id":"doc-en-sidr-UmFHKtJP_Ztc70n5rpkuEFofBlw","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-13.txt\nHi Matt, A few notes below (one editorial and one substantive). There is a typo in this sentence (page 11): In particular, the BGPsec attribute SHOULD NOT be removed even in the case where the BGPsec update message *has not* been that *has not* successfully validated. Repeat of 'has not' above. May be the sentence was meant to read as follows? In particular, the BGPsec attribute SHOULD NOT be removed even in the case where the BGPsec update message has not been validated (not attempted) or has not been successfully validated. Substantive comment .... Looking at this on page 23, \"BGPsec update messages do not contain an AS_PATH attribute. Therefore, a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute. The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4<https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-13#section-4>).\" What is being said in the second sentence above is not clear. No exception applies if the peer is BGPsec capable and negotiated BGPsec. So is the exception for the case when the peer is non-BGPsec? May the fix is to replace this (current): \"The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4<https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-13#section-4>).\" with the following (proposed): The only exception to this rule is when AS path information must be re-formatted to AS_PATH in order to propagate a route to a non-BGPsec peer (in which case the BGPsec speaker follows the instructions in Section 4.4). Sriram Hi Matt, A few notes below (one editorial and one substantive). There is a typo in this sentence (page 11): In particular, the BGPsec attribute SHOULD NOT be removed even in the case where the BGPsec update message *has not* been that *has not* successfully validated. Repeat of 'has not' above. May be the sentence was meant to read as follows? In particular, the BGPsec attribute SHOULD NOT be removed even in the case where the BGPsec update message has not been validated (not attempted) or has not been successfully validated. Substantive comment .... Looking at this on page 23, \"BGPsec update messages do not contain an AS_PATH attribute. Therefore, a BGPsec speaker MUST utilize the AS path information in the BGPsec_Path attribute in all cases where it would otherwise use the AS path information in the AS_PATH attribute. The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" What is being said in the second sentence above is not clear. No exception applies if the peer is BGPsec capable and negotiated BGPsec. So is the exception for the case when the peer is non-BGPsec? May the fix is to replace this (current): \"The only exception to this rule is when AS path information must be updated in order to propagate a route to a peer (in which case the BGPsec speaker follows the instructions in Section 4).\" with the following (proposed): The only exception to this rule is when AS path information must be re-formatted to AS_PATH in order to propagate a route to a non-BGPsec peer (in which case the BGPsec speaker follows the instructions in Section 4.4). Sriram"}
{"_id":"doc-en-sidr-5sogBnL4s5so3ilqOAkEjVIbzyA","title":"","text":"[sidr] as-migration nit in bgpsec-protocol-13\nI just made another pass through sidr-as-migration and bgpsec-protocol-13 back to back to make sure that they are in sync, and I only found one sentence in the security considerations (7.4) that probably needs to be changed: Current: However, entities other than route servers could conceivably use this mechanism (set the pCount to zero) to attract traffic (by reducing the effective length of the AS-PATH) illegitimately. This risk is largely mitigated if every BGPsec speaker drops incoming update messages that set pCount to zero but come from a peer that is not a route server. Proposed: ... if every BGPsec speaker drops incoming update messages that set pCount to zero unless explicitly configured to accept them from a specific peer where pCount=0 messages are expected, such as a route server. Thanks, Wes A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPsec Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-13.txt Pages : 39 Date : 2015-07-06 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-13 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-13 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr ________________________________ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-kegL5O-0SgyO72R5JskHK4l0aE8","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nThanks to David for identifying this problem initially and to everyone else who contributed to this discussion. I am happy to update the document to reflect the working group consensus. My goal is to get a revised version of the document to the working group sometime late next week (e.g. Oct 17). - Matt Lepinski On Tue, Oct 6, 2015 at 9:31 PM, Sandra Murphy <sandy@tislabs.com> wrote: This conversation seems to have come to a close. The wg chairs see wg consensus as follows: The problem is real enough to merit a protocol change. The change is to cover more raw info in the signatures, rather than signature chaining only, along the lines of http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07258.html (see also the new archiving tool https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/sXUj7lgieri0Wrv5PK5u7PfLtxc). In addition, maintaining ordering was also noted as important to some http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07261.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07270.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07271.html The authors of draft-ietf-sidr-bgpsec-protocol-13 are requested to submit a revised version of the draft. The changes are significant enough that the revised draft will go through a wglc, focussed on the changes for this issue, so shorter than normal. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Thanks to David for identifying this problem initially and to everyone else who contributed to this discussion.I am happy to update the document to reflect the working group consensus. My goal is to get a revised version of the document to the working group sometime late next week (e.g. Oct 17).- Matt Lepinski This conversation seems to have come to a close. The wg chairs see wg consensus as follows: The problem is real enough to merit a protocol change. The change is to cover more raw info in the signatures, rather than signature chaining only, along the lines of http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07258.html (see also the new archiving tool https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/sXUj7lgieri0Wrv5PK5u7PfLtxc). In addition, maintaining ordering was also noted as important to some http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07261.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07270.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07271.html The authors of draft-ietf-sidr-bgpsec-protocol-13 are requested to submit a revised version of the draft. The changes are significant enough that the revised draft will go through a wglc, focussed on the changes for this issue, so shorter than normal. —Sandy, speaking as one of the wg co-chairs _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-Pnegayf6AVfiBOBJ1YTnfMIriYg","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nThis conversation seems to have come to a close. The wg chairs see wg consensus as follows: The problem is real enough to merit a protocol change. The change is to cover more raw info in the signatures, rather than signature chaining only, along the lines of http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07258.html (see also the new archiving tool https:\/\/mailarchive.ietf.org\/arch\/msg\/sidr\/sXUj7lgieri0Wrv5PK5u7PfLtxc). In addition, maintaining ordering was also noted as important to some http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07261.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07270.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07271.html The authors of draft-ietf-sidr-bgpsec-protocol-13 are requested to submit a revised version of the draft. The changes are significant enough that the revised draft will go through a wglc, focussed on the changes for this issue, so shorter than normal. —Sandy, speaking as one of the wg co-chairs"}
{"_id":"doc-en-sidr-cRSN1zIESbKTs__UmYCaQ5ymrnM","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nIn the example with -- > A --> B --> C --> D -->, if B and C (the ones that were signing but not verifying) return to the update to verify, then they will realize that the update they last signed (for the prefix) was invalid, and will propagate an alternate valid signed announcement or send a withdrawal message to D. and all the packts will return to their origins with a loud swoosh and re-route correctly :) At this point, B and C have taken their corrective action. not really. the internet is all about the data plane. the control plane is there to help the data plane. randy"}
{"_id":"doc-en-sidr-P3hXNZcoYYD-hPRr5Y_Lw2CfxcM","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\n3. In consideration of the above (#2), the document should instead strongly recommend that “if an AS signs an update without verifying first, it SHOULD return to the update at its earliest and verify, and forward a new signed update, if necessary.\" Make this a strong BCP recommendation. Without replay protection, I don't see how this recommendation would help. I.e., the old signed update would still be valid. In the example with -- > A --> B --> C --> D -->, if B and C (the ones that were signing but not verifying) return to the update to verify, then they will realize that the update they last signed (for the prefix) was invalid, and will propagate an alternate valid signed announcement or send a withdrawal message to D. At this point, B and C have taken their corrective action. Their well-behaving neighbors (others besides D) will act on the new valid announcement or the withdrawal. But if D is still malicious and suppresses the new valid announcement or the withdraw, then that would be a classic withdraw suppression \/ replay attack. (B and C are not contributing to collusion anymore at this point.) And the solution at that point is whatever remedy draft-ietf-sidr-bgpsec-rollover-04 offers. Sriram"}
{"_id":"doc-en-sidr-DqPG2CMWaSWHqRL7cY27H7tpIkw","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nAt least initially, sig order was required to match the AS transit order, to ensure that the AS transit order is accurately represented. Is that no longer true? Are you talking about (1) the order of the signatures on the wire, (2) the order of which AS path is covered by which signature, or (3) the chronological order in which the signatures are generated? I think Rob and I were talking about (3), but Rob should tell me if I misunderstood him. For (1), the order needs to specified such that each signature can be correctly verified. Having the order of the signatures match the AS transit order seems like the most sensible way to do this. For (2), I think it's critical that each signature covers that correct AS path, in the correct order. For (3), the signatures will typically be generated in order, but I don't see the value of enforcing that. I.e., while I don't see the point of pre-computing signatures before including them in a BGPsec UPDATE, I also don't see any harm in it. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-z0PSJhJYt2-XfsIJ71prxLO7Rug","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nDavid, ... What does the guarantee about signature order provide? I don't see how it's useful, but I could be missing something. At least initially, sig order was required to match the AS transit order, to ensure that the AS transit order is accurately represented. Is that no longer true? Steve"}
{"_id":"doc-en-sidr-iKv7-x8_1m3kusvTYoCOk94UMp8","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nAt Tue, 08 Sep 2015 21:21:52 -0400, David Mandelberg wrote: What does the guarantee about signature order provide? I don't see how it's useful, but I could be missing something. I can't point to any concrete threat. Just a suspicion that we should grab a cheap opportunity to reduce the number of potential violations of the Principal of Least Astonishment."}
{"_id":"doc-en-sidr-yfPlPE-2F06Xv_FatBwlc6Wvr2g","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nHmm, I would have thought we'd want to keep the chaining, in the sense that non-originating would sign the previous signature. I've no real objection to signing everything else again, it's just removal of the previous signature that I find odd here. The benefit I see to keeping the signature chaining is that it adds an ordering constraint to the signatures (signature A must have been created after signature B), corresponding to the order in which we expect the update to travel between signers. This seems like a good thing, and I don't see why we'd want to remove it. As you've demonstrated, it doesn't remove all possible forms of mischief, but it raises the bar a bit, and it's cheap, so why not? I agree that signature chaining provides the guarantee you stated, that signatures were generated in order. But in the presence of non-validating signers, I don't think it provides any other guarantee. What does the guarantee about signature order provide? I don't see how it's useful, but I could be missing something. Am I missing something? Where's the benefit in removing the chaining? There's no benefit to removing it, except that I don't see any benefit to keeping it (if we sign the full data, as I described). -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-c1kIr00QYcXxmGHjSPALrYPhg0g","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nHmm, I would have thought we'd want to keep the chaining, in the sense that non-originating would sign the previous signature. I've no real objection to signing everything else again, it's just removal of the previous signature that I find odd here. The benefit I see to keeping the signature chaining is that it adds an ordering constraint to the signatures (signature A must have been created after signature B), corresponding to the order in which we expect the update to travel between signers. This seems like a good thing, and I don't see why we'd want to remove it. As you've demonstrated, it doesn't remove all possible forms of mischief, but it raises the bar a bit, and it's cheap, so why not? Am I missing something? Where's the benefit in removing the chaining?"}
{"_id":"doc-en-sidr-b4G9KopWS9qWlBFXN3f1fp8FqKs","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nIf I understand Davids attack vector correct than the attack would look as follows: For the path -> A -> B -> C -> D -> E with A and D conspiring and B and C only signing but not validating: A signs the path to D and not to B but sends it to B. Because B and C do not validate, just sign they forward the path to D. D removed B and C from the path and forwards the path as -> A -> D to E. Now E verifies the path as valid and moves on. If this is what David had in mind then I agree that the security guarantee in 7.1 does not hold up. This is one type of attack that uses the issue I raised, but this specific attack doesn't seem problematic to me. A and D can always set up a BGPsec tunnel to accomplish the same result of removing B and C from the path, and there's not much we can do to stop that. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-Z3OUnC_DU5VcSffoPMoHqns624U","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\n3. In consideration of the above (#2), the document should instead strongly recommend that “if an AS signs an update without verifying first, it SHOULD return to the update at its earliest and verify, and forward a new signed update, if necessary.\" Make this a strong BCP recommendation. Without replay protection, I don't see how this recommendation would help. I.e., the old signed update would still be valid. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-sXUj7lgieri0Wrv5PK5u7PfLtxc","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nAt Wed, 26 Aug 2015 17:26:24 -0400, David Mandelberg wrote: ... I think this problem might be fixed if we modify the protocol to sign all of the preceding signed data (rather than just the immediate, previous signature). Agreed, assuming this means adding the (theoretically invariant) fields from the data to be signed in section 4.1 to the data to be signed in section 4.2. Taking \"Origin AS Number\" in section 4.1 as equivalent to \"Signer's AS Number\" in section 4.2, this leaves the algorithm suite identifier, the AFI, the SAFI, and the NLRI to be added to the data to be signed in section 4.2. I doubt that there's any practical attack based on fiddling with the algorithm suite identifier (I'd expect any games there to cause validation failure, end of story), but maybe somebody has a more twisted imagination than mine, and, given that the algorithm suite ID is one byte long, I don't think it's worth trying to optimize that byte out of the section 4.2 signature. Presumably we want to keep the existing signature chaining, so I wouldn't remove anything from the data to be signed in section 4.2, just add the fields that are currently only present in section 4.1. David, if this is consistent with what you meant, cool, if not, say on. It is not consistent with what I meant, so I'll be more explicit about what I meant. I meant to remove the signature chaining, and have each AS sign the data that is currently covered by signature chaining. I.e., each AS (origin or intermediary) would sign the same data structure (with different, but related, data in the structure): Target AS Number (4 octets) AS Count (4 octets) <AS Count> instances of: AS Number (4 octets) <AS Count> instances of: pCount (1 octet) Flags (1 octet) Algorithm Suite Id. (1 octet) AFI (2 octets) SAFI (1 octet) NLRI (variable) The sequence of AS Numbers is split from the sequence of (pCount, Flags) to preserve alignment, but the two sequences form a single logical sequence of (AS Number, pCount, Flags). (This could also be represented with 2 bytes of padding per AS, without 4-byte alignment, or with 3 parallel sequences; I don't really care which.) Regardless of the logical sequence's representation, the first (AS Number, pCount, Flags) entry corresponds to (Origin AS Number, pCount, Flags) from section 4.1. Subsequent entries correspond to (Signer's AS Number, pCount, Flags) from section 4.2, in order from the origin's next hop to the current signer. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-tPrzvv4rm6qY-QE8fGp4UagHhAE","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nDoug and I have discussed the issues raised in this thread in some detail. We feel that the following considerations (with corresponding changes in the document) would help resolve the issue(s) we are dealing with: 1. As mentioned already, signature should cover more data so that the collusion vulnerability that David pointed out can be addressed. 2. It was a conscious design decision to not require (MUST) validation before path selection and signing in all cases. Lazy (or deferred) evaluation (e.g., the ability to select and sign a path before validation) adds performance \/ robustness options to implementations that address real operational concerns (e.g., convergence time on table dumps, bootstrap, etc.) that were identified early in the BGPsec design process. 3. In consideration of the above (#2), the document should instead strongly recommend that “if an AS signs an update without verifying first, it SHOULD return to the update at its earliest and verify, and forward a new signed update, if necessary.\" Make this a strong BCP recommendation. 4. If this recommendation (#3) is followed, then other collusion\/replay effects that have been identified on the list will be short lived (e.g. Oliver’s: http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg07248.html ). Adverse effects would be short lived, if the duration of deferment of verification (if any) is short. Sriram"}
{"_id":"doc-en-sidr-Jr_WWjJ8x6EI7FVb8KiLT6SNXXQ","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nSpeaking as a regular ol’ member an intermediate AS, which does not validate but signs, could apply I’d say that the intermediate AS who didn’t verify the signatures it received could be acting on bad info at any time, without any conspiring ASs around. The intermediate AS has no more assurance than a non-bgpsec speaker that the route it receives is valid. it is not worse than unsecured is a form of reasoning i do not buy. <snip> But the intermediate AS and any bgp4 (i.e. non-bgpsec speakers?) peers have chosen to be insecure - I see no reason to be concerned. same fallacious argument. we are supposed to be making things better, not leaving them the same. Are you saying that any system that does NOT check the protections and does not spot invalid signatures should still be protected? I think that’s a pretty tall order. My concern is with those who do check the signature but who, because conspiring ASs “violate the guarantee”, do not get the bgpsec protection in some way. David’s suggestion that more of the data should be covered by the signature still does not help the hapless intermediate AS who does not check the signature, I would think. That AS could still fooled. So I don’t think that the new signature makes anything better for the non-checkers. —Sandy, speaking as a regular ol’ member"}
{"_id":"doc-en-sidr-TVcZP7zgoeuByE5IM2XL1EJYEkw","title":"","text":"[sidr] replay threats (was: draft-ietf-sidr-bgpsec-protocol-13's\n security guarantees)\ncan we start a new thread for replay? randy"}
{"_id":"doc-en-sidr-ZwGVfAV112-JerW9MAblukCv2vk","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nIf I understand your scenario correctly, as far as folks further along the path are concerned, this is a replay attack by D. That D is doing this to cover up something bad that A is doing to B and C is almost irrelevant, as is the specific nature of whatever bad thing A is doing to B and C. So, yeah, OK, it's a form of collusion, but it's not one that relies on a weakness in the signature semantics, it's one that relies on lack of protection against replay attacks, something the WG discussed and rejected. Can't speak for anybody else, but I'm not particularly interested in exhuming the replay horse at this late date. It appears you agree that the two-update collusion scenario that I described is feasible. It is basically another mechanism by which the colluders seem to achieve the same effect as in David's collusion scenario. (I think so, but I'm open to being proven wrong about that.) The latter, it appears, can be mitigated by signing 'all of the preceding signed data', but not the former (two-update collusion). Both scenarios or threats rely on intermediate ASes not verifying. So both of these scenarios are mitigated by requiring intermediate ASes to verify. This is the observation I would like to make. Since you made contrary comments, let me point out respectfully that replay attack mitigation is in the requirements (RFC 7353): 4.3 Replay of BGP UPDATE messages need not be completely prevented, but a BGPsec design SHOULD provide a mechanism to control the window of exposure to replay attacks. And there is an active SIDR WG draft dealing with replay attack mitigation: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-rollover-04#section-4.2 However, a solution for the specific collusion threat we are discussing does not benefit at all from replay attack mitigation techniques. All that D is doing (in my example) is to hold the first update for 15 or 30 seconds. The bgpsec-rollover draft proposes router key rollovers, but (thank goodness) not on that small\/tiny (seconds) time scale! Sriram"}
{"_id":"doc-en-sidr-CNU6np2RNuVEKg7987QhCrhBfVg","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nan intermediate AS, which does not validate but signs, could apply I’d say that the intermediate AS who didn’t verify the signatures it received could be acting on bad info at any time, without any conspiring ASs around. The intermediate AS has no more assurance than a non-bgpsec speaker that the route it receives is valid. it is not worse than unsecured is a form of reasoning i do not buy. prefix-based local policy based on the wrong prefix. same for any bgp4 peers it may have. I see nothing in David’s message about a prefix, so I’m not sure what you are talking about. sorry, i forgot that bgp announces beers. the colluding systems could have signed a hash of lager when the label on the announcement was pils. the intermediate system which does not validate could base it's mains order on pils and tell it's non-validating peers to have a pils with them. But the intermediate AS and any bgp4 (i.e. non-bgpsec speakers?) peers have chosen to be insecure - I see no reason to be concerned. same fallacious argument. we are supposed to be making things better, not leaving them the same. randy"}
{"_id":"doc-en-sidr-98tuTKqK49wkCOF50-eq8edSVic","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nSpeaking as regular ol’ member: good catch. one consequence an intermediate AS, which does not validate but signs, could apply I’d say that the intermediate AS who didn’t verify the signatures it received could be acting on bad info at any time, without any conspiring ASs around. The intermediate AS has no more assurance than a non-bgpsec speaker that the route it receives is valid. So I don’t think anything that happens to the intermediate AS is something to worry about. prefix-based local policy based on the wrong prefix. same for any bgp4 peers it may have. I see nothing in David’s message about a prefix, so I’m not sure what you are talking about. But the intermediate AS and any bgp4 (i.e. non-bgpsec speakers?) peers have chosen to be insecure - I see no reason to be concerned. —Sandy, speaking as regular ol’ member"}
{"_id":"doc-en-sidr-Ne9aGIKfImlOe8HOsZmYo7V8TuY","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nI noticed Outlook changed some characters so here again: If I understand Davids attack vector correct than the attack would look as follows: For the path -> A -> B -> C -> D -> E with A and D conspiring and B and C only signing but not validating: A signs the path to D and not to B but sends it to B. Because B and C do not validate, just sign they forward the path to D. D removed B and C from the path and forwards the path as -> A -> D to E. Now E verifies the path as valid and moves on. If this is what David had in mind then I agree that the security guarantee in 7.1 does not hold up. Oliver On 8\/27\/15, 3:15 PM, \"sidr on behalf of Borchert, Oliver\" <sidr-bounces@ietf.org on behalf of oliver.borchert@nist.gov> wrote: If I understand David¹s attack vector correct than the attack would look as follows: For the path ‹ > A ‹> B ‹> C ‹> D ‹> E with A and D conspiring and B and C only signing but not validating: A signs the path to D and not to B but sends it to B. Because B and C don¹t validate, just sign they forward the path to D. D removed B and C from the path and forwards the path as ‹> A ‹> D to E. Now E verifies the path as valid and moves on. If this is what David had in mind then I agree that the security guarantee in 7.1 does not hold up. Oliver At Thu, 27 Aug 2015 15:45:49 +0000, Sriram, Kotikalapudi wrote: What do you think of the following two-update collusion scenario? -- > A --> B --> C --> D --> E A and D are colluding. B and C are signing without verifying. First update at time= t0: A signs and forwards an update normally (without any corruption). The update propagates via B and C to D. D receives it and stores it, but does not forward to E (or anyone). Second update at time= t1 (= t0 + delta): A sends an intentionally corrupted version of the update (signed), while keeping the same NLRI as before. B and C are still signing but not verifying. The update propagates via B and C to D. Now D replaces this corrupted update with the earlier clean one (received at t0), and propagates to E. The resulting update from D to E is valid. One can argue that there is violation of the guarantee (in Section 7.1) at time t1. The valid route propagated from D to E does not agree with the route that B or C forwarded (at time t1) for the NLRI in consideration. If I understand your scenario correctly, as far as folks further along the path are concerned, this is a replay attack by D. That D is doing this to cover up something bad that A is doing to B and C is almost irrelevant, as is the specific nature of whatever bad thing A is doing to B and C. So, yeah, OK, it's a form of collusion, but it's not one that relies on a weakness in the signature semantics, it's one that relies on lack of protection against replay attacks, something the WG discussed and rejected. Can't speak for anybody else, but I'm not particularly interested in exhuming the replay horse at this late date. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-igN6NHMH1L6RlPg4P7TrSfHXlSY","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nIf I understand David¹s attack vector correct than the attack would look as follows: For the path ‹ > A ‹> B ‹> C ‹> D ‹> E with A and D conspiring and B and C only signing but not validating: A signs the path to D and not to B but sends it to B. Because B and C don¹t validate, just sign they forward the path to D. D removed B and C from the path and forwards the path as ‹> A ‹> D to E. Now E verifies the path as valid and moves on. If this is what David had in mind then I agree that the security guarantee in 7.1 does not hold up. Oliver At Thu, 27 Aug 2015 15:45:49 +0000, Sriram, Kotikalapudi wrote: What do you think of the following two-update collusion scenario? -- > A --> B --> C --> D --> E A and D are colluding. B and C are signing without verifying. First update at time= t0: A signs and forwards an update normally (without any corruption). The update propagates via B and C to D. D receives it and stores it, but does not forward to E (or anyone). Second update at time= t1 (= t0 + delta): A sends an intentionally corrupted version of the update (signed), while keeping the same NLRI as before. B and C are still signing but not verifying. The update propagates via B and C to D. Now D replaces this corrupted update with the earlier clean one (received at t0), and propagates to E. The resulting update from D to E is valid. One can argue that there is violation of the guarantee (in Section 7.1) at time t1. The valid route propagated from D to E does not agree with the route that B or C forwarded (at time t1) for the NLRI in consideration. If I understand your scenario correctly, as far as folks further along the path are concerned, this is a replay attack by D. That D is doing this to cover up something bad that A is doing to B and C is almost irrelevant, as is the specific nature of whatever bad thing A is doing to B and C. So, yeah, OK, it's a form of collusion, but it's not one that relies on a weakness in the signature semantics, it's one that relies on lack of protection against replay attacks, something the WG discussed and rejected. Can't speak for anybody else, but I'm not particularly interested in exhuming the replay horse at this late date. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-tl2u4k9Gbaeg0WYUOn6mus4CtXo","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nAt Thu, 27 Aug 2015 15:45:49 +0000, Sriram, Kotikalapudi wrote: What do you think of the following two-update collusion scenario? -- > A --> B --> C --> D --> E A and D are colluding. B and C are signing without verifying. First update at time= t0: A signs and forwards an update normally (without any corruption). The update propagates via B and C to D. D receives it and stores it, but does not forward to E (or anyone). Second update at time= t1 (= t0 + delta): A sends an intentionally corrupted version of the update (signed), while keeping the same NLRI as before. B and C are still signing but not verifying. The update propagates via B and C to D. Now D replaces this corrupted update with the earlier clean one (received at t0), and propagates to E. The resulting update from D to E is valid. One can argue that there is violation of the guarantee (in Section 7.1) at time t1. The valid route propagated from D to E does not agree with the route that B or C forwarded (at time t1) for the NLRI in consideration. If I understand your scenario correctly, as far as folks further along the path are concerned, this is a replay attack by D. That D is doing this to cover up something bad that A is doing to B and C is almost irrelevant, as is the specific nature of whatever bad thing A is doing to B and C. So, yeah, OK, it's a form of collusion, but it's not one that relies on a weakness in the signature semantics, it's one that relies on lack of protection against replay attacks, something the WG discussed and rejected. Can't speak for anybody else, but I'm not particularly interested in exhuming the replay horse at this late date."}
{"_id":"doc-en-sidr-VVPgz7ik-HQidea1ejobzn_FpPg","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nIt appears that this guarantee will not always hold. Specifically, if two non-adjacent ASes conspire, and they are separated by a sequence of ASes that sign path data that they have not verified, then the conspiring ASes can violate the guarantee. Agree with that. What do you think of the following two-update collusion scenario? -- > A --> B --> C --> D --> E A and D are colluding. B and C are signing without verifying. First update at time= t0: A signs and forwards an update normally (without any corruption). The update propagates via B and C to D. D receives it and stores it, but does not forward to E (or anyone). Second update at time= t1 (= t0 + delta): A sends an intentionally corrupted version of the update (signed), while keeping the same NLRI as before. B and C are still signing but not verifying. The update propagates via B and C to D. Now D replaces this corrupted update with the earlier clean one (received at t0), and propagates to E. The resulting update from D to E is valid. One can argue that there is violation of the guarantee (in Section 7.1) at time t1. The valid route propagated from D to E does not agree with the route that B or C forwarded (at time t1) for the NLRI in consideration. I think this problem might be fixed if we modify the protocol to sign all of the preceding signed data (rather than just the immediate, previous signature). If we agree that the above two-update collusion scenario is something we care about, then it should be noted that this fix does not prevent it. Sriram"}
{"_id":"doc-en-sidr-rH-3JQBhzcmxnhZMoDULer-GWLQ","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nAt Wed, 26 Aug 2015 17:26:24 -0400, David Mandelberg wrote: ... I think this problem might be fixed if we modify the protocol to sign all of the preceding signed data (rather than just the immediate, previous signature). Agreed, assuming this means adding the (theoretically invariant) fields from the data to be signed in section 4.1 to the data to be signed in section 4.2. Taking \"Origin AS Number\" in section 4.1 as equivalent to \"Signer's AS Number\" in section 4.2, this leaves the algorithm suite identifier, the AFI, the SAFI, and the NLRI to be added to the data to be signed in section 4.2. I doubt that there's any practical attack based on fiddling with the algorithm suite identifier (I'd expect any games there to cause validation failure, end of story), but maybe somebody has a more twisted imagination than mine, and, given that the algorithm suite ID is one byte long, I don't think it's worth trying to optimize that byte out of the section 4.2 signature. Presumably we want to keep the existing signature chaining, so I wouldn't remove anything from the data to be signed in section 4.2, just add the fields that are currently only present in section 4.1. David, if this is consistent with what you meant, cool, if not, say on."}
{"_id":"doc-en-sidr-Lq4YFl1qEDhGYysLBRhDxmjg8XM","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\ngood catch. one consequence an intermediate AS, which does not validate but signs, could apply prefix-based local policy based on the wrong prefix. same for any bgp4 peers it may have. randy"}
{"_id":"doc-en-sidr-czM-2u8RxM4d4YfovOtodc3rXwc","title":"","text":"[sidr] draft-ietf-sidr-bgpsec-protocol-13's security guarantees\nHi all, I think I found an issue with draft-ietf-sidr-bgpsec-protocol-13's security guarantees. Apologies that I didn't catch this earlier, before WGLC ended. The security guarantee with the issue is in section 7.1, \"For each AS in the path, a BGPsec speaker authorized by the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the subsequent AS in the path.\" It appears that this guarantee will not always hold. Specifically, if two non-adjacent ASes conspire, and they are separated by a sequence of ASes that sign path data that they have not verified, then the conspiring ASes can violate the guarantee. The ASes that signed path data they didn't verify are behaving properly, since the spec says \"In particular, the BGPsec attribute SHOULD NOT be removed even in the case where the BGPsec update message has not been that has not successfully validated.\" I have not yet been able to come up with a practical attack that uses this issue to do anything particularly bad, but I am concerned that one might exist. I think this problem might be fixed if we modify the protocol to sign all of the preceding signed data (rather than just the immediate, previous signature). Thoughts? -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-iqPKRCfazMLaQUuv_xoQL5FCVog","title":"","text":"[sidr] Update to BGPsec BIRD Implementation\nHi all, I wanted to announce newer versions of BGPsec supporting code using BIRD: bgpsec-bird-client v1.0 and v0.6 of BGPsec support code for BIRD. They are available as a source tarballs at: http:\/\/bgpsec.tislabs.com The bgpsec-bird-client application has two main features. It uses the rpki-rtr protocol (http:\/\/datatracker.ietf.org\/doc\/rfc6810) via RTRlib (https:\/\/rpki.realmv6.org\/trac\/) to download RPKI ROAs and router keys and then loads them into a running BIRD router (e.g. rtr_roa_table). It also supports the RPKI-RTR-MIB (http:\/\/datatracker.ietf.org\/doc\/rfc6945\/) using the Net-SNMP toolkit (http:\/\/www.net-snmp.org). The BGPsec supporting BIRD code is currently based on v1.4.5 of BIRD. The main changes from the last release is that the the lack of the configure directive, --enable-bgpsec, will remove most of the BGPsec related code at compile time (i.e. without the --enable-bgpsec, the compiled code will be the same as the standard BIRD v1.4.5). It currently supports draft version 12 of the BGPsec protocol specification. This is an ongoing project following the IETF's SIDR Working Group's RPKI\/BGPsec work: http:\/\/datatracker.ietf.org\/wg\/sidr\/charter\/ http:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ The code is still at the testing stage and should not be use used for production services. If any one wants to test the code, please feel free to email me any questions or bug reports. Thanks, Mike -- Michael Baer Parsons baerm@tislabs.com"}
{"_id":"doc-en-sidr-QYBMlGvTJdUTSbc1MNAoZHnc6Vw","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nFrom: Matthew Lepinski <mlepinski.ietf@gmail.com<mailto:mlepinski.ietf@gmail.com>> Date: Friday, July 24, 2015 at 1:31 AM To: \"George, Wes\" <wesley.george@twcable.com<mailto:wesley.george@twcable.com>> Cc: \"sidr@ietf.org<mailto:sidr@ietf.org>\" <sidr@ietf.org<mailto:sidr@ietf.org>> Subject: Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 That being said, I agree with you that from the point of view of a denial-of-service prevention, that we should be recommending that implementations \"Skip out\" after a failed signature verification. When I read the text in \"Step III\" on page 29 within Section 5.2, I interpret that text as indicating that implementations should skip the remaining signatures once they get a failed signature verification. If you interpret that text differently, please let me know, but in my reading of the document, I understand the 5.2 algorithm as saying implementations should \"skip out\" when a signature is bad. WG] I agree with your interpretation. As Randy pointed out, this is probably a case of misinterpretation due to the fact that I'm not the target audience (implementers) and thus I missed something that would have been obvious to your target audience. Thanks Wes ________________________________ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 24, 2015 at 1:31 AM To: \"George, Wes\" <wesley.george@twcable.com> Cc: \"sidr@ietf.org\" <sidr@ietf.org> Subject: Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 That being said, I agree with you that from the point of view of a denial-of-service prevention, that we should be recommending that implementations \"Skip out\" after a failed signature verification. When I read the text in \"Step III\" on page 29 within Section 5.2, I interpret that text as indicating that implementations should skip the remaining signatures once they get a failed signature verification. If you interpret that text differently, please let me know, but in my reading of the document, I understand the 5.2 algorithm as saying implementations should \"skip out\" when a signature is bad. WG] I agree with your interpretation. As Randy pointed out, this is probably a case of misinterpretation due to the fact that I'm not the target audience (implementers) and thus I missed something that would have been obvious to your target audience. Thanks Wes This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-gj33_yRM0zlzdS_FMNqELsvgdOE","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nWes, Sorry for the delay. I completely agree with you that the text in 7.1 could be more clear. I appreciate your suggested change and I am happy to issue a quick revision to clarify this issue. With regards to the validation algorithm (Section 5.2), I am not convinced there is a problem. The document currently states (at the beginning of 5.2 on page 26) that implements must have the same input\/output behavior as the validation algorithm in the document. That is, my interpretation of the current text is that we don't want to mandate any particular algorithm (or rule out any potential implementation-specific optimizations), but we want every implementation to return \"Valid\" on the same inputs as any other implementation. I believe this means that implementations are free to \"skip-out\" after a failed signature verification or not as they see fit [and still be compliant with the spec either way]. That being said, I agree with you that from the point of view of a denial-of-service prevention, that we should be recommending that implementations \"Skip out\" after a failed signature verification. When I read the text in \"Step III\" on page 29 within Section 5.2, I interpret that text as indicating that implementations should skip the remaining signatures once they get a failed signature verification. If you interpret that text differently, please let me know, but in my reading of the document, I understand the 5.2 algorithm as saying implementations should \"skip out\" when a signature is bad. - Matt Lepinski On Fri, Jul 10, 2015 at 3:08 PM, George, Wes <wesley.george@twcable.com> wrote: Matt - I finally got a chance to review the updates you put in for –12 and 13. It has addressed most of the concerns I raised. Only thing I see missing is this comment from my previous review. Section 5.2 - elsewhere in the document (7.3), you note that validation should stop when an invalid signature is found. However, I see no mention of that in the actual validation algorithm. That seems like good practice even if there isn't a long chain of signatures to validate. Additionally, 7.1's text \"Thus, a BGPsec speaker MUST completely validate all BGPsec update messages received from external peers.\" seems to conflict with this recommendation because it says \"completely\". I think it's a wording problem, i.e. We're not saying you MUST validate the *entire* update, but rather you must validate ALL updates that you *receive* until you encounter an invalid signature within a given update, in which case you can stop and move to the next update. Thanks, Wes From: sidr <sidr-bounces@ietf.org> on behalf of Matthew Lepinski < mlepinski.ietf@gmail.com> Date: Monday, June 15, 2015 at 12:41 AM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski ------------------------------ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. Wes,Sorry for the delay. I completely agree with you that the text in 7.1 could be more clear. I appreciate your suggested change and I am happy to issue a quick revision to clarify this issue.With regards to the validation algorithm (Section 5.2), I am not convinced there is a problem. The document currently states (at the beginning of 5.2 on page 26) that implements must have the same input\/output behavior as the validation algorithm in the document. That is, my interpretation of the current text is that we don't want to mandate any particular algorithm (or rule out any potential implementation-specific optimizations), but we want every implementation to return \"Valid\" on the same inputs as any other implementation. I believe this means that implementations are free to \"skip-out\" after a failed signature verification or not as they see fit [and still be compliant with the spec either way].That being said, I agree with you that from the point of view of a denial-of-service prevention, that we should be recommending that implementations \"Skip out\" after a failed signature verification. When I read the text in \"Step III\" on page 29 within Section 5.2, I interpret that text as indicating that implementations should skip the remaining signatures once they get a failed signature verification. If you interpret that text differently, please let me know, but in my reading of the document, I understand the 5.2 algorithm as saying implementations should \"skip out\" when a signature is bad. - Matt Lepinski Matt - I finally got a chance to review the updates you put in for –12 and 13. It has addressed most of the concerns I raised. Only thing I see missing is this comment from my previous review. Section 5.2 - elsewhere in the document (7.3), you note that validation should stop when an invalid signature is found. However, I see no mention of that in the actual validation algorithm. That seems like good practice even if there isn't a long chain of signatures to validate. Additionally, 7.1's text \"Thus, a BGPsec speaker MUST completely validate all BGPsec update messages received from external peers.\" seems to conflict with this recommendation because it says \"completely\". I think it's a wording problem, i.e. We're not saying you MUST validate the *entire* update, but rather you must validate ALL updates that you *receive* until you encounter an invalid signature within a given update, in which case you can stop and move to the next update. Thanks, Wes From: sidr <sidr-bounces@ietf.org> on behalf of Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Monday, June 15, 2015 at 12:41 AM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-9OPMsP97OASF2rmbnUzzI7AMK_U","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nsee skip-out logic in expression evaluation a friend just whacked me for being obscure by using compiler and language geekery. sorry. when evaluating A & B, if A is false, there is no sense evaluating B. A | B, if A is true, there is no sense evaluating B. this sometimes surprises new programmers when B is, for example, a function with side effects. randy"}
{"_id":"doc-en-sidr-EaNiqoCYK9t0LWg8aXBqu9pHT7M","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nsee skip-out logic in expression evaluation randy"}
{"_id":"doc-en-sidr-gXM_eREDFqNqphDZWaTJgpbv6uc","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nMatt - I finally got a chance to review the updates you put in for –12 and 13. It has addressed most of the concerns I raised. Only thing I see missing is this comment from my previous review. Section 5.2 - elsewhere in the document (7.3), you note that validation should stop when an invalid signature is found. However, I see no mention of that in the actual validation algorithm. That seems like good practice even if there isn't a long chain of signatures to validate. Additionally, 7.1's text \"Thus, a BGPsec speaker MUST completely validate all BGPsec update messages received from external peers.\" seems to conflict with this recommendation because it says \"completely\". I think it's a wording problem, i.e. We're not saying you MUST validate the *entire* update, but rather you must validate ALL updates that you *receive* until you encounter an invalid signature within a given update, in which case you can stop and move to the next update. Thanks, Wes From: sidr <sidr-bounces@ietf.org<mailto:sidr-bounces@ietf.org>> on behalf of Matthew Lepinski <mlepinski.ietf@gmail.com<mailto:mlepinski.ietf@gmail.com>> Date: Monday, June 15, 2015 at 12:41 AM To: \"sidr@ietf.org<mailto:sidr@ietf.org>\" <sidr@ietf.org<mailto:sidr@ietf.org>> Subject: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski ________________________________ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. Matt - I finally got a chance to review the updates you put in for –12 and 13. It has addressed most of the concerns I raised. Only thing I see missing is this comment from my previous review. Section 5.2 - elsewhere in the document (7.3), you note that validation should stop when an invalid signature is found. However, I see no mention of that in the actual validation algorithm. That seems like good practice even if there isn't a long chain of signatures to validate. Additionally, 7.1's text \"Thus, a BGPsec speaker MUST completely validate all BGPsec update messages received from external peers.\" seems to conflict with this recommendation because it says \"completely\". I think it's a wording problem, i.e. We're not saying you MUST validate the *entire* update, but rather you must validate ALL updates that you *receive* until you encounter an invalid signature within a given update, in which case you can stop and move to the next update. Thanks, Wes From: sidr <sidr-bounces@ietf.org> on behalf of Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Monday, June 15, 2015 at 12:41 AM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12 I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-jHCoaZJKw6VM33Ewngru_HX32K0","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nThe -13 revision addresses all of my questions, thanks. On 2015-07-06 19:26, Matthew Lepinski wrote: David, Thanks a lot for raising this issue. Based on the discussion in Dallas, I was hoping that we could just go with the clean approach of including the MP_REACH_NLRI attribute in the signature. As you correctly point out, we cant sign MP_REACH_NLRI, because the \"Network Address of Next Hop\" field within MP_REACH_NLRI changes as an update message propagates through network. (I.e., if we sign what the -12 draft says we should sign, verification will often fail.) I have just submitted a -13 version of the document that pulls out the fields from MP_REACH_NRLI which arent changed in transit (and thus can be safely signed). - Matt Lepinski On Mon, Jun 22, 2015 at 9:21 PM, David Mandelberg <david@mandelberg.org [4]> wrote: Anyone who commented on draft-ietf-sidr-bgpsec-protocol-11.txt is encouraged to review this version and report if your comments have or have not been addressed. My comments have been addressed, but I have some questions about the way one of them was addressed: Is the MP_REACH_NLRI encoded with or without the attribute flags and type code? Dont the values of MP_REACH_NLRIs \"Length of Next Hop Network Address\" and \"Network Address of Next Hop\" change with each hop, making it infeasible for remote ASes to verify the origins signature? MP_REACH_NLRI has a reserved field that \"MUST be set to 0, and SHOULD be ignored upon receipt\". If a BGPsec speaker receives an update where reserved is non-zero, what should it do? With the current text, I could interpret \"SHOULD be ignored upon receipt\" as meaning either \"calculate the signature using the reserved field as received\" or \"calculate the signature using all zeroes in place of the reserved field\". -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ [1] _______________________________________________ sidr mailing list sidr@ietf.org [2] https:\/\/www.ietf.org\/mailman\/listinfo\/sidr [3] Links: ------ [1] http:\/\/david.mandelberg.org\/ [2] mailto:sidr@ietf.org [3] https:\/\/www.ietf.org\/mailman\/listinfo\/sidr [4] mailto:david@mandelberg.org -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-8Qu2T4EtlZUxaWVO5YY8fDZjjtM","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nDavid, Thanks a lot for raising this issue. Based on the discussion in Dallas, I was hoping that we could just go with the clean approach of including the MP_REACH_NLRI attribute in the signature. As you correctly point out, we can't sign MP_REACH_NLRI, because the \"Network Address of Next Hop\" field within MP_REACH_NLRI changes as an update message propagates through network. (I.e., if we sign what the -12 draft says we should sign, verification will often fail.) I have just submitted a -13 version of the document that pulls out the fields from MP_REACH_NRLI which aren't changed in transit (and thus can be safely signed). - Matt Lepinski On Mon, Jun 22, 2015 at 9:21 PM, David Mandelberg <david@mandelberg.org> wrote: On 2015-06-19 14:00, Sandra Murphy wrote: Anyone who commented on draft-ietf-sidr-bgpsec-protocol-11.txt is encouraged to review this version and report if your comments have or have not been addressed. My comments have been addressed, but I have some questions about the way one of them was addressed: Is the MP_REACH_NLRI encoded with or without the attribute flags and type code? Don't the values of MP_REACH_NLRI's \"Length of Next Hop Network Address\" and \"Network Address of Next Hop\" change with each hop, making it infeasible for remote ASes to verify the origin's signature? MP_REACH_NLRI has a reserved field that \"MUST be set to 0, and SHOULD be ignored upon receipt\". If a BGPsec speaker receives an update where reserved is non-zero, what should it do? With the current text, I could interpret \"SHOULD be ignored upon receipt\" as meaning either \"calculate the signature using the reserved field as received\" or \"calculate the signature using all zeroes in place of the reserved field\". -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr David,Thanks a lot for raising this issue.Based on the discussion in Dallas, I was hoping that we could just go with the clean approach of including the MP_REACH_NLRI attribute in the signature. As you correctly point out, we can't sign MP_REACH_NLRI, because the \"Network Address of Next Hop\" field within MP_REACH_NLRI changes as an update message propagates through network. (I.e., if we sign what the -12 draft says we should sign, verification will often fail.)I have just submitted a -13 version of the document that pulls out the fields from MP_REACH_NRLI which aren't changed in transit (and thus can be safely signed).- Matt LepinskiOn Mon, Jun 22, 2015 at 9:21 PM, David Mandelberg <david@mandelberg.org> wrote: Anyone who commented on draft-ietf-sidr-bgpsec-protocol-11.txt is encouraged to review this version and report if your comments have or have not been addressed. My comments have been addressed, but I have some questions about the way one of them was addressed: Is the MP_REACH_NLRI encoded with or without the attribute flags and type code? Don't the values of MP_REACH_NLRI's \"Length of Next Hop Network Address\" and \"Network Address of Next Hop\" change with each hop, making it infeasible for remote ASes to verify the origin's signature? MP_REACH_NLRI has a reserved field that \"MUST be set to 0, and SHOULD be ignored upon receipt\". If a BGPsec speaker receives an update where reserved is non-zero, what should it do? With the current text, I could interpret \"SHOULD be ignored upon receipt\" as meaning either \"calculate the signature using the reserved field as received\" or \"calculate the signature using all zeroes in place of the reserved field\". -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-EMcQ_y8oeSHxKP0iOqLd4UcXx7w","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-13.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPsec Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-13.txt Pages : 39 Date : 2015-07-06 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-13 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-13 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-qxFOAhMqiXBz4OIS7WW-8tVf6Fo","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nAnyone who commented on draft-ietf-sidr-bgpsec-protocol-11.txt is encouraged to review this version and report if your comments have or have not been addressed. My comments have been addressed, but I have some questions about the way one of them was addressed: Is the MP_REACH_NLRI encoded with or without the attribute flags and type code? Don't the values of MP_REACH_NLRI's \"Length of Next Hop Network Address\" and \"Network Address of Next Hop\" change with each hop, making it infeasible for remote ASes to verify the origin's signature? MP_REACH_NLRI has a reserved field that \"MUST be set to 0, and SHOULD be ignored upon receipt\". If a BGPsec speaker receives an update where reserved is non-zero, what should it do? With the current text, I could interpret \"SHOULD be ignored upon receipt\" as meaning either \"calculate the signature using the reserved field as received\" or \"calculate the signature using all zeroes in place of the reserved field\". -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-dx-Tc24Hry-tqXtiYyvf15-Umk8","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nOn Jun 18, 2015, at 5:15 AM, Christopher Morrow <morrowc.lists@gmail.com> wrote: I think this means you are asking for a WGLC, yes? Not necessarily. The draft went into wglc in January. Matt discussed his planned response to the comments received at IETF92. This version includes those changes. If so we can ship a note to the list (here) about that... I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. Anyone who commented on draft-ietf-sidr-bgpsec-protocol-11.txt is encouraged to review this version and report if your comments have or have not been addressed. The chairs will be reviewing this version as well. --Sandy, speaking as a wg co-chair - Matt Lepinski _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-3kfydosmcam4i6eDyEsb7hhwoFA","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nI think this means you are asking for a WGLC, yes? If so we can ship a note to the list (here) about that... I have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-hCWcf5bwNViBMSQbA7LSK-AeQBc","title":"","text":"[sidr] New Version: draft-ietf-sidr-bgpsec-protocol-12\nI have submitted a new version of the BGPsec protocol specification. This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed. The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature) I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed. - Matt Lepinski I have submitted a new version of the BGPsec protocol specification.This version includes some minor fixes as well as all of the changes discussed at IETF 92. (Minutes can be found here -- http:\/\/www.ietf.org\/proceedings\/92\/minutes\/minutes-92-sidr) I believe that all open issues with this document have been addressed.The only normative changes in the -12 version are the following: -- BGPsec speakers MUST support the multi-protocol extension (RFC 4760) -- BGPsec now signs the entire MP_REACH_NLRI attribute. (Recall that there was an error previously where the AFI was not protected under the signature)I believe that this document is now ready to ship to the IESG. If you disagree, please let me know what still needs to be addressed.- Matt Lepinski"}
{"_id":"doc-en-sidr-Bt-57fSJCCLay7yoPWnabf3c3hI","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-12.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPsec Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-12.txt Pages : 38 Date : 2015-06-14 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-12 A diff from the previous version is available at: https:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-12 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr--hGUMSbIN07GTm_GenwQ_hfYHR4","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIn practice, what will happen very soon is that there will be a BGPsec core with non-BGPsec leaves and branches. That is a possibility. To encourage leaves (stub ASes) to get on board with BGPsec, the specification allows for BGPsec capability to be negotiated independently in each direction (send and receive). This means that a stub AS can negotiate with its upstream to send signed updates (to the upstream) but receive only unsigned updates (i.e. trusts its upstream). Thus it avoids processing and memory costs associated with processing signed updates and storing them. This facilitates the stub AS to avoid expensive HW upgrade, but still benefit from BGPsec. Please see Section 2 of the BGPsec specification. Also see Sections 6.5 and 6.6 in the BGPSEC design discussion document: http:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-07#page-21 Sure. But what if one of those BGPsec-capable ASes has a customer that doesn't run BGPsec? So: 5+ 4+ 3+ 2+ 1- (where + is BGPsec and - is no BGPsec) In this case the entire path will be unprotected, even though four of the five ASes in the path are capable of using BGPsec. I fair argument can be made that if it's only the origin AS that's non-BGPsec, the protection afforded is very nearly as good as in the case where the complete path is BGPsec-protected. Steve Kent summed it up nicely (in his most recent post on the SIDR list) about the pitfalls of allowing partial path signing. In your specific example above, let us say, there is also an 8+ who is *malicious* and a BGPsec neighbor of 5+. 8+ does not peer with 1-, but nevertheless sends an update with the following malicious AS path to 5+: 8+ 1- (for the same NLRI as in your example above) 8+ is basically faking that it got an unsigned update from 1- and it is forwarding the same to 5+ with a signature (i.e. 8+ signing to 5+). How will 5+ know that the partially signed update with AS path of {4+ 3+ 2+ 1-} is legitimate and that the other partially signed update with AS path {8+ 1-} is malicious? It has no way of knowing that. Sriram"}
{"_id":"doc-en-sidr-pIPZWvy0N7cE0x1T9cL95UwhRPQ","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIljitsch, The topic of partial path signing was explored in detail and rejected for a couple of reasons. It was way too complex to figure out how an AS could rely on partial path sig info, and there appeared to be a lot of ways to exploit the new attack surfaces created by partially signed paths. Steve"}
{"_id":"doc-en-sidr-icsSNnzlqgzET5qi_XVW3mFHznY","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\n“path that is partially BGPsec protected” – I wouldn’t call that “partial deployment”. That is just partial path signing. The latter is a way to allow for the former. Partial deployment, on the other hand, connotes that there are islands within which BGPsec is deployed, and the rest of Internet is non-BGPsec. Hm, could be islands of BGPsec in a non-BGPsec sea or islands of non-BGPsec in a BGPsec sea. In practice, what will happen very soon is that there will be a BGPsec core with non-BGPsec leaves and branches. (1) Incremental Deployment: BGPsec is amenable to incremental deployment, and does provide benefit to early adopters within BGPsec islands. For examples, you can have a BGPsec island in Asia in which, say, 30K prefixes are originated. And another BGPsec island in Europe in which, say, 50K prefixes are originated. All prefix-routes for those 30K (or 50K) prefixes within an island have the full protection of BGPsec while they originate from an AS within the island and propagate fully signed to other ASes within the same island. Sure. But what if one of those BGPsec-capable ASes has a customer that doesn't run BGPsec? So: 5+ 4+ 3+ 2+ 1- (where + is BGPsec and - is no BGPsec) In this case the entire path will be unprotected, even though four of the five ASes in the path are capable of using BGPsec. I fair argument can be made that if it's only the origin AS that's non-BGPsec, the protection afforded is very nearly as good as in the case where the complete path is BGPsec-protected. And in general it would be better for BGPsec to be more opportunistic and protect whatever it can protect, even if that falls short of full end-to-end protection. Every protected hop takes away an opportunity for malicious parties to do bad things."}
{"_id":"doc-en-sidr-hd4H-XsqghNgGrIbjSVJD8sfZaY","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIljitsch, For path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.) I think expired certificates qualifies. And a case can be made for strong crypto algo vs weak crypto algo is a fourth one. I'm puzzled by the comment re crypto strength. We don't have the TLS situation where there are lots of alg suites. We have one suite, and a well-documented (RFC 6915) process for transitioning to a next suite. Steve"}
{"_id":"doc-en-sidr-fe55BR5ddTuzz3NQVfz9vzexRAI","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIt would have been better if BGPsec would have had provisions for partial deployment, so that you can have a path that is partially BGPsec protected even if it can't be fully be BGPsec-protected. That way, the filtering issue shrinks in scope as the BGPsec-enabled core grows and non-BGPsec branches turn into leaves and finally go away. “path that is partially BGPsec protected” – I wouldn’t call that “partial deployment”. That is just partial path signing. Partial deployment, on the other hand, connotes that there are islands within which BGPsec is deployed, and the rest of Internet is non-BGPsec. In this sense, partial deployment is synonymous with incremental deployment. Let us discuss incremental deployment and “path that is partially BGPsec protected” separately. (1) Incremental Deployment: BGPsec is amenable to incremental deployment, and does provide benefit to early adopters within BGPsec islands. For examples, you can have a BGPsec island in Asia in which, say, 30K prefixes are originated. And another BGPsec island in Europe in which, say, 50K prefixes are originated. All prefix-routes for those 30K (or 50K) prefixes within an island have the full protection of BGPsec while they originate from an AS within the island and propagate fully signed to other ASes within the same island. When those prefix-routes cross from a BGPsec island into non-BGPsec Internet, then they lose the signatures entirely and lose the protection. Down the road, when ASes from the two islands in this example interconnect using BGPsec peering, then the combined BGPsec island will be much bigger, providing protection for prefix-routes for all 80K prefixes while they originate from an AS within the combined island and propagate fully signed to other ASes within the combined island. So incremental deployment can start within islands, and grow as islands expand and\/or interconnect with each other. Some additional thoughts on incremental deployment can be found in Section 6.3 of the BGPSEC design discussion document: https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-07#page-21 (2) “path that is partially BGPsec protected” or Partial Path Signing If an update with partially signed path is given some sort of preference over an unsigned update that would encourage cut-and-paste attacks. Additional thoughts on why partial path signing is disallowed can be found in Section 6.4 of the BGPSEC design discussion document: https:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-07#page-21 Sriram"}
{"_id":"doc-en-sidr-tIyObrF82SPUUdLVJAxQXkl0jmE","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nYou are certainly correct that there are Nine possible states (and Randy's table is correct). Randy's table? I must have missed that one. That being said, I have some concern about treating \"Path Unsigned\" differently than \"Path Not Valid\", since it is trivial for a malicious adversary to transform \"Path Not Valid\" into \"Path Unsigned\" if doing so will yield better treatment for some bad route. That's a good point. But then, how do you treat those? By filtering the affected prefixes? You can only do that once _all_ paths are signed. So basically, we're stuck with our AS path filters until BGPsec deployment hits 100%. It would have been better if BGPsec would have had provisions for partial deployment, so that you can have a path that is partially BGPsec protected even if it can't be fully be BGPsec-protected. That way, the filtering issue shrinks in scope as the BGPsec-enabled core grows and non-BGPsec branches turn into leaves and finally go away."}
{"_id":"doc-en-sidr-JBN-zVF4bwemR0Cjze2NXdNjeF8","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nMy apologies for dropping the distinction between \"Path Unsigned\" (no BGPsec attribute) vs \"Path Not Valid\" (Path validation algorithm fails to validate). You are certainly correct that there are Nine possible states (and Randy's table is correct). That being said, I have some concern about treating \"Path Unsigned\" differently than \"Path Not Valid\", since it is trivial for a malicious adversary to transform \"Path Not Valid\" into \"Path Unsigned\" if doing so will yield better treatment for some bad route. On Thu, Apr 30, 2015 at 4:39 PM, Iljitsch van Beijnum <iljitsch@muada.com> wrote: On 30 Apr 2015, at 19:48, Matthew Lepinski <mlepinski.ietf@gmail.com> wrote: For path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.) I think expired certificates qualifies. And a case can be made for strong crypto algo vs weak crypto algo is a fourth one. This means that there are six possible states that come from SIDR validation (assuming you are using both origin validation and path validation). That is, three possible origin validation states and two possible path validation states yields six possible joint states. Actually nine, assuming < 100% BGPsec deployment: 1. BGPsec=valid, RPKI=valid 2. BGPsec=valid, RPKI=unknown 3. BGPsec=valid, RPKI=invalid 4. no BGPsec, RPKI=valid 5. no BGPsec, RPKI=unknown 6. no BGPsecd, RPKI=invalid 7. BGPsec=notvalid, RPKI=valid 8. BGPsec=notvalid, RPKI=unknown 9. BGPsec=notvalid, RPKI=invalid Only with type 1 can we be sure that the prefix is advertised legitimately. Type 5 indicates no BGPsec or RPKI deployment and may or may not be legitimate. These should have a lower local_pref than type 1. Type 2 is strange, but can probably be treated the same as type 5, or perhaps a loc_pref higher than 5 but lower than 1. Types 3, 6 and 9 are bad news, as they may be unauthorized more specifics, so it's important to filter these. Type 4 can happen because BGPsec hasn't been fully deployed yet (remember that the whole path must support it while RPKI can be deployed by just the \"end\" AS) but once that's no longer common it will be the attack vector of choice because it's easy to fake the origin AS if there's no BGPsec, so at some point, these need to be filtered, too. That leaves 7 and 8, which SHOULD be filtered if they're legitimate BGPsec validation failures and not incidental mistakes such as expired certificates. it is perfectly fine for different operators to handle such cases differently.) Famous last words. Obviously we don't want to be overly prescriptive, but I don't think there's as much room for creativity as you suggest. However, personally, for path validation, I would not recommend throwing out all route advertisements where path validation returns invalid. That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Actually I don't think that case can happen. Consider the following path: 6 5 4 3 2 1 If AS 4 doesn't support BGPsec but the others do, then AS 3 will convert the BGPsec_Path to an AS_PATH, removing all the signatures. ASes 5 and 6 are not in the position to repair this, so as far as they're concerned, the path is completely unprotected. However, what you say here is problematic: That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Considering whether a route is \"the only route you know\" is explicitly forbidden by RFC 4271: \"The function that calculates the degree of preference for a given route SHALL NOT use any of the following as its inputs: the existence of other routes, the non-existence of other routes, or the path attributes of other routes.\" However, you can get the same result by simply giving the invalid path a low local preference. However 2, the real problem with allowing prefixes that don't RPKI\/BGPsec validate is that these invalid prefixes could be more specifics of legitimate prefixes, and no matter how high the local_pref of the valid prefixes and low the local_pref of the invalid more specifics, the packets will be forwarded as per the invalid more specifics. Therefore, the only workable approach is to completely filter out prefixes that don't validate. However, the downside of such a strict policy is that if the certificates used for BGPsec signatures expire, the path will become notvalid and the associated prefixes disappear from the internet. That's why we need the ability to treat paths that don't validate because of expired certificates differently from paths that don't validate for other reasons. My apologies for dropping the distinction between \"Path Unsigned\" (no BGPsec attribute) vs \"Path Not Valid\" (Path validation algorithm fails to validate). You are certainly correct that there are Nine possible states (and Randy's table is correct).That being said, I have some concern about treating \"Path Unsigned\" differently than \"Path Not Valid\", since it is trivial for a malicious adversary to transform \"Path Not Valid\" into \"Path Unsigned\" if doing so will yield better treatment for some bad route.On Thu, Apr 30, 2015 at 4:39 PM, Iljitsch van Beijnum <iljitsch@muada.com> wrote: For path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.) I think expired certificates qualifies. And a case can be made for strong crypto algo vs weak crypto algo is a fourth one. This means that there are six possible states that come from SIDR validation (assuming you are using both origin validation and path validation). That is, three possible origin validation states and two possible path validation states yields six possible joint states. Actually nine, assuming < 100% BGPsec deployment: 1. BGPsec=valid, RPKI=valid 2. BGPsec=valid, RPKI=unknown 3. BGPsec=valid, RPKI=invalid 4. no BGPsec, RPKI=valid 5. no BGPsec, RPKI=unknown 6. no BGPsecd, RPKI=invalid 7. BGPsec=notvalid, RPKI=valid 8. BGPsec=notvalid, RPKI=unknown 9. BGPsec=notvalid, RPKI=invalid Only with type 1 can we be sure that the prefix is advertised legitimately. Type 5 indicates no BGPsec or RPKI deployment and may or may not be legitimate. These should have a lower local_pref than type 1. Type 2 is strange, but can probably be treated the same as type 5, or perhaps a loc_pref higher than 5 but lower than 1. Types 3, 6 and 9 are bad news, as they may be unauthorized more specifics, so it's important to filter these. Type 4 can happen because BGPsec hasn't been fully deployed yet (remember that the whole path must support it while RPKI can be deployed by just the \"end\" AS) but once that's no longer common it will be the attack vector of choice because it's easy to fake the origin AS if there's no BGPsec, so at some point, these need to be filtered, too. That leaves 7 and 8, which SHOULD be filtered if they're legitimate BGPsec validation failures and not incidental mistakes such as expired certificates. it is perfectly fine for different operators to handle such cases differently.) Famous last words. Obviously we don't want to be overly prescriptive, but I don't think there's as much room for creativity as you suggest. However, personally, for path validation, I would not recommend throwing out all route advertisements where path validation returns invalid. That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Actually I don't think that case can happen. Consider the following path: 6 5 4 3 2 1 If AS 4 doesn't support BGPsec but the others do, then AS 3 will convert the BGPsec_Path to an AS_PATH, removing all the signatures. ASes 5 and 6 are not in the position to repair this, so as far as they're concerned, the path is completely unprotected. However, what you say here is problematic: That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Considering whether a route is \"the only route you know\" is explicitly forbidden by RFC 4271: \"The function that calculates the degree of preference for a given route SHALL NOT use any of the following as its inputs: the existence of other routes, the non-existence of other routes, or the path attributes of other routes.\" However, you can get the same result by simply giving the invalid path a low local preference. However 2, the real problem with allowing prefixes that don't RPKI\/BGPsec validate is that these invalid prefixes could be more specifics of legitimate prefixes, and no matter how high the local_pref of the valid prefixes and low the local_pref of the invalid more specifics, the packets will be forwarded as per the invalid more specifics. Therefore, the only workable approach is to completely filter out prefixes that don't validate. However, the downside of such a strict policy is that if the certificates used for BGPsec signatures expire, the path will become notvalid and the associated prefixes disappear from the internet. That's why we need the ability to treat paths that don't validate because of expired certificates differently from paths that don't validate for other reasons."}
{"_id":"doc-en-sidr-lFkhAMzD-LmImPwY5yOSyFT1iRU","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nFor path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.) I think expired certificates qualifies. And a case can be made for strong crypto algo vs weak crypto algo is a fourth one. This means that there are six possible states that come from SIDR validation (assuming you are using both origin validation and path validation). That is, three possible origin validation states and two possible path validation states yields six possible joint states. Actually nine, assuming < 100% BGPsec deployment: 1. BGPsec=valid, RPKI=valid 2. BGPsec=valid, RPKI=unknown 3. BGPsec=valid, RPKI=invalid 4. no BGPsec, RPKI=valid 5. no BGPsec, RPKI=unknown 6. no BGPsecd, RPKI=invalid 7. BGPsec=notvalid, RPKI=valid 8. BGPsec=notvalid, RPKI=unknown 9. BGPsec=notvalid, RPKI=invalid Only with type 1 can we be sure that the prefix is advertised legitimately. Type 5 indicates no BGPsec or RPKI deployment and may or may not be legitimate. These should have a lower local_pref than type 1. Type 2 is strange, but can probably be treated the same as type 5, or perhaps a loc_pref higher than 5 but lower than 1. Types 3, 6 and 9 are bad news, as they may be unauthorized more specifics, so it's important to filter these. Type 4 can happen because BGPsec hasn't been fully deployed yet (remember that the whole path must support it while RPKI can be deployed by just the \"end\" AS) but once that's no longer common it will be the attack vector of choice because it's easy to fake the origin AS if there's no BGPsec, so at some point, these need to be filtered, too. That leaves 7 and 8, which SHOULD be filtered if they're legitimate BGPsec validation failures and not incidental mistakes such as expired certificates. it is perfectly fine for different operators to handle such cases differently.) Famous last words. Obviously we don't want to be overly prescriptive, but I don't think there's as much room for creativity as you suggest. However, personally, for path validation, I would not recommend throwing out all route advertisements where path validation returns invalid. That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Actually I don't think that case can happen. Consider the following path: 6 5 4 3 2 1 If AS 4 doesn't support BGPsec but the others do, then AS 3 will convert the BGPsec_Path to an AS_PATH, removing all the signatures. ASes 5 and 6 are not in the position to repair this, so as far as they're concerned, the path is completely unprotected. However, what you say here is problematic: That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. Considering whether a route is \"the only route you know\" is explicitly forbidden by RFC 4271: \"The function that calculates the degree of preference for a given route SHALL NOT use any of the following as its inputs: the existence of other routes, the non-existence of other routes, or the path attributes of other routes.\" However, you can get the same result by simply giving the invalid path a low local preference. However 2, the real problem with allowing prefixes that don't RPKI\/BGPsec validate is that these invalid prefixes could be more specifics of legitimate prefixes, and no matter how high the local_pref of the valid prefixes and low the local_pref of the invalid more specifics, the packets will be forwarded as per the invalid more specifics. Therefore, the only workable approach is to completely filter out prefixes that don't validate. However, the downside of such a strict policy is that if the certificates used for BGPsec signatures expire, the path will become notvalid and the associated prefixes disappear from the internet. That's why we need the ability to treat paths that don't validate because of expired certificates differently from paths that don't validate for other reasons."}
{"_id":"doc-en-sidr-K0TywGx9G_n-GsABUl-uWgmhgwU","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIljitsch, Thank you for the feedback. With regards to bgpsec-protocol and\/or bgpsec-overview, I am not sure what text would be helpful. For path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.) This means that there are six possible states that come from SIDR validation (assuming you are using both origin validation and path validation). That is, three possible origin validation states and two possible path validation states yields six possible joint states. Of course, one's local policy is free to collapse that state-space if they wish to treat of some of those states as identical. (Perhaps if origin is invalid, then it doesn't matter whether path is valid or not ... maybe it is foolish to care about whether there are signatures on a path if the path is headed to a bad destination. I don't know ... but it is a matter of local policy, and it is perfectly fine for different operators to handle such cases differently.) In any case, with regards to path validation, I think that in general one wants to prefer routes with valid, signed paths over routes that lack valid, signed paths. However, personally, for path validation, I would not recommend throwing out all route advertisements where path validation returns invalid. That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. (But again, this is a matter of local policy, and I don't want to mandate policy decisions for network operators in the base protocol specification.) - Matt Lepinski On Tue, Apr 28, 2015 at 2:01 PM, Iljitsch van Beijnum <iljitsch@muada.com> wrote: On 28 Jan 2015, at 23:38, Sandra Murphy <sandy@tislabs.com> wrote: idr folk, your attention and comments would be appreciated as well. Since you ask... I'm sending this to both idr and sidr as I think this needs broader input than just sidr. (And it seems I'm no longer on the sidr list.) I read draft-ietf-sidr-bgpsec-protocol-11 and draft-lepinski-bgpsec-overview-00.txt as well as RFC 6483. I think what's lacking here is any discussion of what happens when certificates etc expire. Please stay with me for a bit: RFC 6483 talks about RPKI route validation, which suggests that there are three possible states: valid unknown invalid where valid is preferred over unknown and unknown over invalid, and: \"It is a matter of local routing policy as to whether routes with an \"invalid\" validity state are considered to be ineligible for further consideration in a route selection process.\" Actually, I think the only reasonable approach is to filter out invalids and prefer valids over unknowns. The important part here is that if there's a ROA for 193.0.0.0\/21 and then someone announces a more specific like 193.0.7.0\/24, that \/24 will be \"invalid\", so even in partial deployment RPKI users are protected against malicious or accidental more specifics. But if invalids are accepted, even with a very low preference, then they still get to divert traffic. So far, so good. But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem... So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.) _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Iljitsch,Thank you for the feedback. With regards to bgpsec-protocol and\/or bgpsec-overview, I am not sure what text would be helpful.For path validation (as opposed to origin validation), the path validation algorithm returns one of two states. That is, either an update has a valid signed path or it doesn't. (We discussed previously in SIDR whether there was a useful third case for path validation, and the working group wasn't able to come up with one.)This means that there are six possible states that come from SIDR validation (assuming you are using both origin validation and path validation). That is, three possible origin validation states and two possible path validation states yields six possible joint states. Of course, one's local policy is free to collapse that state-space if they wish to treat of some of those states as identical. (Perhaps if origin is invalid, then it doesn't matter whether path is valid or not ... maybe it is foolish to care about whether there are signatures on a path if the path is headed to a bad destination. I don't know ... but it is a matter of local policy, and it is perfectly fine for different operators to handle such cases differently.)In any case, with regards to path validation, I think that in general one wants to prefer routes with valid, signed paths over routes that lack valid, signed paths. However, personally, for path validation, I would not recommend throwing out all route advertisements where path validation returns invalid. That is, if the only route you know of to get to a particular block of address space has a signature that doesn't valid (or lack signatures because someone in the middle doesn't have BGPsec turned on), I think it is probably a good idea to use that route despite the lack of valid signature chain. (But again, this is a matter of local policy, and I don't want to mandate policy decisions for network operators in the base protocol specification.)- Matt LepinskiOn Tue, Apr 28, 2015 at 2:01 PM, Iljitsch van Beijnum <iljitsch@muada.com> wrote: idr folk, your attention and comments would be appreciated as well. Since you ask... I'm sending this to both idr and sidr as I think this needs broader input than just sidr. (And it seems I'm no longer on the sidr list.) I read draft-ietf-sidr-bgpsec-protocol-11 and draft-lepinski-bgpsec-overview-00.txt as well as RFC 6483. I think what's lacking here is any discussion of what happens when certificates etc expire. Please stay with me for a bit: RFC 6483 talks about RPKI route validation, which suggests that there are three possible states: valid unknown invalid where valid is preferred over unknown and unknown over invalid, and: \"It is a matter of local routing policy as to whether routes with an \"invalid\" validity state are considered to be ineligible for further consideration in a route selection process.\" Actually, I think the only reasonable approach is to filter out invalids and prefer valids over unknowns. The important part here is that if there's a ROA for 193.0.0.0\/21 and then someone announces a more specific like 193.0.7.0\/24, that \/24 will be \"invalid\", so even in partial deployment RPKI users are protected against malicious or accidental more specifics. But if invalids are accepted, even with a very low preference, then they still get to divert traffic. So far, so good. But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem... So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.) _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-TmZE-3DkmZ2qMhkjwcZZhrljWXU","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nHi, First: There should be operational BCP recommendation based on the principle of make-before-break ( in doc like https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops-05 ): 1. Certificate should be renewed and pre-published in advance of expiry of the current certificate; There should be overlapping validity period bridging the two (current and new certs). (See https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-rollover-03 and https:\/\/www.ietf.org\/proceedings\/92\/slides\/slides-92-sidr-5.pdf ) 2. The update for the prefix should be re-originated (by origin AS) or re-propagated (by a transit AS). Basically, whoever got a new certificate should do this refresh within the above overlap period. The above two BCP steps, if followed, will help prevent \"couldn't validate because of certificate lifetime\". Second: The operational BCP can also say: Allow a certain grace period before you act on the update that became 'Not Valid' due to cert expiry. (Earlier Sandy also mentioned this.) Your other scenario \"validation failed because of a bad signature or bad certificate chain\" is fine. In this scenario, the update is labeled 'Not Valid' for good reason. From: Randy Bush <randy@psg.com> Subject: Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation, was: Re: wglc for draft-ietf-sidr-bgpsec-protocol-11 To: Roque Gagliano <rogaglia@cisco.com> Cc: idr wg <idr@ietf.org>, sidr wg <sidr@ietf.org> Date: Wed, 29 Apr 2015 12:07:02 +0900 ca software should warn the user of upcoming expiration of certs, ee certs, roas, crls, drivers' licenses, ... but what is the user gonna do? they're gonna renew. so maybe renew automagically and tell the user? For the record in the RIPE NCC software we automagically re-issue CA certificates to members 6 months before they expire (and log errors in case of problems, so we have time to respond). Our system currently only supports non-hosted setups where a member runs their own remote CA in our pilot environment, but there too we pro-actively re-issue.. we don't tell the CA because in the provisioning protocol model the child CA can contact us, but we can't contact them. We do tell them about the new certificate when the CA queries, as they do regularly. We believe that this is safe to do. The new certificate is equivalent in every way to the last requested and issued certificate except that the validity time is longer, so we don't see any scenario where the child would not agree to this - i.e. we can be pro-active. For hosted member CAs we also re-issue ROAs 6 months before the expire, and we re-issue MFTs 16 hours before their 'next update time' and 6 days and 16 hours before their EE certificate expiration. randy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-wTPDGNC6KFoHgq_nwBw8_JNtg5M","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nFirst: There should be operational BCP recommendation based on the principle of make-before-break ( in doc like https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops-05 ): 1. Certificate should be renewed and pre-published in advance of expiry of the current certificate; There should be overlapping validity period bridging the two (current and new certs). (See https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-rollover-03 and https:\/\/www.ietf.org\/proceedings\/92\/slides\/slides-92-sidr-5.pdf ) 2. The update for the prefix should be re-originated (by origin AS) or re-propagated (by a transit AS). Basically, whoever got a new certificate should do this refresh within the above overlap period. The above two BCP steps, if followed, will help prevent \"couldn't validate because of certificate lifetime\". Second: The operational BCP can also say: Allow a certain grace period before you act on the update that became 'Not Valid' due to cert expiry. (Earlier Sandy also mentioned this.) Your other scenario \"validation failed because of a bad signature or bad certificate chain\" is fine. In this scenario, the update is labeled 'Not Valid' for good reason. From: Randy Bush <randy@psg.com> Subject: Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation, was: Re: wglc for draft-ietf-sidr-bgpsec-protocol-11 To: Roque Gagliano <rogaglia@cisco.com> Cc: idr wg <idr@ietf.org>, sidr wg <sidr@ietf.org> Date: Wed, 29 Apr 2015 12:07:02 +0900 ca software should warn the user of upcoming expiration of certs, ee certs, roas, crls, drivers' licenses, ... but what is the user gonna do? they're gonna renew. so maybe renew automagically and tell the user? randy"}
{"_id":"doc-en-sidr-shIMrwavuzsfMjrG6djeviGxEgY","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nThe above two BCP steps, if followed, will help prevent \"couldn't validate because of certificate lifetime\". Of course, most of the time this would happen correctly. People aren't stupid. But experience with HTTPS has shown that expired certificates can't be prevented 100%, and with routing the results are much more severe than with the web, as the user can't decide to go ahead anyway. The user wouldn't even know what happened. And fixing the problem may not be possible because of the unreachability caused by the problem. Second: The operational BCP can also say: Allow a certain grace period before you act on the update that became 'Not Valid' due to cert expiry. (Earlier Sandy also mentioned this.) Ok. So what do you propose? That a path with signatures based on expired certificates remains \"valid\" for some additional grace period? Then you simply postpone the problem by that period. Or should operators have a way to differentiate between paths that are actually invalid and paths that are merely affected by expired certificates? In that case we are saying the same thing. It might even be useful to have valid \/ expired-but-otherwise-valid \/ unknown \/ invalid rather than valid \/ unknown \/ invalid. Or maybe valid-algo1 \/ valid-algo2 \/ expired-but-otherwise-valid \/ unknown \/ invalid, so I can prefer paths protected with the strongest hashing algorithm over paths protected with a weaker algorithm and those over paths protected with expired certificates and those over paths not protected by BGPsec. (IMO invalid paths should not be allowed at all.) Iljitsch"}
{"_id":"doc-en-sidr-cPNX6epUtrSm3egxIiAjBIvxRxs","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nSo what we need is a third option, that provides better security than 1. and better reachability than 2. In other words, \"couldn't validate because of certificate lifetime\" and \"validation failed because of a bad signature or bad certificate chain\" are different enough that we need them to have different effects on the forwarding tables. My thoughts on this: First: There should be operational BCP recommendation based on the principle of make-before-break ( in doc like https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops-05 ): 1. Certificate should be renewed and pre-published in advance of expiry of the current certificate; There should be overlapping validity period bridging the two (current and new certs). (See https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-rollover-03 and https:\/\/www.ietf.org\/proceedings\/92\/slides\/slides-92-sidr-5.pdf ) 2. The update for the prefix should be re-originated (by origin AS) or re-propagated (by a transit AS). Basically, whoever got a new certificate should do this refresh within the above overlap period. The above two BCP steps, if followed, will help prevent \"couldn't validate because of certificate lifetime\". Second: The operational BCP can also say: Allow a certain grace period before you act on the update that became 'Not Valid' due to cert expiry. (Earlier Sandy also mentioned this.) Your other scenario \"validation failed because of a bad signature or bad certificate chain\" is fine. In this scenario, the update is labeled 'Not Valid' for good reason. Sriram"}
{"_id":"doc-en-sidr-_oiWIxq5XGRn0ENLxsm17Bg5MIk","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nThe validation in the BGPsec draft is only about the AS path signatures in signed updates. It is talking about the validity of the Secure_Path. If all the signatures in a Signature_Block are valid, then the Signature_Block (and hence Secure_Path) is 'Valid'; Else, the Signature_Block is 'Not Valid'. So how does this work when a certificate expires without a new one in place? Then the signature over a hop in the path and therefore the path and therefore one or more prefixes are now \"Not Valid\". This presents us with two choices: 1. we accept those prefixes in our forwarding tables 2. we don't accept those prefixes in our forwarding tables Obviously 1. can't be the answer, because then BGPsec is pretty much a NOP. But 2. is not so great either, because now a mistake or delay in generating and propagating certificates can cause unreachability. So what we need is a third option, that provides better security than 1. and better reachability than 2. In other words, \"couldn't validate because of certificate lifetime\" and \"validation failed because of a bad signature or bad certificate chain\" are different enough that we need them to have different effects on the forwarding tables."}
{"_id":"doc-en-sidr-9_4wmtVbFTYoa4nf49662nWNnkY","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nthis is deja vu all over again path validation has three possible results o a signed path validated o a signed path could not be validated o the path was unsigned I will add one more thing, the path was was signed\/validated when it was checked. Some prefixes are stable for very long periods of time and therefore the validation may not occur until after the expiration. I generally dislike systems that self-destruct. - Jared"}
{"_id":"doc-en-sidr-jYl29ffOh3GTRFawvny3Bef6Ai8","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nthis is deja vu all over again path validation has three possible results o a signed path validated o a signed path could not be validated o the path was unsigned randy"}
{"_id":"doc-en-sidr-c21mjwT8epKE7LZ1nNR2h0joNSQ","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nHi Iljitsch, But unless I missed something, the BGPsec drafts don't even talk about the unknown state: \"The validation procedure results in one of two states: 'Valid' and 'Not Valid'.\" I don't see any reasonable deployment scenario with only valid and invalid. I think this needs to be addressed in a BGPsec document. The validation in the BGPsec draft is only about the AS path signatures in signed updates. It is talking about the validity of the Secure_Path. If all the signatures in a Signature_Block are valid, then the Signature_Block (and hence Secure_Path) is 'Valid'; Else, the Signature_Block is 'Not Valid'. If there are two Signature_Blocks (e.g. when two different algorithms are in use) in an update, then at least one of them must be 'Valid' in order for the Secure_Path to be valid. Separately, prefix-origin validation has three possible outcomes as you have observed already. That is the topic of RFC 6483 (Informational) and RFC 6811 (Standards Track). Sriram"}
{"_id":"doc-en-sidr-XZGutftjmb88EC4pUl2JZ-RLOjA","title":"","text":"Re: [sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr]  wglc for draft-ietf-sidr-bgpsec-protocol-11\nHi Iljitsch, But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem… So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html yup, becuase an expired certificate is not used for validation of ROAs, so a route object that is only referred to by a ROA that cannot be validated is “unknown” in this taxonomy. It is not “invalid\" by virtue of an expired certificate. However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. to quote RFC6483: \"It is assumed here that a relying party (RP) has access to a local cache of the complete set of valid ROAs when performing validation of a route. (Valid ROAs are defined as ROAs that are determined to be syntactically correct and are signed using a signature that can be verified using the RPKI, as described in [RFC6482].) i.e. the route validation process that produces this set of valid, invalid and unknown outcomes is based on the set of valid ROAs. ROAs that cannot be validated (i.e. due to expired certificates and other causes) are not considered in the route validation process described in RFC6483. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. It’s not clear to me that any further text needs to be added to RFC6483. The underlying process is one based on examination of the route feed and comparing each received route object to a collection of attestations and authorities that have been validated by the relying party as trustable. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.) regards, Geoff"}
{"_id":"doc-en-sidr-rbkBRXt8eSf88mzZtN7ZLhFg3SE","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re: wglc for draft-ietf-sidr-bgpsec-protocol-11\nca software should warn the user of upcoming expiration of certs, ee certs, roas, crls, drivers' licenses, ... but what is the user gonna do? they're gonna renew. so maybe renew automagically and tell the user? randy"}
{"_id":"doc-en-sidr-wry8_J-tXtKn2yaMtR2ejtmx7BI","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nI think Roque was saying that the first outcome would be the case, not the second: You are correct and IMHO we do not need more documents. The normative text is in RFC 6482 section 4: ----------------------- 4. ROA Validation Before a relying party can use a ROA to validate a routing announcement, the relying party MUST first validate the ROA. To validate a ROA, the relying party MUST perform all the validation checks specified in [RFC6488] as well as the following additional ROA-specific validation step. o The IP address delegation extension [RFC3779] is present in the end-entity (EE) certificate (contained within the ROA), and each IP address prefix(es) in the ROA is contained within the set of IP addresses specified by the EE certificate's IP address delegation extension. ‹‹‹‹‹‹‹‹‹‹‹ Informational text is in RFC6907, section 7.2: 7.2. ROA Expiry or Receipt of a CRL Revoking a ROA Particularly, section 7.2.5 to 7.2.8 covers different expiration circumstances. ‹‹‹‹‹‹‹‹‹‹‹ Regards, Roque"}
{"_id":"doc-en-sidr-wmWGWxR8wTonhsDz9imznEl5gQs","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nspeaking as regular ol' member: On Apr 28, 2015, at 3:21 PM, Iljitsch van Beijnum <iljitsch@muada.com> wrote: It is not an implementation choice, it is by design. If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. No... Suppose: ROA: 193.0.0.0\/21 up to \/21 -> AS 3333 not valid after 20150430 BGP table 29 april: 193.0.0.0\/21 3333 -> valid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown But, two days later, after the ROA expires, do we have this: 193.0.0.0\/21 3333 -> unknown 193.0.0.0\/21 4444 -> unknown 193.0.7.0\/24 3333 -> unknown 192.0.0.0\/16 5555 -> unknown or this: 193.0.0.0\/21 3333 -> invalid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown ? You seem to be saying the second, but that wouldn't work, as a simple mistake would make AS 3333 unreachable. And since you need to connect to the internet in order to get a new certificate\/ROA so you can connect to the internet… I think Roque was saying that the first outcome would be the case, not the second: If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. If the ROA's EE certificate expires, then the ROA does not validate, it is like if the ROA did not exist. Which makes the first outcome, not the second. I'm not sure where you see text that implies that the second outcome would happen. We have left the idea of how fast expiration takes effect up to implementation. If the implementation immediately trashes an expired EE cert, then you lose the ROA, and the 3333 route would be \"unknown\". If the implementation keeps the EE cert around (until next clock chime? next sync interval? until it sees a reissue or a CRL?), then you keep the ROA, and the 3333 route would be \"valid\". In neither case does the 3333 route become \"invalid\". To get a result of \"invalid\" for 3333 for the \/21 requires that you found a ROA that authorizes some other AS for the \/21 and no ROA that authorizes 3333 for the \/21. The NANOG link I posted says it's the first case, which would be much more workable in practice: in that case, if a certificate expires before a new one is installed, you lose security but not connectivity. Since that's what I think happens and what you think should happen, we're good! Note also that the approach suggested in RFC 6483 and Cisco and Juniper documentation, where valid > unknown > invalid is not workable because then can still have traffic flow towards more specific prefixes even though they're invalid and have a very low local preference. The nice thing about RPKI is that you can deploy it TODAY if you filter invalids with the huge upside that you get rid of unauthorized more specifics, incurring only the very small risk that someone creates ROAs that conflict with their advertisements. Some people think depref-ing invalids is a safer alternative than outright dropping them. There's evidence that people are creating ROAs for their own announcement but forgetting the more specific prefixes they've sub allocated to customers, where the customer are announcing from their own AS but not doing ROAs. The ROA for the aggregate makes the customer's announcement look invalid. Or maybe that's what you mean by \"get rid of unauthorized more specifics\" and you think that's a good outcome. As we've successfully run BGP for 25 years without security, that's bad, but preferable to being unreachable. I'm not sure you'd be unreachable. In this day and age, if there's an aggregate prefix that includes yours, then you got your prefix from the holder of the aggregate. And in (most?) cases, you have connectivity to the holder of the aggregate. So you are reachable through them. (Since IAmNotAnOperator (IANAO), any remark I make about operations should be checked with someone who is.) Not reachable through your backup provider, but that's maybe not so bad. If you took their\/your more specific prefix and walked and no longer have connectivity thru the aggregate holder, well, … just deserts? Speculation on my part. But the real issue is that this isn't written down anywhere as far as I can tell, so we're dependent on implementers all independently coming up with the preferred way to handle this. That's never good business for a standards organization. I don't agree that it is not written down anywhere. I think the certificate checking and the BGP route checking are both clear in the cases you lay out. --Sandy, speaking as regular ol' member"}
{"_id":"doc-en-sidr-Um0h2RbY1Nlaz4THN7LWr9s_YbI","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nBased on the two snippets above, I do think it's clear enough for implementations to get it right. Yes, looks like it's indeed in there if you read closely. However, you asked a good question that other people will probably ask again. Do you think it would be helpful to make this case more explicit somewhere? I think making this more explicit in an update of RFC 6483 would be helpful. But unless I missed something, the BGPsec drafts don't even talk about the unknown state: \"The validation procedure results in one of two states: 'Valid' and 'Not Valid'.\" I don't see any reasonable deployment scenario with only valid and invalid. I think this needs to be addressed in a BGPsec document."}
{"_id":"doc-en-sidr-ALgEeXqa62P5oNfPq1RWHiKuRUY","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nOn 2015-04-28 15:21, Iljitsch van Beijnum wrote: It is not an implementation choice, it is by design. If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. No... Suppose: ROA: 193.0.0.0\/21 up to \/21 -> AS 3333 not valid after 20150430 In your example, is this the only ROA with a prefix that covers 193.0.0.0\/21 or is covered by 193.0.0.0\/21? Based on the states below, I'm assuming it is. Please correct me if I'm wrong. BGP table 29 april: 193.0.0.0\/21 3333 -> valid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown This part looks right to me. But, two days later, after the ROA expires, do we have this: 193.0.0.0\/21 3333 -> unknown 193.0.0.0\/21 4444 -> unknown 193.0.7.0\/24 3333 -> unknown 192.0.0.0\/16 5555 -> unknown or this: 193.0.0.0\/21 3333 -> invalid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown ? [snip] But the real issue is that this isn't written down anywhere as far as I can tell, so we're dependent on implementers all independently coming up with the preferred way to handle this. That's never good business for a standards organization. It's the first one (all unknowns). I don't think this is written down explicitly, but if implementations follow RFC6483, I don't think there's any way they can get the second result. From RFC6483, Section 2: It is assumed here that a relying party (RP) has access to a local cache of the complete set of valid ROAs when performing validation of a route. (Valid ROAs are defined as ROAs that are determined to be syntactically correct and are signed using a signature that can be verified using the RPKI, as described in [RFC6482].) The RP needs to match a route to one or more valid candidate ROAs in order to determine a validation outcome, which, in turn, can be used to determine the appropriate local actions to perform on the route. This means that only valid (non-expired) ROAs are used for origin validation. Like Roque said, \"if a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed.\" Then, in the next paragraph: However, routes for address prefixes that are not fully described by any single ROA (i.e., those routes whose address prefixes may be an aggregate of address prefixes described in a valid ROA, or have address prefixes where there is no intersection with any valid ROA), and are not matched by any valid ROA and do not have an address prefix that is a more specific address prefix described in any valid ROA, cannot be reliably classified as \"invalid\" in a partial deployment scenario. Such routes have a validation outcome of \"unknown\". Since the {AS 3333, 193.0.0.0\/21-21} ROA expired, there's no *valid* ROA that intersects any of {193.0.0.0\/21, 193.0.0.0\/21, 193.0.7.0\/24, 192.0.0.0\/16}. (See my assumption above about no other ROAs for these prefixes.) Since none of these four prefixes intersect any prefix in any valid ROA, all four routes you gave are unknown. Based on the two snippets above, I do think it's clear enough for implementations to get it right. However, you asked a good question that other people will probably ask again. Do you think it would be helpful to make this case more explicit somewhere? -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-vQFWdZcFFuwScBRZr8wcNcY6HBQ","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nIt is not an implementation choice, it is by design. If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. No... Suppose: ROA: 193.0.0.0\/21 up to \/21 -> AS 3333 not valid after 20150430 BGP table 29 april: 193.0.0.0\/21 3333 -> valid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown But, two days later, after the ROA expires, do we have this: 193.0.0.0\/21 3333 -> unknown 193.0.0.0\/21 4444 -> unknown 193.0.7.0\/24 3333 -> unknown 192.0.0.0\/16 5555 -> unknown or this: 193.0.0.0\/21 3333 -> invalid 193.0.0.0\/21 4444 -> invalid 193.0.7.0\/24 3333 -> invalid 192.0.0.0\/16 5555 -> unknown ? You seem to be saying the second, but that wouldn't work, as a simple mistake would make AS 3333 unreachable. And since you need to connect to the internet in order to get a new certificate\/ROA so you can connect to the internet... The NANOG link I posted says it's the first case, which would be much more workable in practice: in that case, if a certificate expires before a new one is installed, you lose security but not connectivity. As we've successfully run BGP for 25 years without security, that's bad, but preferable to being unreachable. Note also that the approach suggested in RFC 6483 and Cisco and Juniper documentation, where valid > unknown > invalid is not workable because then can still have traffic flow towards more specific prefixes even though they're invalid and have a very low local preference. The nice thing about RPKI is that you can deploy it TODAY if you filter invalids with the huge upside that you get rid of unauthorized more specifics, incurring only the very small risk that someone creates ROAs that conflict with their advertisements. But the real issue is that this isn't written down anywhere as far as I can tell, so we're dependent on implementers all independently coming up with the preferred way to handle this. That's never good business for a standards organization."}
{"_id":"doc-en-sidr-_HD0c9m1Vg-mxPXNzbJ4jkWq_u4","title":"","text":"Re: [sidr] [Idr] Levels of BGPsec\/RPKI validation,\n was: Re:   wglc for draft-ietf-sidr-bgpsec-protocol-11\nIljitsu, It is not an implementation choice, it is by design. If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. I guess your point is covered. Roque Sent from my HTC ----- Reply message ----- From: \"Iljitsch van Beijnum\" <iljitsch@muada.com> To: \"Sandra Murphy\" <sandy@tislabs.com> Cc: \"idr@ietf.org wg\" <idr@ietf.org>, \"ggm@apnic.net\" <ggm@apnic.net>, \"sidr@ietf.org\" <sidr@ietf.org> Subject: [Idr] Levels of BGPsec\/RPKI validation, was: Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11 Date: Tue, Apr 28, 2015 20:02 On 28 Jan 2015, at 23:38, Sandra Murphy <sandy@tislabs.com> wrote: idr folk, your attention and comments would be appreciated as well. Since you ask... I'm sending this to both idr and sidr as I think this needs broader input than just sidr. (And it seems I'm no longer on the sidr list.) I read draft-ietf-sidr-bgpsec-protocol-11 and draft-lepinski-bgpsec-overview-00.txt as well as RFC 6483. I think what's lacking here is any discussion of what happens when certificates etc expire. Please stay with me for a bit: RFC 6483 talks about RPKI route validation, which suggests that there are three possible states: valid unknown invalid where valid is preferred over unknown and unknown over invalid, and: \"It is a matter of local routing policy as to whether routes with an \"invalid\" validity state are considered to be ineligible for further consideration in a route selection process.\" Actually, I think the only reasonable approach is to filter out invalids and prefer valids over unknowns. The important part here is that if there's a ROA for 193.0.0.0\/21 and then someone announces a more specific like 193.0.7.0\/24, that \/24 will be \"invalid\", so even in partial deployment RPKI users are protected against malicious or accidental more specifics. But if invalids are accepted, even with a very low preference, then they still get to divert traffic. So far, so good. But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem... So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.) _______________________________________________ Idr mailing list Idr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/idr Iljitsu, It is not an implementation choice, it is by design. If a signed object does not validate (based on whatever reason not just expiration), it is like if did not existed. I guess your point is covered. Roque Sent from my HTC ----- Reply message ----- From: \"Iljitsch van Beijnum\" <iljitsch@muada.com> To: \"Sandra Murphy\" <sandy@tislabs.com> Cc: \"idr@ietf.org wg\" <idr@ietf.org>, \"ggm@apnic.net\" <ggm@apnic.net>, \"sidr@ietf.org\" <sidr@ietf.org> Subject: [Idr] Levels of BGPsec\/RPKI validation, was: Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11 Date: Tue, Apr 28, 2015 20:02 idr folk, your attention and comments would be appreciated as well. Since you ask... I'm sending this to both idr and sidr as I think this needs broader input than just sidr. (And it seems I'm no longer on the sidr list.) I read draft-ietf-sidr-bgpsec-protocol-11 and draft-lepinski-bgpsec-overview-00.txt as well as RFC 6483. I think what's lacking here is any discussion of what happens when certificates etc expire. Please stay with me for a bit: RFC 6483 talks about RPKI route validation, which suggests that there are three possible states: valid unknown invalid where valid is preferred over unknown and unknown over invalid, and: \"It is a matter of local routing policy as to whether routes with an \"invalid\" validity state are considered to be ineligible for further consideration in a route selection process.\" Actually, I think the only reasonable approach is to filter out invalids and prefer valids over unknowns. The important part here is that if there's a ROA for 193.0.0.0\/21 and then someone announces a more specific like 193.0.7.0\/24, that \/24 will be \"invalid\", so even in partial deployment RPKI users are protected against malicious or accidental more specifics. But if invalids are accepted, even with a very low preference, then they still get to divert traffic. So far, so good. But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem... So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.) _______________________________________________ Idr mailing list Idr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/idr"}
{"_id":"doc-en-sidr-cybuhYRveX9gRGu4hfXg-7Edv9s","title":"","text":"[sidr] Levels of BGPsec\/RPKI validation,\n was: Re: [Idr]  wglc for draft-ietf-sidr-bgpsec-protocol-11\nidr folk, your attention and comments would be appreciated as well. Since you ask... I'm sending this to both idr and sidr as I think this needs broader input than just sidr. (And it seems I'm no longer on the sidr list.) I read draft-ietf-sidr-bgpsec-protocol-11 and draft-lepinski-bgpsec-overview-00.txt as well as RFC 6483. I think what's lacking here is any discussion of what happens when certificates etc expire. Please stay with me for a bit: RFC 6483 talks about RPKI route validation, which suggests that there are three possible states: valid unknown invalid where valid is preferred over unknown and unknown over invalid, and: \"It is a matter of local routing policy as to whether routes with an \"invalid\" validity state are considered to be ineligible for further consideration in a route selection process.\" Actually, I think the only reasonable approach is to filter out invalids and prefer valids over unknowns. The important part here is that if there's a ROA for 193.0.0.0\/21 and then someone announces a more specific like 193.0.7.0\/24, that \/24 will be \"invalid\", so even in partial deployment RPKI users are protected against malicious or accidental more specifics. But if invalids are accepted, even with a very low preference, then they still get to divert traffic. So far, so good. But now what if a certificate expires? We know from the web that this is extremely common. If an expired certificate means the prefixes involved are marked invalid, this means that filtering invalids becomes very problematic: not only will prefixes randomly drop off the net as people forget to generate or install certificates or RPKI caches get stale, but if things get really bad the resulting lack of connectivity makes it impossible to correct the problem... So what we need is for expired certificates to make the affected prefixes revert to unknown rather than invalid. Turns out, that's what happens today: http:\/\/mailman.nanog.org\/pipermail\/nanog\/2014-December\/071907.html However, unless this is specified in one of the related documents other than the three mentioned above, this seems to be an implementation choice. I think the above issue needs to be discussed in an update of RFC 6483 or in one of the BGPsec documents. And there's probably a bit more to think about: wouldn't it make sense to be able to filter on the signature algorithm at some point during the transition from one algorithm to the next? Or to be able to filter on \"expired\" explicitly? A binary valid\/invalid isn't enough. Valid\/unknown\/invalid is workable, but maybe four or five levels is even better. (And have a look at how this works in practice: http:\/\/www.cisco.com\/c\/en\/us\/td\/docs\/ios-xml\/ios\/iproute_bgp\/command\/irg-cr-book\/bgp-m1.html search for PEX.)"}
{"_id":"doc-en-sidr-9yskMfWIVwIdkf3z4Jb8PbGM6jw","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nOn page 5, draft-ietf-sidr-bgpsec-protocol-11 says: A BGP speaker SHOULD NOT advertise the capability of BGPsec support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI combination [3]. I interpret this to mean that if a BGPsec speaker intends to send IPv4 updates to a peer, it should advertise multiprotocol extension capability with AFI = 1. That is so even when it intends to send only IPv4 updates. The fact that multiprotocol extension capability (with AFI = 1) is advertised, does it mean that MP_REACH_NLRI (see page 3, RFC 4760) should be used for announcing IPv4 prefixes? Just trying to clarify because it wasn’t clear to me reading RFC 4760. Sriram"}
{"_id":"doc-en-sidr-Y7ZoSo4KoZrc2CCigWaLENPiMFg","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nI do not have any objection to the resolutions below, but I did notice something else while looking at the NLRI processing for BGPsec. For prefixes that do not end on octet boundary, the value of the trailing bits between the end of the prefix and the octet boundary are undefined. Both RFC 4271 p20 and the multiprotocol RFC 4760 p7 use the same language, \"Note that the value of trailing bits is irrelevant.\" I was unable to find text in another RFC or within the protocol draft that explicitly sets these bits. If any of those bits get changed from what the originator signed, the signature will be invalid even though the NLRI is otherwise valid according to the RFCs. Practically speaking, these bits likely get set to zero by most (all?) routers anyway. But it would probably be good to have text in the protocol document explicitly setting them when creating signatures. Something like, \"Any trailing bits in the NLRI prefix between the prefix length and the next octet boundary are set to zero when calculating the signatures.\" -Mike On Tue, 24 Feb 2015 12:38:07 -0500, Matthew Lepinski <mlepinski.ietf@gmail.com> said: ML> I am in the process of resolving issues in the bgpsec-protocol document in ML> order to get out a new version before Dallas. ML> Based on the discussion in this thread, I believe the best way forward is: ML> 1) Add a small amount of security considerations text to address the ML> original concern that David raised. (I believe the consensus is that this ML> concern cannot be converted into an actual attack. However, other readers ML> might reasonably have the same concern as David and so there is no harm ML> laying the concern to rest in security considerations.) ML> 2) Given that origin validation is now decoupled from path validation, we ML> will put the AFI under the BGPsec signature to avoid potential IPv4 vs IPv6 ML> issues. ML> Any objections to this resolution of these issues? ML> - Matt Lepinski ML> On Tue, Feb 17, 2015 at 6:40 PM, David Mandelberg <david@mandelberg.org> ML> wrote: >> >> > I agree that the solution should not merely rely on the presence of a >> validating ROA. >> > But there is some more detail here that is worth looking into. The path >> was fully signed >> > and assume all signatures are valid. Then clearly the origin AS actually >> announced it. >> > The question or ambiguity is: Did the origin AS announce 1.2.0.0\/16 >> (v4) or 102::\/16 (v6)? >> > The ROA has AFI information, but the signed update does not (currently). >> > https:\/\/tools.ietf.org\/html\/rfc6482#section-3.3 >> > “Within the ROAIPAddressFamily structure, addressFamily contains the >> > Address Family Identifier (AFI) of an IP address family. This >> > specification only supports IPv4 and IPv6. Therefore, addressFamily >> > MUST be either 0001 or 0002.” >> > >> > Hence, as Keyur has surmised, there is a possibility that the ROA can >> help resolve the ambiguity here. >> > But the ambiguity would still persist if the same origin AS happens to >> have ROA(s) for >> > both prefixes 1.2.0.0\/16 (v4) and 102::\/16 (v6) (though the >> probability is extremely small). >> > So, yes, a robust solution calls for something more than a validating >> ROA. >> > The ambiguity goes away if the AFI (of the announced prefix) is included >> by the origin AS >> > on the wire as well as in the sequence of octets that are signed. >> >> When there's no attack, I don't think there's any ambiguity about what >> NLRI is being announced or withdrawn. RFC4760 seems to include (S)AFIs >> in the right places on the wire. The only change that I think needs to >> happen for this issue is including (S)AFIs in the data that's signed. >> >> -- >> David Eric Mandelberg \/ dseomn >> http:\/\/david.mandelberg.org\/ >> >> >> _______________________________________________ >> sidr mailing list >> sidr@ietf.org >> https:\/\/www.ietf.org\/mailman\/listinfo\/sidr >> >> ML> _______________________________________________ ML> sidr mailing list ML> sidr@ietf.org ML> https:\/\/www.ietf.org\/mailman\/listinfo\/sidr -- Michael Baer baerm@tislabs.com Senior Software Engineer Parsons Global Shared Services, Cyber Security Division C: 530.902.3131"}
{"_id":"doc-en-sidr-a2MJx2wFxJI6TC_1pEz6ejMX5fw","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nI am in the process of resolving issues in the bgpsec-protocol document in order to get out a new version before Dallas. Based on the discussion in this thread, I believe the best way forward is: 1) Add a small amount of security considerations text to address the original concern that David raised. (I believe the consensus is that this concern cannot be converted into an actual attack. However, other readers might reasonably have the same concern as David and so there is no harm laying the concern to rest in security considerations.) 2) Given that origin validation is now decoupled from path validation, we will put the AFI under the BGPsec signature to avoid potential IPv4 vs IPv6 issues. Any objections to this resolution of these issues? - Matt Lepinski On Tue, Feb 17, 2015 at 6:40 PM, David Mandelberg <david@mandelberg.org> wrote: On 02\/14\/2015 02:53 PM, Sriram, Kotikalapudi wrote: I agree that the solution should not merely rely on the presence of a validating ROA. But there is some more detail here that is worth looking into. The path was fully signed and assume all signatures are valid. Then clearly the origin AS actually announced it. The question or ambiguity is: Did the origin AS announce 1.2.0.0\/16 (v4) or 102::\/16 (v6)? The ROA has AFI information, but the signed update does not (currently). https:\/\/tools.ietf.org\/html\/rfc6482#section-3.3 “Within the ROAIPAddressFamily structure, addressFamily contains the Address Family Identifier (AFI) of an IP address family. This specification only supports IPv4 and IPv6. Therefore, addressFamily MUST be either 0001 or 0002.” Hence, as Keyur has surmised, there is a possibility that the ROA can help resolve the ambiguity here. But the ambiguity would still persist if the same origin AS happens to have ROA(s) for both prefixes 1.2.0.0\/16 (v4) and 102::\/16 (v6) (though the probability is extremely small). So, yes, a robust solution calls for something more than a validating ROA. The ambiguity goes away if the AFI (of the announced prefix) is included by the origin AS on the wire as well as in the sequence of octets that are signed. When there's no attack, I don't think there's any ambiguity about what NLRI is being announced or withdrawn. RFC4760 seems to include (S)AFIs in the right places on the wire. The only change that I think needs to happen for this issue is including (S)AFIs in the data that's signed. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr I am in the process of resolving issues in the bgpsec-protocol document in order to get out a new version before Dallas. Based on the discussion in this thread, I believe the best way forward is:1) Add a small amount of security considerations text to address the original concern that David raised. (I believe the consensus is that this concern cannot be converted into an actual attack. However, other readers might reasonably have the same concern as David and so there is no harm laying the concern to rest in security considerations.)2) Given that origin validation is now decoupled from path validation, we will put the AFI under the BGPsec signature to avoid potential IPv4 vs IPv6 issues. Any objections to this resolution of these issues?- Matt Lepinski On Tue, Feb 17, 2015 at 6:40 PM, David Mandelberg <david@mandelberg.org> wrote: I agree that the solution should not merely rely on the presence of a validating ROA. But there is some more detail here that is worth looking into. The path was fully signed and assume all signatures are valid. Then clearly the origin AS actually announced it. The question or ambiguity is: Did the origin AS announce 1.2.0.0\/16 (v4) or 102::\/16 (v6)? The ROA has AFI information, but the signed update does not (currently). https:\/\/tools.ietf.org\/html\/rfc6482#section-3.3 “Within the ROAIPAddressFamily structure, addressFamily contains the Address Family Identifier (AFI) of an IP address family. This specification only supports IPv4 and IPv6. Therefore, addressFamily MUST be either 0001 or 0002.” Hence, as Keyur has surmised, there is a possibility that the ROA can help resolve the ambiguity here. But the ambiguity would still persist if the same origin AS happens to have ROA(s) for both prefixes 1.2.0.0\/16 (v4) and 102::\/16 (v6) (though the probability is extremely small). So, yes, a robust solution calls for something more than a validating ROA. The ambiguity goes away if the AFI (of the announced prefix) is included by the origin AS on the wire as well as in the sequence of octets that are signed. When there's no attack, I don't think there's any ambiguity about what NLRI is being announced or withdrawn. RFC4760 seems to include (S)AFIs in the right places on the wire. The only change that I think needs to happen for this issue is including (S)AFIs in the data that's signed. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-XQ3VEIGVzEIWv6tddyTXV6eVSCc","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nI agree that the solution should not merely rely on the presence of a validating ROA. But there is some more detail here that is worth looking into. The path was fully signed and assume all signatures are valid. Then clearly the origin AS actually announced it. The question or ambiguity is: Did the origin AS announce 1.2.0.0\/16 (v4) or 102::\/16 (v6)? The ROA has AFI information, but the signed update does not (currently). https:\/\/tools.ietf.org\/html\/rfc6482#section-3.3 “Within the ROAIPAddressFamily structure, addressFamily contains the Address Family Identifier (AFI) of an IP address family. This specification only supports IPv4 and IPv6. Therefore, addressFamily MUST be either 0001 or 0002.” Hence, as Keyur has surmised, there is a possibility that the ROA can help resolve the ambiguity here. But the ambiguity would still persist if the same origin AS happens to have ROA(s) for both prefixes 1.2.0.0\/16 (v4) and 102::\/16 (v6) (though the probability is extremely small). So, yes, a robust solution calls for something more than a validating ROA. The ambiguity goes away if the AFI (of the announced prefix) is included by the origin AS on the wire as well as in the sequence of octets that are signed. When there's no attack, I don't think there's any ambiguity about what NLRI is being announced or withdrawn. RFC4760 seems to include (S)AFIs in the right places on the wire. The only change that I think needs to happen for this issue is including (S)AFIs in the data that's signed. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-NLZE1HVqoqOxkJlYVAYGX36E7y4","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nAnd even if we had not decoupled those two, just because you might be authorized to announce 102::\/16 to a peer, that is different than saying that you actually announced it. point taken randy I agree that the solution should not merely rely on the presence of a validating ROA. But there is some more detail here that is worth looking into. The path was fully signed and assume all signatures are valid. Then clearly the origin AS actually announced it. The question or ambiguity is: Did the origin AS announce 1.2.0.0\/16 (v4) or 102::\/16 (v6)? The ROA has AFI information, but the signed update does not (currently). https:\/\/tools.ietf.org\/html\/rfc6482#section-3.3 “Within the ROAIPAddressFamily structure, addressFamily contains the Address Family Identifier (AFI) of an IP address family. This specification only supports IPv4 and IPv6. Therefore, addressFamily MUST be either 0001 or 0002.” Hence, as Keyur has surmised, there is a possibility that the ROA can help resolve the ambiguity here. But the ambiguity would still persist if the same origin AS happens to have ROA(s) for both prefixes 1.2.0.0\/16 (v4) and 102::\/16 (v6) (though the probability is extremely small). So, yes, a robust solution calls for something more than a validating ROA. The ambiguity goes away if the AFI (of the announced prefix) is included by the origin AS on the wire as well as in the sequence of octets that are signed. Sriram"}
{"_id":"doc-en-sidr-wid9Xg0plmJPO6QQyKHxDNi28dc","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nAnd even if we had not decoupled those two, just because you might be authorized to announce 102::\/16 to a peer, that is different than saying that you actually announced it. point taken randy"}
{"_id":"doc-en-sidr-MEr9UCn5KlWt1d3ciFmU5qyFmt8","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nSince we agreed to decouple path validity from origin validity (and return both as distinct validation results), we should probably clean this up. That is, we now can’t rely on the origin being invalid, to invalidate this path manipulation. And even if we had not decoupled those two, just because you might be authorized to announce 102::\/16 to a peer, that is different than saying that you actually announced it. I realize that the threat scenario here is getting diminishing small, but still, we should clean this up to reduce it to zero. dougm — Doug Montgomery, Mgr Internet & Scalable Systems Research @ NIST\/ITL\/ANTD On 2\/13\/15, 8:03 PM, \"Keyur Patel (keyupate)\" <keyupate@cisco.com> wrote: Hi David, On 2\/10\/15, 1:48 PM, \"David Mandelberg\" <david@mandelberg.org> wrote: All, while coming up with the example below, I realized another issue. The structure in 4.1 doesn't include an Address Family Identifier. Unless I missed something, this means that a signature for 1.2.0.0\/16 would be exactly the same as a signature for 102::\/16. This would be a much more practical attack than the one I originally though of. But, isn¹t this issue covered by origin-AS validation? Regards, Keyur Michael, response to your comment is below. I don't believe this is a problem. The signature is calculated by creating a digest of the data and then creating a signature from that digest. I'm definitely not a cryptography expert, but my understanding of digest functions generally is that with even slightly differing input, the resulting set of bits should be completely different. Assuming the digest function chosen is not flawed, there shouldn't be a set of bits from the digest of 4.1 that could be used to successfully replace the digest of 4.2, except by chance. You're right about digest algorithms being highly sensitive to changes in the input, but the issue I described is when the two inputs are equal, not just similar. For example, if a router signed the below values in the structure from 4.2: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Most Recent Sig Field = 0x00700102030405060708090a0b0c0d0e (See Sriram's email for why this would never actually happen with the current algorithm suite's signature length.) Then the router signed the digest of the bytes 0x0102030405060708010000700102030405060708090a0b0c0d0e. However, these exact same bytes could appear to have come from the structure in 4.1 with these values: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Algorithm Suite Id = 0x00 NLRI Length = 0x70 (112 bits = 14 bytes) NLRI Prefix = 0x0102030405060708090a0b0c0d0e Note that the first 16 bits of 4.2's Most Recent Sig Field can't be any values. The first 8 have to match the Algorithm Suite ID (1 possible value). The next 8 have to be a valid number of bits for the number of bytes in the prefix (8 possible values). This means that there's only a 2^-13 chance that a single random Most Recent Sig Field of the appropriate length could be reinterpreted successfully. However, with more than 2^13 signatures floating around the Internet, that's not good odds. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-RvxQM_YrZOVmwHLisQM0w0bn7l4","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nHi David, On 2\/10\/15, 1:48 PM, \"David Mandelberg\" <david@mandelberg.org> wrote: All, while coming up with the example below, I realized another issue. The structure in 4.1 doesn't include an Address Family Identifier. Unless I missed something, this means that a signature for 1.2.0.0\/16 would be exactly the same as a signature for 102::\/16. This would be a much more practical attack than the one I originally though of. But, isn¹t this issue covered by origin-AS validation? Regards, Keyur Michael, response to your comment is below. I don't believe this is a problem. The signature is calculated by creating a digest of the data and then creating a signature from that digest. I'm definitely not a cryptography expert, but my understanding of digest functions generally is that with even slightly differing input, the resulting set of bits should be completely different. Assuming the digest function chosen is not flawed, there shouldn't be a set of bits from the digest of 4.1 that could be used to successfully replace the digest of 4.2, except by chance. You're right about digest algorithms being highly sensitive to changes in the input, but the issue I described is when the two inputs are equal, not just similar. For example, if a router signed the below values in the structure from 4.2: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Most Recent Sig Field = 0x00700102030405060708090a0b0c0d0e (See Sriram's email for why this would never actually happen with the current algorithm suite's signature length.) Then the router signed the digest of the bytes 0x0102030405060708010000700102030405060708090a0b0c0d0e. However, these exact same bytes could appear to have come from the structure in 4.1 with these values: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Algorithm Suite Id = 0x00 NLRI Length = 0x70 (112 bits = 14 bytes) NLRI Prefix = 0x0102030405060708090a0b0c0d0e Note that the first 16 bits of 4.2's Most Recent Sig Field can't be any values. The first 8 have to match the Algorithm Suite ID (1 possible value). The next 8 have to be a valid number of bits for the number of bytes in the prefix (8 possible values). This means that there's only a 2^-13 chance that a single random Most Recent Sig Field of the appropriate length could be reinterpreted successfully. However, with more than 2^13 signatures floating around the Internet, that's not good odds. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-VzL8G9eiEepj4OIq8Gcw2RTd69c","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nOn Tue, 10 Feb 2015 16:48:08 -0500, David Mandelberg <david@mandelberg.org> said: DM> All, while coming up with the example below, I realized another DM> issue. The structure in 4.1 doesn't include an Address Family DM> Identifier. Unless I missed something, this means that a DM> signature for 1.2.0.0\/16 would be exactly the same as a DM> signature for 102::\/16. This would be a much more practical DM> attack than the one I originally though of. DM> Michael, response to your comment is below. DM> >> I don't believe this is a problem. The signature is calculated >> by creating a digest of the data and then creating a signature >> from that digest. I'm definitely not a cryptography expert, but >> my understanding of digest functions generally is that with even >> slightly differing input, the resulting set of bits should be >> completely different. Assuming the digest function chosen is not >> flawed, there shouldn't be a set of bits from the digest of 4.1 >> that could be used to successfully replace the digest of 4.2, >> except by chance. DM> You're right about digest algorithms being highly sensitive to DM> changes in the input, but the issue I described is when the two DM> inputs are equal, not just similar. For example, if a router DM> signed the below values in the structure from 4.2: DM> Target AS Number = 0x01020304 Origin AS Number = 0x05060708 DM> pCount = 0x01 Flags = 0x00 Most Recent Sig Field = DM> 0x00700102030405060708090a0b0c0d0e (See Sriram's email for why DM> this would never actually happen with the current algorithm DM> suite's signature length.) Ah, I see. Thanks for the explanation. I was not understanding the attack vector but I get how it would work now (and good to know the input won't match with the current algorithm). -Mike DM> Then the router signed the digest of the bytes DM> 0x0102030405060708010000700102030405060708090a0b0c0d0e. However, DM> these exact same bytes could appear to have come from the DM> structure in 4.1 with these values: DM> Target AS Number = 0x01020304 Origin AS Number = 0x05060708 DM> pCount = 0x01 Flags = 0x00 Algorithm Suite Id = 0x00 NLRI Length DM> = 0x70 (112 bits = 14 bytes) NLRI Prefix = DM> 0x0102030405060708090a0b0c0d0e DM> Note that the first 16 bits of 4.2's Most Recent Sig Field can't DM> be any values. The first 8 have to match the Algorithm Suite ID DM> (1 possible value). The next 8 have to be a valid number of bits DM> for the number of bytes in the prefix (8 possible values). This DM> means that there's only a 2^-13 chance that a single random Most DM> Recent Sig Field of the appropriate length could be DM> reinterpreted successfully. However, with more than 2^13 DM> signatures floating around the Internet, that's not good odds. DM> -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/ DM> _______________________________________________ sidr mailing DM> list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr -- Michael Baer baerm@tislabs.com"}
{"_id":"doc-en-sidr-XiuDCIbOH2Hc5KnWoEvse-s_L6w","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nAll, while coming up with the example below, I realized another issue. The structure in 4.1 doesn't include an Address Family Identifier. Unless I missed something, this means that a signature for 1.2.0.0\/16 would be exactly the same as a signature for 102::\/16. This would be a much more practical attack than the one I originally though of. Michael, response to your comment is below. I don't believe this is a problem. The signature is calculated by creating a digest of the data and then creating a signature from that digest. I'm definitely not a cryptography expert, but my understanding of digest functions generally is that with even slightly differing input, the resulting set of bits should be completely different. Assuming the digest function chosen is not flawed, there shouldn't be a set of bits from the digest of 4.1 that could be used to successfully replace the digest of 4.2, except by chance. You're right about digest algorithms being highly sensitive to changes in the input, but the issue I described is when the two inputs are equal, not just similar. For example, if a router signed the below values in the structure from 4.2: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Most Recent Sig Field = 0x00700102030405060708090a0b0c0d0e (See Sriram's email for why this would never actually happen with the current algorithm suite's signature length.) Then the router signed the digest of the bytes 0x0102030405060708010000700102030405060708090a0b0c0d0e. However, these exact same bytes could appear to have come from the structure in 4.1 with these values: Target AS Number = 0x01020304 Origin AS Number = 0x05060708 pCount = 0x01 Flags = 0x00 Algorithm Suite Id = 0x00 NLRI Length = 0x70 (112 bits = 14 bytes) NLRI Prefix = 0x0102030405060708090a0b0c0d0e Note that the first 16 bits of 4.2's Most Recent Sig Field can't be any values. The first 8 have to match the Algorithm Suite ID (1 possible value). The next 8 have to be a valid number of bits for the number of bytes in the prefix (8 possible values). This means that there's only a 2^-13 chance that a single random Most Recent Sig Field of the appropriate length could be reinterpreted successfully. However, with more than 2^13 signatures floating around the Internet, that's not good odds. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-MTO1MulHxYF4lP5TKmawSMSyfwM","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nOn Thu, 05 Feb 2015 23:38:16 -0500, David Mandelberg <david@mandelberg.org> said: David> After reviewing this document, I have one concern below, and David> some nits that I'll send to the editor. Otherwise it looks David> good to me. David> In sections 4.1 and 4.2, there are two different to-be-signed David> structures. If I understand correctly, the same router keys David> will be used to sign data from both structures. It might be David> possible for an attacker to take a valid signature of data David> from the structure in 4.2, and present it as a valid David> signature of the same bytes interpreted with the structure in David> 4.1. I'm not sure anything malicious could be done this way, David> but reinterpreting the meaning of signed data seems like a David> bad idea to me. It would be easy to prevent this by David> prepending both structures with a single byte that MUST BE 0 David> for 4.1 and MUST BE 1 for 4.2. Apologies if this has already David> been discussed and is not an issue. I don't believe this is a problem. The signature is calculated by creating a digest of the data and then creating a signature from that digest. I'm definitely not a cryptography expert, but my understanding of digest functions generally is that with even slightly differing input, the resulting set of bits should be completely different. Assuming the digest function chosen is not flawed, there shouldn't be a set of bits from the digest of 4.1 that could be used to successfully replace the digest of 4.2, except by chance. -Mike -- Michael Baer baerm@tislabs.com"}
{"_id":"doc-en-sidr-ZH8OQhDBZYRP99k_MYjXJ12CWzw","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIt might be possible for an attacker to take a valid signature of data from the structure in 4.2, and present it as a valid signature of the same bytes interpreted with the structure in 4.1. If you have worked out a concrete example showing how the attack works, it would be good to see that. For this type of attack to be feasible, is it required that the size of the signature field equals the combined size of {Alg. ID, NLRI length, NLRI prefix}? Yes, that's correct. If yes, observe that the size of the signature field (ECDSA-P256) = 64 octets + a few variable #octets, and the combined size of {Alg. ID, NLRI length, NLRI prefix} is either 6 octets (IPv4) or 18 octets (IPv6). Good catch. It seems that for a feasible attack, a future algorithm suite would need to have much shorter signatures (unlikely) or bgpsec would need to be extended to something with much longer NLRI prefixes (who's ready for IPv8?!) So this isn't going to bite us for a very long time, if ever. Should we (1) prevent that remote possibility by adding a single byte to both to-be-signed structures (which doesn't add any bytes on the wire), (2) make a note in the security considerations, or (3) just ignore this as too unlikely to care about? If we choose either 2 or 3, won't it be very difficult to change our minds once bgpsec is deployed? How hard is it to do (1) now? -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-_JKkBYSJefaWa-0aO3NePDFsedY","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nIt might be possible for an attacker to take a valid signature of data from the structure in 4.2, and present it as a valid signature of the same bytes interpreted with the structure in 4.1. If you have worked out a concrete example showing how the attack works, it would be good to see that. For this type of attack to be feasible, is it required that the size of the signature field equals the combined size of {Alg. ID, NLRI length, NLRI prefix}? If yes, observe that the size of the signature field (ECDSA-P256) = 64 octets + a few variable #octets, and the combined size of {Alg. ID, NLRI length, NLRI prefix} is either 6 octets (IPv4) or 18 octets (IPv6). Sriram"}
{"_id":"doc-en-sidr-qwiUeIPWlglBMF4Y1Q8BzKvHhrM","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nAfter reviewing this document, I have one concern below, and some nits that I'll send to the editor. Otherwise it looks good to me. In sections 4.1 and 4.2, there are two different to-be-signed structures. If I understand correctly, the same router keys will be used to sign data from both structures. It might be possible for an attacker to take a valid signature of data from the structure in 4.2, and present it as a valid signature of the same bytes interpreted with the structure in 4.1. I'm not sure anything malicious could be done this way, but reinterpreting the meaning of signed data seems like a bad idea to me. It would be easy to prevent this by prepending both structures with a single byte that MUST BE 0 for 4.1 and MUST BE 1 for 4.2. Apologies if this has already been discussed and is not an issue. -- David Eric Mandelberg \/ dseomn http:\/\/david.mandelberg.org\/"}
{"_id":"doc-en-sidr-HS6klGz6NCHuVmwZVqHMef33nas","title":"","text":"Re: [sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nGave this another review. Other than what I identify below, I think that this is ready to publish. First, some comments specific to the interaction between this draft's language and draft-ietf-sidr-as-migration: Section 4 discusses behavior for iBGP speakers. It may be appropriate to include another reference to the slightly different behavior defined in sidr-as-migration (see sections 5.2 and 5.3). Also, 4.1 says that AS_Path and BGPSec_Path are mutually exclusive (must not send both, etc.) and section 4 says that routes originated to other iBGP peers should omit BGPSec attributes. I don't think that this and sidr-as-migration are in conflict, but I want to have another pair of eyes looking at it to make sure that the recommendations for iBGP peers are in sync. This includes if you think that the text in sidr-as-migration should be updated for better clarity. 5.2 item 5- pcount=0 - again, want to make sure that the way that this is treated in as-migration is not in conflict with this instruction. The idea is that any AS-migration configuration should be local to the edge router under migration, and not require configuration changes on every router in the ASN pair (old + new), but since there is a signature from old_ASN to New_ASN with Pcount=0 coming from an iBGP neighbor, this is a detail we have to have right, whether it drives changes in your text or mine. Note: after Keyur's review, I made some wording changes to section 5.2 of as-migration, but it's still in my edit buffer, so the text in the current version is replaced by: 5.2 \"When a PE router receives an update from an eBGP neighbor that is locally configured with AS-migration knobs (i.e. the opposite direction of the previous route flow), it MUST generate a signature from the old (local) ASN forward signing to the new (global) ASN with pCount=0. It is not necessary to generate the second signature from the new (global) ASN because the ASBR will generate that when it forward signs towards its eBGP peers as defined in normal BGPSec operation. Note that a signature is not normally added when a routing update is sent across an iBGP session. The requirement to sign updates in iBGP represents a change to the normal behavior for this specific AS-migration implementation only.\" Now, some general comments: Section 5: extreme circumstances...defer validation. Perhaps we should add a recommendation that this behavior be visible (i.e. Log messages, visible in bgp diagnostic information, etc.) While the circumstances that invoke this behavior is a matter of local policy\/implementation, I think it's reasonable to add this recommendation to make sure that it's visible to the operator when it is happening. Section 5.2 - elsewhere in the document (7.3), you note that validation should stop when an invalid signature is found. However, I see no mention of that in the actual validation algorithm. That seems like good practice even if there isn't a long chain of signatures to validate. Additionally, 7.1's text \"Thus, a BGPsec speaker MUST completely validate all BGPsec update messages received from external peers.\" seems to conflict with this recommendation because it says \"completely\". I think it's a wording problem, i.e. We're not saying you MUST validate the *entire* update, but rather you must validate ALL updates that you *receive* until you encounter an invalid signature within a given update, in which case you can stop and move to the next update. Also, it may be appropriate to state that the application of local policy on validation state may be dependent on the ASN, i.e. I may want to say that I want to drop or depref invalid BGPSec routes but carve out a list of exception ASNs where the policy is bypassed (or vice versa). This is largely an implementation detail and probably better discussed in detail in the ops considerations doc, but it may be important in the protocol doc because it requires more info to be passed from the validation machinery to the policy machinery - in other words, it can't just know that somewhere in this update, there was an invalid signature, and thus the update is invalid, it may need to know that the update is valid except for the signature for ASN1701 in order to have granular enough policy control. Section 6.1 \"It is anticipated that, in the future mandatory, the algorithm suites document will be updated to specify a transition from the 'current' algorithm suite to a 'new' algorithm suite.\" This sentence is pretty hard to parse, wasn't sure if it's a misplaced word or just clunky. \"We anticipate that in the future, the mandatory algorithm suites document...\"? Or if that was the intended word order, I think it says that we're anticipating that the algorithm suites doc will be mandatory and that it will be updated to transition to new suites. Let's be a little clearer - we already know that the algorithm suites doc will be mandatory, so we shouldn't really need to qualify this statement so much. Thanks, Wes George The editor of draft-ietf-sidr-bgpsec-protocol, BGPsec Protocol Specification, indicate that all issues have been addressed and the draft is ready for a working group last call. This starts a working group last call for https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-11. Please review the draft and send comments to the list. Please include whether you believe the draft is ready for publication. This wglc will end on 9 February 2015. --Sandy, speaking for the wg co-chairs This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-LqVjpPTNMu6e-ReKI8AzB05Sdso","title":"","text":"[sidr] wglc for draft-ietf-sidr-bgpsec-protocol-11\nThe editor of draft-ietf-sidr-bgpsec-protocol, BGPsec Protocol Specification, indicate that all issues have been addressed and the draft is ready for a working group last call. This starts a working group last call for https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-11. Please review the draft and send comments to the list. Please include whether you believe the draft is ready for publication. This wglc will end on 9 February 2015. --Sandy, speaking for the wg co-chairs"}
{"_id":"doc-en-sidr-S6RMd419OxKi8C0zEecfUwAhO28","title":"","text":"Re: [sidr] New Version: draft-ietf-sidr-bgpsec-protocol-11\nOne minor issue that arose in making these revisions: Consider the case where you are creating a new update message somewhere within your AS (to originate a route to one of your own prefixes) and you are sending this new update message via iBGP to an internal peer. The document currently says that you omit the Secure_Path attribute (that is, the BGPsec_Path attribute is added by your edge router ... since the signature depends on the eBGP peer to whom an update is being sent). An alternative would be to include an 'empty' BGPsec_Path attribute ... that is, one with zero Secure_Path segments and zero Signature segments. If you think sending an empty BGPsec_Path is better than omitting the BGPsec_Path, please speak up now. (Both approaches seem perfectly fine to me.) the iBGPsec originator creates an empty BGPsec_Path and sends the update to o whether the iBGPsec speaker might send a BGPsec_Path to a iBGP peer is a per-peer decision determined at BGP_OPEN. o an eBGP edge which has >0 peers who do not speak BGPsec has to strip to non-speakers, which may be pretty common in early daze. o iBGP originators which are not BGPsec enabled will need the eBGPsec edge to create the BGPsec_Path anyway. where's the win? randy"}
{"_id":"doc-en-sidr-zy44zDS_Uje3WvOjaCR04TNQSac","title":"","text":"[sidr] New Version: draft-ietf-sidr-bgpsec-protocol-11\nI have just submitted a new version of the BGPsec protocol document. This version includes text changes to improve the security considerations section of the document as well as review comments based on the previous version of the document. (In particular, many thanks to Sriram -- for his very thorough review -- and to everyone who made helpful comments on the list.) Also, to make this document consistent with other documents in the document suite, this document now specifies a BGPsec_Path attribute instead of a BGPSEC_Path attribute. ==================== One minor issue that arose in making these revisions: Consider the case where you are creating a new update message somewhere within your AS (to originate a route to one of your own prefixes) and you are sending this new update message via iBGP to an internal peer. The document currently says that you omit the Secure_Path attribute (that is, the BGPsec_Path attribute is added by your edge router ... since the signature depends on the eBGP peer to whom an update is being sent). An alternative would be to include an 'empty' BGPsec_Path attribute ... that is, one with zero Secure_Path segments and zero Signature segments. If you think sending an empty BGPsec_Path is better than omitting the BGPsec_Path, please speak up now. (Both approaches seem perfectly fine to me.) I have just submitted a new version of the BGPsec protocol document. This version includes text changes to improve the security considerations section of the document as well as review comments based on the previous version of the document. (In particular, many thanks to Sriram -- for his very thorough review -- and to everyone who made helpful comments on the list.) Also, to make this document consistent with other documents in the document suite, this document now specifies a BGPsec_Path attribute instead of a BGPSEC_Path attribute.====================One minor issue that arose in making these revisions:Consider the case where you are creating a new update message somewhere within your AS (to originate a route to one of your own prefixes) and you are sending this new update message via iBGP to an internal peer. The document currently says that you omit the Secure_Path attribute (that is, the BGPsec_Path attribute is added by your edge router ... since the signature depends on the eBGP peer to whom an update is being sent). An alternative would be to include an 'empty' BGPsec_Path attribute ... that is, one with zero Secure_Path segments and zero Signature segments.If you think sending an empty BGPsec_Path is better than omitting the BGPsec_Path, please speak up now. (Both approaches seem perfectly fine to me.)"}
{"_id":"doc-en-sidr-WXQvr3Q798pYklUEnOn1QF-W8UA","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-11.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPsec Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-11.txt Pages : 35 Date : 2015-01-19 Abstract: This document describes BGPsec, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPsec is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-11 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-11 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-y9jrvFTnmpSQEhqfmz3cpmAm4Ek","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nChris, You are correct that was the thinking that went into Section 7.3. That is, Section 7.3 focuses on mitigating any new denial of service possibilities that are introduced by the BGPsec extensions to BGP. I am happy to make this more clear in the text. - Matt Lepinski On Mon, Jan 12, 2015 at 1:25 PM, Christopher Morrow <morrowc.lists@gmail.com wrote: On Mon, Nov 24, 2014 at 3:08 PM, Smith, Donald <Donald.Smith@centurylink.com> wrote: Wouldn't GTSM and tcp-ao help with DOS attacks? I think this was focused only on the uplift to bgp that bgpsec is supposed to be, so the assumption was\/is that you'd already be doing 'bgp best practices'. (authors are free to correct me, as always) -chris I would recommend they be put in in the paragraph below. 7.3 Mitigation of Denial of Service Attacks BGPSEC speakers should implement an update validation algorithm that performs expensive checks (e.g., signature verification) after performing less expensive checks (e.g., syntax checks). The validation algorithm specified in Section 5.2 was chosen so as to perform checks which are likely to be expensive after checks that are likely to be inexpensive. https:\/\/tools.ietf.org\/html\/rfc5082 https:\/\/tools.ietf.org\/html\/rfc5925 As examples or recommendations for the \"less expensive\" checks. In fact it should be GTSM, tcp-ao THEN bgpsec validation. (coffee != sleep) & (!coffee == sleep) Donald.Smith@centurylink.com ________________________________ From: sidr [sidr-bounces@ietf.org] on behalf of Stephen Kent [ kent@bbn.com] Sent: Monday, November 24, 2014 12:35 PM To: sidr@ietf.org Subject: Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10 Wes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This communication is the property of CenturyLink and may contain confidential or privileged information. Unauthorized use of this communication is strictly prohibited and may be unlawful. If you have received this communication in error, please immediately notify the sender by reply e-mail and destroy all copies of the communication and any attachments. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Chris,You are correct that was the thinking that went into Section 7.3. That is, Section 7.3 focuses on mitigating any new denial of service possibilities that are introduced by the BGPsec extensions to BGP. I am happy to make this more clear in the text.- Matt LepinskiOn Mon, Jan 12, 2015 at 1:25 PM, Christopher Morrow <morrowc.lists@gmail.com> wrote: Wouldn't GTSM and tcp-ao help with DOS attacks? I think this was focused only on the uplift to bgp that bgpsec is supposed to be, so the assumption was\/is that you'd already be doing 'bgp best practices'. (authors are free to correct me, as always) -chris I would recommend they be put in in the paragraph below. 7.3 Mitigation of Denial of Service Attacks BGPSEC speakers should implement an update validation algorithm that performs expensive checks (e.g., signature verification) after performing less expensive checks (e.g., syntax checks). The validation algorithm specified in Section 5.2 was chosen so as to perform checks which are likely to be expensive after checks that are likely to be inexpensive. https:\/\/tools.ietf.org\/html\/rfc5082 https:\/\/tools.ietf.org\/html\/rfc5925 As examples or recommendations for the \"less expensive\" checks. In fact it should be GTSM, tcp-ao THEN bgpsec validation. (coffee != sleep) & (!coffee == sleep) Donald.Smith@centurylink.com ________________________________ From: sidr [sidr-bounces@ietf.org] on behalf of Stephen Kent [kent@bbn.com] Sent: Monday, November 24, 2014 12:35 PM To: sidr@ietf.org Subject: Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10 Wes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This communication is the property of CenturyLink and may contain confidential or privileged information. Unauthorized use of this communication is strictly prohibited and may be unlawful. If you have received this communication in error, please immediately notify the sender by reply e-mail and destroy all copies of the communication and any attachments. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-RvuYZI9BZSTsojj0YszV5kBq0oQ","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nWouldn't GTSM and tcp-ao help with DOS attacks? I think this was focused only on the uplift to bgp that bgpsec is supposed to be, so the assumption was\/is that you'd already be doing 'bgp best practices'. (authors are free to correct me, as always) -chris I would recommend they be put in in the paragraph below. 7.3 Mitigation of Denial of Service Attacks BGPSEC speakers should implement an update validation algorithm that performs expensive checks (e.g., signature verification) after performing less expensive checks (e.g., syntax checks). The validation algorithm specified in Section 5.2 was chosen so as to perform checks which are likely to be expensive after checks that are likely to be inexpensive. https:\/\/tools.ietf.org\/html\/rfc5082 https:\/\/tools.ietf.org\/html\/rfc5925 As examples or recommendations for the \"less expensive\" checks. In fact it should be GTSM, tcp-ao THEN bgpsec validation. (coffee != sleep) & (!coffee == sleep) Donald.Smith@centurylink.com ________________________________ From: sidr [sidr-bounces@ietf.org] on behalf of Stephen Kent [kent@bbn.com] Sent: Monday, November 24, 2014 12:35 PM To: sidr@ietf.org Subject: Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10 Wes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This communication is the property of CenturyLink and may contain confidential or privileged information. Unauthorized use of this communication is strictly prohibited and may be unlawful. If you have received this communication in error, please immediately notify the sender by reply e-mail and destroy all copies of the communication and any attachments. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-45SMl-QouauxzpBgd1PRuX099hs","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nWouldn't GTSM and tcp-ao help with DOS attacks? I would recommend they be put in in the paragraph below. 7.3<https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-10#section-7.3> Mitigation of Denial of Service Attacks BGPSEC speakers should implement an update validation algorithm that performs expensive checks (e.g., signature verification) after performing less expensive checks (e.g., syntax checks). The validation algorithm specified in Section 5.2<https:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-10#section-5.2> was chosen so as to perform checks which are likely to be expensive after checks that are likely to be inexpensive. https:\/\/tools.ietf.org\/html\/rfc5082 https:\/\/tools.ietf.org\/html\/rfc5925 As examples or recommendations for the \"less expensive\" checks. In fact it should be GTSM, tcp-ao THEN bgpsec validation. (coffee != sleep) & (!coffee == sleep) Donald.Smith@centurylink.com<mailto:Donald.Smith@centurylink.com> ________________________________ From: sidr [sidr-bounces@ietf.org] on behalf of Stephen Kent [kent@bbn.com] Sent: Monday, November 24, 2014 12:35 PM To: sidr@ietf.org Subject: Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10 Wes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This communication is the property of CenturyLink and may contain confidential or privileged information. Unauthorized use of this communication is strictly prohibited and may be unlawful. If you have received this communication in error, please immediately notify the sender by reply e-mail and destroy all copies of the communication and any attachments. Wouldn't GTSM and tcp-ao help with DOS attacks? I would recommend they be put in in the paragraph below. 7.3 Mitigation of Denial of Service Attacks BGPSEC speakers should implement an update validation algorithm that performs expensive checks (e.g., signature verification) after performing less expensive checks (e.g., syntax checks). The validation algorithm specified in Section 5.2 was chosen so as to perform checks which are likely to be expensive after checks that are likely to be inexpensive. https:\/\/tools.ietf.org\/html\/rfc5082 https:\/\/tools.ietf.org\/html\/rfc5925 As examples or recommendations for the \"less expensive\" checks. In fact it should be GTSM, tcp-ao THEN bgpsec validation. (coffee != sleep) & (!coffee == sleep) Donald.Smith@centurylink.com From: sidr [sidr-bounces@ietf.org] on behalf of Stephen Kent [kent@bbn.com] Sent: Monday, November 24, 2014 12:35 PM To: sidr@ietf.org Subject: Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10 Wes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This communication is the property of CenturyLink and may contain confidential or privileged information. Unauthorized use of this communication is strictly prohibited and may be unlawful. If you have received this communication in error, please immediately notify the sender by reply e-mail and destroy all copies of the communication and any attachments."}
{"_id":"doc-en-sidr-PuwqtvxWjOS3uD0nJkSFlbyqUZM","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nWes, To first order I agree with your concern of this DoS vulnerability, but with some minor clarifications. 1. BGPsec-signed updates are sent only between ASes that agree to send and receive (separate choices) this signed data. So, an attack of this sort is perpetrated only against an immediate neighbor that agrees to accept BGPsec traffic from you. You cannot send a BGPsec route to an arbitrary AS that it not configured for you as a neighbor. 2. As you noted, an AS can generate a path only for ASes that it holds, and thus, for which it holds private keys. So, a long path of the sort you describe is directly traceable to the resources holder, creating a \"smoking gun\" effect, for forensic purposes. If we can agree on a max path length, based on real world data, and RECOMMEND that routers enforce this limit, we can mitigate the ability of an AS to Dos it's neighbor (and others). That, combined with the ability to identify who added all of the questionable AS entries, might provide a deterrent to this behavior. Still, even with a max path length, there is the potential to add just a few, unnecessary ASes to every signed route that traverses an evil AS, to add to the burden of neighbors and those beyond. Given all the folks who track routing updates, this too will probably be noted by a bunch of folks, and because of the signatures, there will be no doubt about the source(s). So, here too, that may prove to be a deterrent. I believe someone at the meeting observed that smart implementations will try to address this sort of concern by postponing BGPsec crypto processing when resources get scarce. While I agree that this represents another attack vector, the ability to identify the perpetrators may diminish the attraction of this attack strategy. In any case, this is a good topic to address, perhaps in the BGPsec security considerations section, plus a separate document that suggests implementation notes. Steve"}
{"_id":"doc-en-sidr-tjoKDir5dWrnR0DUwEhbece_KF8","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\ncould you please describe how an attacker can send many long bgpsec paths? how are these long paths signed? Though I'm guessing it might be possible to try it as a replay attack (grab a string of signed ASNs from the path of one or more routes that go past you, then add them to another set of routes that doesn't already have them), I was thinking the attacker likely has to have the ability to sign those ASNs (they have the keys) so that they're valid, otherwise the route just gets dropped. It's not hard to get an ASN or 10. $Dayjob have 12 or 15 that I know about, Comcast has 30+ ASNs, and plenty of hosting providers use an ASN per location to avoid needing ways to connect islands of the same ASN together. Normally they don't have routes that go through each ASN, but spinning up BGP speaking VM instances on Quagga or similar to generate routes to inject and sign from one ASN to another is not hard. In order to avoid the protections that Origin Validation would provide, it's less likely that this is going to be done at origin, but rather by an ASN that is in the middle of the path. I.e. <origin> -- <upstream 1> -- <bad upstream> -- <upstream 3> Bad upstream receives routes from its downstream, and adds the list of ASNs it can sign for plus any churn it wants to induce, sends it to upstream 3, which in this case would be the target of the attack, and if it propagates the routes further, networks beyond it would also be affected. Even if the added ASNs in the path have the result of redirecting traffic to another candidate with a shorter AS Path, the route update itself will propagate on and still eat CPU and memory on the routers it transits, and maybe even be amplified as it gets duplicated to be sent to the learning router's BGP peers. This attack is different from the normal AS Path attacks BGPSec was designed to protect against, because it's not necessarily trying to add a specific ASN to shift traffic to a certain network, that's just a side-effect of the attempt to attack the routers running BGPSec themselves. I'm thinking of this in terms of worst-case scenario, where one builds a nice long ASN path, then uses it to lengthen a few thousand routes as they pass, and then churn them, either on the assumption that RFD isn't configured, or keeping the churn on an individual route low enough to keep from triggering the dampening, but churn lots of routes simultaneously. I admit that this seems like a stretch since exploiting it requires access to ASNs and keys and possibly compromising a router in the middle of a network so that you can have a platform to launch the attack, but there is also the possibility that the simple act of having a long string of valid ASNs in the actual forwarding path could cause this, especially in conjunction with churn, lots of route deaggregation, and misconfiguration (route leaks) that has the net result of taking a long AS path and making it longer. The key question as to how much of a problem this actually might be is, \"how long of an AS Path is too long in BGPSec?\" or alternately, \"when does the product of number of signed routes and number of ASNs per route start causing performance degradation during validation?\") I'm not sure we can know that at this point, because it'll depend on a lot of things, so unless we can make some common-sense inferences based on what we see in the routing table, we mainly have to identify it as a potential problem. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-TFWY38YhmE2uLKhDMKaOE_EcLDs","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nPer discussion during IDR\/SIDR meeting Friday, there may need to be some text in the security considerations around the attack vector of sending many updates with long (but valid) AS_Paths could you please describe how an attacker can send many long bgpsec paths? how are these long paths signed? I'm not Wes, but I could imagine an attacker who has 2 ASNs making a path that looks like: 192.0.2.0\/24 174 3561 17 42 17 42 17 42 .... 17 42 17 42 701 Seems like it would be a lot of work for very little fun, but that's what I'd understood the question to be. W randy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr -- I don't think the execution is relevant when it was obviously a bad idea in the first place. This is like putting rabid weasels in your pants, and later expressing regret at having chosen those particular rabid weasels and that pair of pants. ---maf"}
{"_id":"doc-en-sidr-jgm4fpFpvUQoDbz-VL5LbSsqnnE","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nPer discussion during IDR\/SIDR meeting Friday, there may need to be some text in the security considerations around the attack vector of sending many updates with long (but valid) AS_Paths could you please describe how an attacker can send many long bgpsec paths? how are these long paths signed? randy"}
{"_id":"doc-en-sidr-Az5wIzjq0jN2IgivD9ev--j8yK8","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nMatt- Per discussion during IDR\/SIDR meeting Friday, there may need to be some text in the security considerations around the attack vector of sending many updates with long (but valid) AS_Paths, since the analysis Sriram provided indicated a correlation between the length of the AS Path to be validated and CPU impact or convergence time impact. Sounds like we don't have a problem with long paths comprised of multiple prepends because Pcount means that there aren't multiple signatures, but validly signed strings of unique ASNs could still trigger this problem, whether they are generated accidentally or maliciously. We may also need to make the observation that rapid route churn with these sorts of prefixes are likely to make the impact even higher, such that it may be advisable to implement route flap dampening to provide additional protection against route churn. That said, I'm not sure that this is strictly a security considerations addition, because we may need to make some suggestions in the design to protect against these sorts of scaling problems. I'm not sure if we can use analysis of existing routing table data to identify an 80\/20 threshold of the longest credible AS Path and put a recommendation on a max_as_length value for the limit for protection against this attack, or whether we cannot recommend a value, and have to simply acknowledge that this is a problem and recommend that implementers provide a knob for setting a limit on AS Path such that implementations can intercept and drop long AS_Paths before the BGPSec machinery tries to validate them. Perhaps both, i.e. A reasonable default limit that can be raised or lowered if a user sees fit. Alternatively, we could suggest a fall-back method whereby excessively long-path BGPSec updates are deprioritized or throttled to avoid causing adverse performance impacts, perhaps in conjunction with existing RFD implementations for routes that are both long-path and churning. I can try to contribute some text once the WG weighs in on what direction they want to take to address this, but I wanted to at least get the discussion started. Thanks, Wes George Just posted the -10 revision of the document. The only normative change was to decouple BGPsec validation from Origin Validation. (This is a normative change to the validation algorithm in Section 5.) This is based on working group discussions at IETF 90 and confirmed on the list in September. Additionally, there were some text changes made, including a reference to the AS-Migration document (and an accompanying text change regarding pCount=0). I have a couple of improvements to the security considerations text that I wasn't able to fold into this version of the document. Other than improving the security considerations, I am not aware of any open issues in this particular document. - Matt Lepinski _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-SI2DQv_mFxMpQyi9LJ5GonOhHZw","title":"","text":"Re: [sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nMatt, Thanks for all your efforts and time in keeping this I-D updated. Some technical and some editorial comments on the new version 10 follow. Technical comments: 1. At the top of sec. 5.1, say something like – Here we focus only on validation of BGPSEC_Path or Secure_Path attribute. And refer to RFC 6811 for the recommended origin validation algorithm. 2. In sec. 5.1 and 5.2, wherever there is mention of validation of *BGPSEC update message*, it should be replaced by “validation of BGPSEC_Path (or Secure_Path or Signature_Block). 3. In sec. 7 (Security Considerations), the vulnerability to replay attacks is currently not mentioned? Should it be mentioned? Editorial comments: 1. Some references to Internet Drafts have old dates (not showing the actual updated dates). 2. Perhaps RFC 6811 should be a normative reference. 3. p. 5, 1st para: “A BGP speaker SHOULD NOT advertise the capability of BGPSEC support for a particular AFI unless it has also advertised the multiprotocol extension capability for the same AFI combination [3].” s\/ a particular AFI\/ a particular set of AFIs\/ 4. p. 7, para 1: s\/in the same way\/ in a similar way\/ 5. The following sentence is repeated on pages 6 and 7: “A BGPSEC update message containing the BGPSEC_Path attribute MUST NOT contain the AS_PATH attribute.” 6. p. 7, para 2: s\/for one AS number\/for each AS number\/ 7. p. 7, para 2: s\/secure path segment\/ Secure_Path segment\/ 8. p. 8, para 4: “(The pCount field is also useful in managing AS Number migrations, see [18] for details.)” Could be replaced with: (The pCount field is also useful in managing route servers (see Section 4.2) and AS Number migrations, see [18] for details.) 9. p. 10, para 2: “When originating a new route advertisement and sending it to an internal peer, the BGPSEC speaker creates a new BGPSEC_Path attribute with zero Secure_Path segments and zero Signature Segments.” This sentence is a bit verbose. There is no BGPSEC_Path attribute if it has zero Secure_Path segments and zero Signature Segments. So why not reword it simply as: “When originating a new route advertisement and sending it to an internal peer, the BGPSEC speaker sends only the NLRI (to an iBGP peer).” 10. The last paragraph on p.11 and the top two paragraphs on p.12 can be moved to the preamble of Section 4 (to a spot just before start of Sec. 4.1). This is because these three paragraphs are generally applicable to both Sections 4.1 and 4.2. 11. p.13, 2nd last para: s\/ to the RPKI router corresponding to the BGPSEC speaker \/ to the RPKI router *certificate* corresponding to the BGPSEC speaker\/ 12. p.16, para 2: s\/ in the Subject Key Identifier extension of the RPKI router corresponding to \/ in the Subject Key Identifier extension of the RPKI router *certificate* corresponding to\/ 13. p.17, last para: s\/ the most recently added Secure_Path *segments*\/ the most recently added Secure_Path *segment*\/ (make “segments” singular) 14. p 18, para 3: s\/ for a signature produced by a BGPSEC speaker outside of a confederation\/ for a signature produced by a *peer* BGPSEC speaker outside of a confederation\/ 15. In Sections 5.1 and 5.2, search “update message” and see if it should be replaced by “BGPSEC_Path attribute” or Secure_Path” or “Signature_Block” as the case may be. (In the context of validation) 16. p.28, 3 rd last para: s\/ A BGPSEC speaker\/ a BGPSEC speaker\/ (should be lower case A) Sriram"}
{"_id":"doc-en-sidr-JhAJSRGUCp1BpLfyvvJ3UDN3UzE","title":"","text":"[sidr] New version : draft-ietf-sidr-bgpsec-protocol-10\nJust posted the -10 revision of the document. The only normative change was to decouple BGPsec validation from Origin Validation. (This is a normative change to the validation algorithm in Section 5.) This is based on working group discussions at IETF 90 and confirmed on the list in September. Additionally, there were some text changes made, including a reference to the AS-Migration document (and an accompanying text change regarding pCount=0). I have a couple of improvements to the security considerations text that I wasn't able to fold into this version of the document. Other than improving the security considerations, I am not aware of any open issues in this particular document. - Matt Lepinski"}
{"_id":"doc-en-sidr-mhGhykmWMPC5zYMEcEUvxsr4sw4","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-10.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-10.txt Pages : 34 Date : 2014-10-27 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-10 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-10 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-DlTKUvUZqh4xR3S1e3EuJI5DbBI","title":"","text":"Re: [sidr] WGLC - draft-ietf-sidr-as-migration\nI support the publication of this document as an RFC. I have read the revised -02 version carefully. The description of the methodology is clear, and no inconsistencies found with reference to the BGPsec protocol draft [draft-ietf-sidr-bgpsec-protocol]. I thank the authors for incorporating most of my earlier comments\/suggestions. Some minor nits\/editorial comments follow: 1. Figures 3 and 4 from the companion I-D draft-ietf-idr-as-migration are referenced several times in this document. It would be easier for the readers if those two figures are reproduced in this document when they are first referenced. Readers can then avoid having to go back and forth between the two documents. 2. The meaning of this sentence on p.4 is lost on me. \"Since they are using methods to migrate that do not require coordination with customers, they do not have a great deal of control over the length of the transition period as they might with something completely under their administrative control (e.g. a key roll).\" For me, \"do not require coordination with customers\" and \"completely under their administrative control\" are on the same side of the equation. May be this paraphrasing will help: \"Since they are using interim methods to migrate that seek to postpone requiring coordination with customers, they do not have a great deal of control over the length of the transition period as they might with something completely under their administrative control (e.g. a key roll).\" 3. Sentence on p.5 reads: \"Assuming that this mismatch will be allowed by vendor implementations and using it as a means to solve this migration case is likely to be problematic.\" Please consider changing it to (for grammatical accuracy): \"Assuming that this mismatch will be allowed by vendor implementations, using it as a means to solve this migration case is likely to be problematic.\" Thanks. Sriram"}
{"_id":"doc-en-sidr-le6m0UcIDNL7h867NTWhTvv14lA","title":"","text":"Re: [sidr] minutes note consensus on several topics\nSandy, The minutes note consensus in the meeting on several topics. I'm attempting to capture them here. The mailing list is always the final word on consensus. If you object to any of the following, you should speak on list now! If I've missed something noted in the minutes, you should speak on the list now! If you think there was consensus on a topic not noted in the minutes - see previous message about the deadline for corrections. In the discussion of draft-ietf-sidr-bgpsec-protocol: consensus to remove origin validation check from this document and add text explaining the oddly appearing case of OV invalid, BGPSEC path authentic\/valid. Discussion has not converged <consensus that there was no consensus on signature choice> In the discussion of draft-ietf-sidr-as-migration: 1) What status should this document be? Concensus appeared to be the same status as BGPSEC concur 2) Should this document be merged into BGPSEC-Protocol Concensus appeared to be not to merge yes. 3) Should this document \"Update\" BGPSEC-Protocol Concensus appeared to be that an update header is not needed if both missing text at the end? In the discussion of Router Keying Communication of cert to CA: Concensus <sic> appeared to be that one ASN per router certificate is sufficient. agreed. Steve"}
{"_id":"doc-en-sidr-02EW8GPILsPXHYVicTaWtY1UPUU","title":"","text":"[sidr] minutes note consensus on several topics\nThe minutes note consensus in the meeting on several topics. I'm attempting to capture them here. The mailing list is always the final word on consensus. If you object to any of the following, you should speak on list now! If I've missed something noted in the minutes, you should speak on the list now! If you think there was consensus on a topic not noted in the minutes - see previous message about the deadline for corrections. In the discussion of draft-ietf-sidr-bgpsec-protocol: consensus to remove origin validation check from this document and add text explaining the oddly appearing case of OV invalid, BGPSEC path authentic\/valid. Discussion has not converged <consensus that there was no consensus on signature choice> In the discussion of draft-ietf-sidr-as-migration: 1) What status should this document be? Concensus appeared to be the same status as BGPSEC 2) Should this document be merged into BGPSEC-Protocol Concensus appeared to be not to merge 3) Should this document \"Update\" BGPSEC-Protocol Concensus appeared to be that an update header is not needed if both In the discussion of Router Keying Communication of cert to CA: Concensus <sic> appeared to be that one ASN per router certificate is sufficient. --Sandy"}
{"_id":"doc-en-sidr-Pet-JTYeXehltAiTcqV-jWnznXQ","title":"","text":"Re: [sidr] comment on draft-ietf-sidr-bgpsec-protocol and\n draft-ietf-sidr-bgpsec-ops\nSandy, Speaking as regular ol' member The bgpsec-protocol draft has the following text: Next, the BGPSEC speaker verifies that the origin AS is authorized to advertise the prefix in question. To do this, consult the valid ROA data to obtain a list of AS numbers that are associated with the given IP address prefix in the update message. Then locate the last (least recently added) AS number in the Secure_Path portion of the BGPSEC_Path attribute. If the origin AS in the Secure_Path is not in the set of AS numbers associated with the given prefix, then the BGPSEC update message is 'Not Valid' and the validation algorithm terminates. This text reprises the origin validation algorithm, without some of the more detailed pieces. I believe it would be better instead to refer to RFC6483 or RFC6811, rather than try to reprise the algorithm. Something like: \"To do this, the speaker performs the algorithm of RFC6483\/RFC6811. If the result is not Valid, then the BGP Update is 'Not Valid'.\" (This seems particularly prudent as we might be reconsidering the validation algorithm.) good point. we should use a reference rather than paraphrase. This also brought to mind a point I'm curious about. Does a bgpsec speaking router have one configuration about the results of the bgpsec validation, or does it have two configurations, one for the results of the origin validation and a second for the results of the bgpsec validation? Are the two validation states separated? Should this be a point to be explained in the bgpsec-ops document? For origin validation, a router needs the binding between an AS and a set of prefixes. For BGPsec, it needs a binding between a public key and a set of ASes. So I see these as separate databases. Steve"}
{"_id":"doc-en-sidr-jp-Ef2Sg0IgRM507AqWgMZi_KPE","title":"","text":"Re: [sidr] comment on draft-ietf-sidr-bgpsec-protocol and\n draft-ietf-sidr-bgpsec-ops\nWith regards to the bgpsec-protocol document, I agree with Sandy that the protocol document should reference RFC 6811\/6483. I will reference the origin validation algorithm in next version of bpgsec-protocol. With regards to the bpgsec-ops document, it isn't at all clear to me what the \"right\" answer is for how an implementation handles configuration of origin validation and path validation (when both are implemented). Unless there is something that we fear implementations might do that is clearly bad, I don't see value in adding text to bgpsec-ops. Speaking as regular ol' member The bgpsec-protocol draft has the following text: Next, the BGPSEC speaker verifies that the origin AS is authorized to advertise the prefix in question. To do this, consult the valid ROA data to obtain a list of AS numbers that are associated with the given IP address prefix in the update message. Then locate the last (least recently added) AS number in the Secure_Path portion of the BGPSEC_Path attribute. If the origin AS in the Secure_Path is not in the set of AS numbers associated with the given prefix, then the BGPSEC update message is 'Not Valid' and the validation algorithm terminates. This text reprises the origin validation algorithm, without some of the more detailed pieces. I believe it would be better instead to refer to RFC6483 or RFC6811, rather than try to reprise the algorithm. Something like: \"To do this, the speaker performs the algorithm of RFC6483\/RFC6811. If the result is not Valid, then the BGP Update is 'Not Valid'.\" (This seems particularly prudent as we might be reconsidering the validation algorithm.) This also brought to mind a point I'm curious about. Does a bgpsec speaking router have one configuration about the results of the bgpsec validation, or does it have two configurations, one for the results of the origin validation and a second for the results of the bgpsec validation? Are the two validation states separated? Should this be a point to be explained in the bgpsec-ops document? --Sandy, speaking as regular ol' member _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-ipQxpd5WXv2KFZBsZqj9BG-ehAI","title":"","text":"Re: [sidr] comment on draft-ietf-sidr-bgpsec-protocol and\n draft-ietf-sidr-bgpsec-ops\nSpeaking as regular ol' member The bgpsec-protocol draft has the following text: Next, the BGPSEC speaker verifies that the origin AS is authorized to advertise the prefix in question. To do this, consult the valid ROA data to obtain a list of AS numbers that are associated with the given IP address prefix in the update message. Then locate the last (least recently added) AS number in the Secure_Path portion of the BGPSEC_Path attribute. If the origin AS in the Secure_Path is not in the set of AS numbers associated with the given prefix, then the BGPSEC update message is 'Not Valid' and the validation algorithm terminates. This text reprises the origin validation algorithm, without some of the more detailed pieces. I believe it would be better instead to refer to RFC6483 or RFC6811, rather than try to reprise the algorithm. Something like: \"To do this, the speaker performs the algorithm of RFC6483\/RFC6811. If the result is not Valid, then the BGP Update is 'Not Valid'.\" (This seems particularly prudent as we might be reconsidering the validation algorithm.) This also brought to mind a point I'm curious about. Does a bgpsec speaking router have one configuration about the results of the bgpsec validation, or does it have two configurations, one for the results of the origin validation and a second for the results of the bgpsec validation? Are the two validation states separated? Should this be a point to be explained in the bgpsec-ops document? ³Does² is an interesting question. Clearly one can. Our prototype does. So far I thought we were not standardizing the local policy mechanisms that could be built off of the protocol mechanisms. Given that we permit lazy evaluation, one might envision employing RPKI-based OV on a BGPSEC update before getting around to doing PATH validation. Now providing guidance that trusting origin validation when path validation has failed might not be bad. But even there, first the first hop sig might be valid ... --Sandy, speaking as regular ol' member ‹ Doug Montgomery, Mgr Internet & Scalable Systems Research NIST\/ITL\/ANTD"}
{"_id":"doc-en-sidr-MO7W75jaoPlsYu_5dX9dLmGGjU4","title":"","text":"[sidr] comment on draft-ietf-sidr-bgpsec-protocol and\n draft-ietf-sidr-bgpsec-ops\nSpeaking as regular ol' member The bgpsec-protocol draft has the following text: Next, the BGPSEC speaker verifies that the origin AS is authorized to advertise the prefix in question. To do this, consult the valid ROA data to obtain a list of AS numbers that are associated with the given IP address prefix in the update message. Then locate the last (least recently added) AS number in the Secure_Path portion of the BGPSEC_Path attribute. If the origin AS in the Secure_Path is not in the set of AS numbers associated with the given prefix, then the BGPSEC update message is 'Not Valid' and the validation algorithm terminates. This text reprises the origin validation algorithm, without some of the more detailed pieces. I believe it would be better instead to refer to RFC6483 or RFC6811, rather than try to reprise the algorithm. Something like: \"To do this, the speaker performs the algorithm of RFC6483\/RFC6811. If the result is not Valid, then the BGP Update is 'Not Valid'.\" (This seems particularly prudent as we might be reconsidering the validation algorithm.) This also brought to mind a point I'm curious about. Does a bgpsec speaking router have one configuration about the results of the bgpsec validation, or does it have two configurations, one for the results of the origin validation and a second for the results of the bgpsec validation? Are the two validation states separated? Should this be a point to be explained in the bgpsec-ops document? --Sandy, speaking as regular ol' member"}
{"_id":"doc-en-sidr-0qS5fmKGTnhjKAwpoFuGnF_FHo0","title":"","text":"Re: [sidr] New version draft-ietf-sidr-bgpsec-protocol\nOn Fri, 4 Jul 2014 18:16:17 -0400, Matthew Lepinski <mlepinski.ietf@gmail.com> said: ML> I submitted a new version of the bgpsec protocol document. This ML> revision includes a fair number of editorial changes but does ML> not include any normative changes. ML> Now that the BGPSEC requirements document is essentially done, I ML> look forward to discussing the protocol document again in ML> Toronto. In particular, between now and the Toronto meeting I ML> will write up (and send to the list) a brief comparison between ML> the requirements in the final version of the reqs draft and what ML> we deliver in the protocol document. ML> The only open issue in the protocol document that I am aware of ML> is the following: ML> * It was suggested in a review that we should explicitly specify ML> (when we discuss error handling) that an implementation send a ML> BGP NOTIFICATION message when an error occurs. ML> Personally, I don't think this is necessary. (In particular, my ML> reading of draft-ietf-idr-error-handling-13 is that in the ML> \"treat as withdrawal\" case that a NOTIFICATION message is not ML> required. I'm working on a BGPSEC implementation and I've made some comments on error handling in the past. If it is my comment you are mentioning, then that wasn't quite what I meant. In any case, I agree that not all errors should behave the same. I do think that for a specific error case, the error handling description should explicitly state whether or not a notification should be sent for that type of error. E.g., when 'A' happens a notification SHOULD (or SHOULD NOT) be sent. I think the previous update together with the reference to the idr-error-handling draft answered the issues I had. Looking through the 09 draft's version of UPDATE message error handling, the edits have only made it clearer. One minor thing I think is missing is a description of how to handle multiple BGPSEC_Path attributes. Without it, I believe the default response would be a session reset, but a treat-as-withdraw would be more consistent. My reading of idr-error-handling is that 2+ AS_PATH attributes, or an AS_PATH and BGPSEC_PATH attribute in an UPDATE message would indicate a treat-as-withdraw. But without a description of the handling of multiple BGPSEC_PATH attributes in the bgpsec-protocol doc, 2+ BGPSEC_PATH attributes would indicate a session-reset. ML> That being said, I am very willing to defer to the BGP experts ML> in the group on this issue. In particular, does anyone know if ML> the intention of draft-ietf-idr-error-handling is for a ML> NOTIFICATION to be sent when an error is \"treat as withdrawal\"? ML> (I am concerned that sending a NOTIFICATION message in a case ML> where we are not closing the session is not a good idea, but I ML> am certain that others know more about these details than I do.) I'm not sure about the intention of idr-error-handling draft. But FWIW, my reading of the draft is that a session-reset MUST send a notification. A treat-as-withdraw would not normally send a notification, but could for a specific case. I'm using that interpretation when reading the bgpsec-protocol draft. I.e., A treat-as-withdraw indicates no notification is sent unless otherwise specified. -Mike -- Michael Baer baerm@tislabs.com Senior Software Engineer Parsons Global Shared Services, Cyber Security Division C: 530.902.3131"}
{"_id":"doc-en-sidr-Fw55ou3G_hhLFryQ1PYDiEnOqNE","title":"","text":"Re: [sidr] New version draft-ietf-sidr-bgpsec-protocol\nWRT integrating the two specs … whatever is easier. spt On Jul 07, 2014, at 13:06, Matthew Lepinski <mlepinski.ietf@gmail.com> wrote: Oh, one other thing: If anyone on this list thinks that instead of referencing as-migration, that we are better off merging as-migration into bgpsec-protocol, this would be a great time to speak up. (That is, it is not too late to pull the solution from as-migration directly into bgpsec-protocol, but if we are going to go down that road, we should do it as soon as possible!) On Mon, Jul 7, 2014 at 1:03 PM, Matthew Lepinski <mlepinski.ietf@gmail.com> wrote: Wes, I agree that inserting a reference in bgpsec-protocol (and bgpsec-overview) and then publishing as-migration as part of the bgpsec document set (along with the router certificate profile, the algorithm document, etc) is a good way forward. I need to do a careful review of the latest version of as-migration (I really haven't looked at the -01). I will get to that before we meet in Toronto. Also, I am open to suggestions with regards to where to insert a reference to as-migration -- but I will try to suggestion for how to link the two documents in time for Toronto. - Matt Lepinski From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-kR32ViCIZnfN8Fw50m8ypccdq9k","title":"","text":"Re: [sidr] New version draft-ietf-sidr-bgpsec-protocol\nOh, one other thing: If anyone on this list thinks that instead of referencing as-migration, that we are better off merging as-migration into bgpsec-protocol, this would be a great time to speak up. (That is, it is not too late to pull the solution from as-migration directly into bgpsec-protocol, but if we are going to go down that road, we should do it as soon as possible!) On Mon, Jul 7, 2014 at 1:03 PM, Matthew Lepinski <mlepinski.ietf@gmail.com> wrote: Wes, I agree that inserting a reference in bgpsec-protocol (and bgpsec-overview) and then publishing as-migration as part of the bgpsec document set (along with the router certificate profile, the algorithm document, etc) is a good way forward. I need to do a careful review of the latest version of as-migration (I really haven't looked at the -01). I will get to that before we meet in Toronto. Also, I am open to suggestions with regards to where to insert a reference to as-migration -- but I will try to suggestion for how to link the two documents in time for Toronto. - Matt Lepinski On Mon, Jul 7, 2014 at 12:40 PM, George, Wes <wesley.george@twcable.com> wrote: From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- ------------------------------ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. Oh, one other thing:If anyone on this list thinks that instead of referencing as-migration, that we are better off merging as-migration into bgpsec-protocol, this would be a great time to speak up. (That is, it is not too late to pull the solution from as-migration directly into bgpsec-protocol, but if we are going to go down that road, we should do it as soon as possible!) On Mon, Jul 7, 2014 at 1:03 PM, Matthew Lepinski <mlepinski.ietf@gmail.com> wrote: Wes,I agree that inserting a reference in bgpsec-protocol (and bgpsec-overview) and then publishing as-migration as part of the bgpsec document set (along with the router certificate profile, the algorithm document, etc) is a good way forward. I need to do a careful review of the latest version of as-migration (I really haven't looked at the -01). I will get to that before we meet in Toronto. Also, I am open to suggestions with regards to where to insert a reference to as-migration -- but I will try to suggestion for how to link the two documents in time for Toronto. - Matt Lepinski From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-od9jgQZ2Y75ajrQswn4-Xy37x0g","title":"","text":"Re: [sidr] New version draft-ietf-sidr-bgpsec-protocol\nWes, I agree that inserting a reference in bgpsec-protocol (and bgpsec-overview) and then publishing as-migration as part of the bgpsec document set (along with the router certificate profile, the algorithm document, etc) is a good way forward. I need to do a careful review of the latest version of as-migration (I really haven't looked at the -01). I will get to that before we meet in Toronto. Also, I am open to suggestions with regards to where to insert a reference to as-migration -- but I will try to suggestion for how to link the two documents in time for Toronto. - Matt Lepinski On Mon, Jul 7, 2014 at 12:40 PM, George, Wes <wesley.george@twcable.com> wrote: From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- ------------------------------ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. Wes,I agree that inserting a reference in bgpsec-protocol (and bgpsec-overview) and then publishing as-migration as part of the bgpsec document set (along with the router certificate profile, the algorithm document, etc) is a good way forward. I need to do a careful review of the latest version of as-migration (I really haven't looked at the -01). I will get to that before we meet in Toronto. Also, I am open to suggestions with regards to where to insert a reference to as-migration -- but I will try to suggestion for how to link the two documents in time for Toronto. - Matt Lepinski From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-xbfXnqJYX7TnapH3pMmDAwKTB4Y","title":"","text":"Re: [sidr] New version draft-ietf-sidr-bgpsec-protocol\nFrom: Matthew Lepinski <mlepinski.ietf@gmail.com<mailto:mlepinski.ietf@gmail.com>> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org<mailto:sidr@ietf.org>\" <sidr@ietf.org<mailto:sidr@ietf.org>> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- ________________________________ This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. From: Matthew Lepinski <mlepinski.ietf@gmail.com> Date: Friday, July 4, 2014 at 6:16 PM To: \"sidr@ietf.org\" <sidr@ietf.org> Subject: [sidr] New version draft-ietf-sidr-bgpsec-protocol I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: [snip] Matt - One additional change I think is necessary is to add a reference to ietf-sidr-as-migration. This is effectively an extension of the BGPSec protocol that is contained in a separate document. If the BGPSec doc was already done, I'd most likely be using the metadata of as-migration to update RFCnnnn so that the link would exist from the BGPSec protocol doc in addition to the normative reference to -protocol from as–migration, but in the current form where it's trivial to update the -protocol draft, I think that should instead be accomplished by a forward reference, and then the two documents will simply be part of the group of interdependent docs that get released for BGPSec (assuming of course that -as–migration passes LC). That said, my quick scan of –protocol didn't reveal an obvious place to insert that reference, so if you or others have ideas of where it should go, I'm happy to contribute a few lines of wrapper text. Thanks, Wes Anything below this line has been added by my company’s mail server, I have no control over it. ----------- This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-LkvZphYGtvXYjt9LuO_bGTqq4-Q","title":"","text":"[sidr] FW: New Version Notification for\n draft-sriram-route-leak-protection-00\nThis is a -00 individual draft contribution. I will consult with GROW and SIDR chairs regarding a possible presentation of this work in Toronto. Your comments, suggestions requested. Sriram -----Original Message----- From: internet-drafts@ietf.org [mailto:internet-drafts@ietf.org] Sent: Friday, July 04, 2014 7:17 PM To: Sriram, Kotikalapudi; Montgomery, Douglas; Montgomery, Douglas; Sriram, Kotikalapudi Subject: New Version Notification for draft-sriram-route-leak-protection-00.txt A new version of I-D, draft-sriram-route-leak-protection-00.txt has been successfully submitted by Kotikalapudi Sriram and posted to the IETF repository. Name: draft-sriram-route-leak-protection Revision: 00 Title: Enhancement to BGPSEC for Protection against Route Leaks Document date: 2014-07-04 Group: Individual Submission Pages: 11 URL: http:\/\/www.ietf.org\/internet-drafts\/draft-sriram-route-leak-protection-00.txt Status: https:\/\/datatracker.ietf.org\/doc\/draft-sriram-route-leak-protection\/ Htmlized: http:\/\/tools.ietf.org\/html\/draft-sriram-route-leak-protection-00 Abstract: This document enumerates different types of route leaks based on observed events on the Internet. It illustrates how BGPSEC in its current form (as described in draft-ietf-sidr-bgpsec-protocol-09) already provides protection against all but one of these route-leaks scenarios. The document further discusses a design enhancement to the BGPSEC protocol that will extend protection against this one remaining type of route-leak attack as well. With the inclusion of this enhancement, BGPSEC is expected to provide protection against all types of route-leaks. The document also includes a stopgap method for detection and mitigation of route leaks for the phase when BGPSEC (path validation) is not yet deployed but only origin validation is deployed. Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. The IETF Secretariat"}
{"_id":"doc-en-sidr-wznSILixMDQiCX4w0gzVtcUl3Jk","title":"","text":"[sidr] New version draft-ietf-sidr-bgpsec-protocol\nI submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes. Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following: * It was suggested in a review that we should explicitly specify (when we discuss error handling) that an implementation send a BGP NOTIFICATION message when an error occurs. Personally, I don't think this is necessary. (In particular, my reading of draft-ietf-idr-error-handling-13 is that in the \"treat as withdrawal\" case that a NOTIFICATION message is not required. That being said, I am very willing to defer to the BGP experts in the group on this issue. In particular, does anyone know if the intention of draft-ietf-idr-error-handling is for a NOTIFICATION to be sent when an error is \"treat as withdrawal\"? (I am concerned that sending a NOTIFICATION message in a case where we are not closing the session is not a good idea, but I am certain that others know more about these details than I do.) I submitted a new version of the bgpsec protocol document. This revision includes a fair number of editorial changes but does not include any normative changes.Now that the BGPSEC requirements document is essentially done, I look forward to discussing the protocol document again in Toronto. In particular, between now and the Toronto meeting I will write up (and send to the list) a brief comparison between the requirements in the final version of the reqs draft and what we deliver in the protocol document. The only open issue in the protocol document that I am aware of is the following:* It was suggested in a review that we should explicitly specify (when we discuss error handling) that an implementation send a BGP NOTIFICATION message when an error occurs. Personally, I don't think this is necessary. (In particular, my reading of draft-ietf-idr-error-handling-13 is that in the \"treat as withdrawal\" case that a NOTIFICATION message is not required. That being said, I am very willing to defer to the BGP experts in the group on this issue. In particular, does anyone know if the intention of draft-ietf-idr-error-handling is for a NOTIFICATION to be sent when an error is \"treat as withdrawal\"? (I am concerned that sending a NOTIFICATION message in a case where we are not closing the session is not a good idea, but I am certain that others know more about these details than I do.)"}
{"_id":"doc-en-sidr-NPc2Rp1OKc1Tu3kFTW78roEo1c0","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-09.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-09.txt Pages : 34 Date : 2014-07-04 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-09 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-09 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-xryUBGLq9BkJjN-NEcBNzs0QxBI","title":"","text":"Re: [sidr] BGPSEC Algorithms document missing a clear reference?\nNew version should be posted soon addressing this and some other reference updaets. spt On Mar 11, 2014, at 11:56, Christopher Morrow <morrowc.lists@gmail.com> wrote: Chris, It was pointed out in passing (hallway\/table conversation) that in: draft-ietf-sidr-bgpsec-algs-05 (at least 05) there's this text in section 2: \"NOTE: The exception to the above hashing algorithm is the use of SHA-1 [SHS] when CAs generate authority and subject key identifiers [ID.bgpsec-pki-profiles].\" The reference to bgpsec-pki-profiles, is PROBABLY really: draft-sidr-bgpsec-pki-profiles <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol> not sure why the angle bracket reference to the bgpsec protocol appears above, angle brackets because of old-skool email-client\/URL interpolation habits :( wrong reference because ... #fail. The right one: <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-pki-profiles> apologies for the confusion. after the intended reference. But, as you note below, draft-sidr-bgpsec-pki-profiles does not refer to SKI's.It says that it inherits all of the RPKI cert profile (RFC 6487) except as noted in Section 3 of the I-D. RFC 6487 mandates inclusion of the SKI and AKI extensions, and specifies use of SHA-1 to compute SKI and AKI values. So, the text above should be changed to refer RFC 6487. (There is no need to go back to 5280, since 6487 cites it and narrows the SKI\/AKI generation options from that RFC.) awesome! the OP was correct in pointing out the missing linkages, sweet :) _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-r6BML4IFkNbAjTnBvOC1GUvaTws","title":"","text":"Re: [sidr] BGPSEC Algorithms document missing a clear reference?\nChris, It was pointed out in passing (hallway\/table conversation) that in: draft-ietf-sidr-bgpsec-algs-05 (at least 05) there's this text in section 2: \"NOTE: The exception to the above hashing algorithm is the use of SHA-1 [SHS] when CAs generate authority and subject key identifiers [ID.bgpsec-pki-profiles].\" The reference to bgpsec-pki-profiles, is PROBABLY really: draft-sidr-bgpsec-pki-profiles <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol> not sure why the angle bracket reference to the bgpsec protocol appears above, angle brackets because of old-skool email-client\/URL interpolation habits :( wrong reference because ... #fail. The right one: <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-pki-profiles> apologies for the confusion. after the intended reference. But, as you note below, draft-sidr-bgpsec-pki-profiles does not refer to SKI's.It says that it inherits all of the RPKI cert profile (RFC 6487) except as noted in Section 3 of the I-D. RFC 6487 mandates inclusion of the SKI and AKI extensions, and specifies use of SHA-1 to compute SKI and AKI values. So, the text above should be changed to refer RFC 6487. (There is no need to go back to 5280, since 6487 cites it and narrows the SKI\/AKI generation options from that RFC.) awesome! the OP was correct in pointing out the missing linkages, sweet :) _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-C1cWt4lVDOv44xW2cKWTR2GsZbc","title":"","text":"Re: [sidr] BGPSEC Algorithms document missing a clear reference?\nChris, It was pointed out in passing (hallway\/table conversation) that in: draft-ietf-sidr-bgpsec-algs-05 (at least 05) there's this text in section 2: \"NOTE: The exception to the above hashing algorithm is the use of SHA-1 [SHS] when CAs generate authority and subject key identifiers [ID.bgpsec-pki-profiles].\" The reference to bgpsec-pki-profiles, is PROBABLY really: draft-sidr-bgpsec-pki-profiles <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol> not sure why the angle bracket reference to the bgpsec protocol appears above, after the intended reference. But, as you note below, draft-sidr-bgpsec-pki-profiles does not refer to SKI's.It says that it inherits all of the RPKI cert profile (RFC 6487) except as noted in Section 3 of the I-D. RFC 6487 mandates inclusion of the SKI and AKI extensions, and specifies use of SHA-1 to compute SKI and AKI values. So, the text above should be changed to refer RFC 6487. (There is no need to go back to 5280, since 6487 cites it and narrows the SKI\/AKI generation options from that RFC.) Steve"}
{"_id":"doc-en-sidr-7BavhPybXnBwSjTIOUXHozNtg9U","title":"","text":"[sidr] BGPSEC Algorithms document missing a clear reference?\nIt was pointed out in passing (hallway\/table conversation) that in: draft-ietf-sidr-bgpsec-algs-05 (at least 05) there's this text in section 2: \"NOTE: The exception to the above hashing algorithm is the use of SHA-1 [SHS] when CAs generate authority and subject key identifiers [ID.bgpsec-pki-profiles].\" The reference to bgpsec-pki-profiles, is PROBABLY really: draft-sidr-bgpsec-pki-profiles <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol> There doesn't seem to be a reference to sha1 here for making an SKI. It looks like you'd have to inherit and inherit from 3779 -> 5280 and text in section 4.2.1.2: \" For CA certificates, subject key identifiers SHOULD be derived from the public key or a method that generates unique values. Two common methods for generating key identifiers from the public key are: (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bits). Cooper, et al. Standards Track [Page 28] RFC 5280 PKIX Certificate and CRL Profile May 2008 (2) The keyIdentifier is composed of a four-bit type field with the value 0100 followed by the least significant 60 bits of the SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bits). \" Is this the intention? that spelunking in rfcs is required to figure out that sha1 would be used? or could\/should the reference be more clear? -chris (care of mystery caller #7)"}
{"_id":"doc-en-sidr-G86xPXxYgRElTmNnelVc5ZW2ZBg","title":"","text":"Re: [sidr] BGPSEC Protocol -08\nOn Tue, 5 Nov 2013 01:38:19 -0500, Matthew Lepinski <mlepinski.ietf@gmail.com> said: MattL> I have submitted draft-ietf-sidr-bgpsec-protocol-08. My MattL> apologies that I didn't get this version in the draft MattL> repository before the IETF 88 cut-off. MattL> The main change in this version of the document is that I MattL> added a reference to draft-ietf-idr-error-handling. The text MattL> now references this document with regards to errors in the MattL> BGPSEC_Path attribute. Additionally, the document clearly MattL> specifies that for any error in the BGPSEC_Path attribute, MattL> the BGPSEC speaker MUST \"treat-as-withdraw\" (as defined in MattL> draft-ietf-idr-error-handling). MattL> Additionally, I made a small number of editorial changes MattL> which I believe improve the clarity of the text in a couple MattL> of places. I agree with most of the error handling updates but I have several comments on them as well. Mostly I think there should be more specific language on how to handle the errors. The first comment is editorial. At the bottom of page 24 (section 5.2), it looks there is a cut\/paste error and some text wasn't removed from the previous draft that should have been: an error in the BGPSEC_Path attribute, then the implementation should notify the operator that an error has occurred and treat the update in a manner consistent with other BGP errors (i.e., following RFC 4271 [2] or any future updates to that document). Also in section 5.2, I think the language should more explicitly state what do when an error occurs. This would include sending a NOTIFICATION message with new error Subcode of Malformed BGPSEC Attribute. Suggested text: Current: If any of these checks fail, it is an error in the BGPSEC_Path attribute. Any of these errors in the BGPSEC_Path attribute are handled as per RFC WXYZ [12]. BGPSEC speakers MUST handle these errors using the \"treat-as-withdraw\" approach as defined in RFC WXYZ [12]. Add: The implementation should notify the operator that an error has occurred and send a NOTIFICATION message with an Error Subcode set to Malformed BGPSEC Attribute and an empty data field. Also, of the 5 error types, the AS_PATH being included along with a BGPSEC attribute in an UPDATE message is not really a Malformed BGPSEC Attribute error. So I think this error should be handled otherwise the same but with a different error Subcode in the NOTIFICATION. e.g. N. Check that the update message does not contain an AS_PATH attribute. If this check fail, it is an error in the UPDATE's attribute list. This error is handled as per RFC WXYZ [12]. BGPSEC speakers MUST handle this errors using the \"treat-as-withdraw\" approach as defined in RFC WXYZ [12]. The implementation should notify the operator that an error has occurred and send a NOTIFICATION message with an Error Subcode set to Malformed Attribute List and an empty data field -Mike -- Michael Baer baerm@tislabs.com Senior Research Scientist Parsons - Tislabs C: 530.902.3131"}
{"_id":"doc-en-sidr-tzmgJK25jtsxcmUQTgS4pBEt-50","title":"","text":"[sidr] BGPSEC Protocol -08\nI have submitted draft-ietf-sidr-bgpsec-protocol-08. My apologies that I didn't get this version in the draft repository before the IETF 88 cut-off. The main change in this version of the document is that I added a reference to draft-ietf-idr-error-handling. The text now references this document with regards to errors in the BGPSEC_Path attribute. Additionally, the document clearly specifies that for any error in the BGPSEC_Path attribute, the BGPSEC speaker MUST \"treat-as-withdraw\" (as defined in draft-ietf-idr-error-handling). Additionally, I made a small number of editorial changes which I believe improve the clarity of the text in a couple of places. - Matt Lepinski I have submitted draft-ietf-sidr-bgpsec-protocol-08.My apologies that I didn't get this version in the draft repository before the IETF 88 cut-off. The main change in this version of the document is that I added a reference to draft-ietf-idr-error-handling. The text now references this document with regards to errors in the BGPSEC_Path attribute. Additionally, the document clearly specifies that for any error in the BGPSEC_Path attribute, the BGPSEC speaker MUST \"treat-as-withdraw\" (as defined in draft-ietf-idr-error-handling). Additionally, I made a small number of editorial changes which I believe improve the clarity of the text in a couple of places.- Matt Lepinski"}
{"_id":"doc-en-sidr-YxOeq9lB1qvcx-Vs6ljEenUdcgg","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-08.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-08.txt Pages : 35 Date : 2013-11-04 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-08 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-08 Please note that it may take a couple of minutes from the time of submission until the htmlized version and diff are available at tools.ietf.org. Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-28CRn-hs1OEUl8KNvEbusnK5V-s","title":"","text":"Re: [sidr] Acceptance call for draft-george-sidr-as-migration-01.txt\nThanks, George. Some comments in line. From: Sriram, Kotikalapudi [mailto:kotikalapudi.sriram@nist.gov] Please note that some minor omissions have resulted in technical inaccuracies in the AS_PATH and\/or bgpsec update representation in the example scenarios\/solutions (see pages 21, 23 of the attached). [WEG] I reviewed that, (eg \"Comment: AS_PATH must show the actual path traversed; cannot hide AS 200.\") and I don't think that's correct. The entire point behind this draft and its companion is that when using Local\/replace AS functions, the AS_PATH is actually manipulated and the AS that we desire to hide *is* hidden from the AS_PATH, so I believe that the example is correct as it stands. The AS_PATH is a BGP-4 attribute. We shouldn't be ideally using it when we illustrate a BGPSEC update with signatures etc. in the examples (unless we refer to it as Equivalent AS_PATH or something). BGPSEC has the Secure_Path attribute instead (pages 8, 9 of the spec) http:\/\/tools.ietf.org\/pdf\/draft-ietf-sidr-bgpsec-protocol-07.pdf +----------------------------+ | AS Number (4 octets) | +----------------------------+ | pCount (1 octet) | +----------------------------+ | Flags (1 octet) | +----------------------------+ All ASes in the path are included in the Secure_Path, including the \"hidden\" ones (w\/ pCount=0). In BGPSEC, the AS intended to be hidden is only implicitly hidden. The receiver cannot verify the update signatures unless all ASNs that signed are included in the Secure_Path. For the examples, I think that showing a condensed version of the Secure_Path works, where the hidden ASes are shown with pcount=0 next to them, like, Secure_Path = 200, 300(pcount=0), 100 length = sum(pcount) = 2 (length is NOT 3) One key technical comment is related to an additional scenario that may be worthwhile including for the proposed solution. It has to do with three ISP's (or ASes) being involved in the migration scenario: ISP A' ISP A' CE-1 ---------> PE-1 -------------------> PE-3 -----------> CE-3 100 Old_ASN: 300 Old_ASN: 500 600 New_ASN: 200 New_ASN: 200 | | | | | | | ISP A' | ------------PE-2---------------- Old_ASN: 200 New_ASN: 200 Here both PE's (PE-1 on left and PE-3 right) are using Local ASN with their respective CEs. I have worked out (illustrated) a solution for this scenario (see page 24 of the attachment). This should hopefully round up (complete) the basic set of scenarios operators may encounter in the real world. [WEG] In looking at your example, I'm not sure whether it's totally necessary as a separate scenario - it doesn't seem that the process changes any, and dealing with all of these different ASNs starts becoming hard to parse. Would it suffice to add a simple statement that this will work the same way if there are multiple different ASNs simultaneously being migrated into the subsuming ASN? Anyone else in the WG have an opinion on this matter? I would like to hear others' thoughts on this. The solution (worked out on p. 24) seems not so hard to parse to me. But it is your call. You can keep this in the reserve if you like and we can ruminate over it. There is still time until this goes to WGLC. Sriram"}
{"_id":"doc-en-sidr-J3h6h64UGxrhRTp_4GKoANpOUd8","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-07.txt\nNew version of draft-ietf-bpgsec-protocol. The only changes that I made were in Section 2 (negotiation of BGPSEC). The previous version defined two separate capabilities (a Send capability and a Receive capability). The authors received feedback that it was important not to be wasteful of BGP capability numbers and therefore the two capabilities were merged into a single BGPSEC capability. A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-07.txt Pages : 35 Date : 2013-02-25 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-07 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-07 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-_aebNDFXCCMDPJRnKL32zCBQRfk","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-07.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-07.txt Pages : 35 Date : 2013-02-25 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-07 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-07 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-n3WSvBR21gh4NeKKWLbecXk4qb4","title":"","text":"Re: [sidr] BGP capability in draft-ietf-sidr-bgpsec-protocol-06\ncapability codes will soon be in short supply. Use a bit set in your capability to indicate the \"sub capabilities\". -- Jakob Heitz. Just noticed that two capabilities are defined in the draft. They actually can and should be combined into one, something like: 0 1 2 3 4 5 6 7 +---------------------------------------+ | Version | S R Reserved| +---------------------------------------+ | | | AFI | | | +---------------------------------------+ where S is for sending, and R for receiving. As you know, the number space for the capability code is only one byte. There is no need to waste. [ confeesion: enke, matt, and i discussed this offline and matt and i have asked to push to list ] matt pointed out that, in amsterdam, we went from one cap to two because sra said don't create cases you do not want to handle, namely the above with S=R=0 the suggestion now is that it is worth saving the code point and to just treat that case as if the cap was not received. what do folk think? randy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-HvsCp4BMh9pzP9iBjYsSxDPZ3F8","title":"","text":"Re: [sidr] BGP capability in draft-ietf-sidr-bgpsec-protocol-06\nRandy, I suggest that the case of S=R=0 be treated as if the cap were not received. It's a good deal to save a capability number by a very short sentence! -- Enke Just noticed that two capabilities are defined in the draft. They actually can and should be combined into one, something like: 0 1 2 3 4 5 6 7 +---------------------------------------+ | Version | S R Reserved| +---------------------------------------+ | | | AFI | | | +---------------------------------------+ where S is for sending, and R for receiving. As you know, the number space for the capability code is only one byte. There is no need to waste. [ confeesion: enke, matt, and i discussed this offline and matt and i have asked to push to list ] matt pointed out that, in amsterdam, we went from one cap to two because sra said don't create cases you do not want to handle, namely the above with S=R=0 the suggestion now is that it is worth saving the code point and to just treat that case as if the cap was not received. what do folk think? randy"}
{"_id":"doc-en-sidr-GHCsUGZz1P6yIFML71J7hEl1aoY","title":"","text":"Re: [sidr] BGP capability in draft-ietf-sidr-bgpsec-protocol-06\nJust noticed that two capabilities are defined in the draft. They actually can and should be combined into one, something like: 0 1 2 3 4 5 6 7 +---------------------------------------+ | Version | S R Reserved| +---------------------------------------+ | | | AFI | | | +---------------------------------------+ where S is for sending, and R for receiving. As you know, the number space for the capability code is only one byte. There is no need to waste. [ confeesion: enke, matt, and i discussed this offline and matt and i have asked to push to list ] matt pointed out that, in amsterdam, we went from one cap to two because sra said don't create cases you do not want to handle, namely the above with S=R=0 the suggestion now is that it is worth saving the code point and to just treat that case as if the cap was not received. what do folk think? randy"}
{"_id":"doc-en-sidr-ikc7B8VmqBOLJDSf-rEsOW8hMSc","title":"","text":"[sidr] BGP capability in draft-ietf-sidr-bgpsec-protocol-06\nHi, folks: Just noticed that two capabilities are defined in the draft. They actually can and should be combined into one, something like: 0 1 2 3 4 5 6 7 +---------------------------------------+ | Version | S R Reserved| +---------------------------------------+ | | | AFI | | | +---------------------------------------+ where S is for sending, and R for receiving. As you know, the number space for the capability code is only one byte. There is no need to waste. Thanks. -- Enke"}
{"_id":"doc-en-sidr-X-S_gxWML9Gp6Q9NdUjOwswlaoc","title":"","text":"[sidr] more agenda changes\nPlease be aware that one of our presenters this time is remote, so take extra care to practice good mike and speaking manners. I have uploaded the latest version of the agenda. Please do pay attention to the agenda and make sure everyone is shown there. Slides are coming in and SOME of them are numbered (whee!). One of the requesters of agenda time (the idr error-reporting concern) became ill and left . We'll have to try to open that discussion on the list. I had mistakenly omitted the discussion of the LACNIC conference experience, after I was the one that suggested it! In the idr meeting on Monday, the wg suggested to one of the presenters that they ask for advice from sidr about the proposed work. This is not being suggested as a sidr work item, but the right sort of people to advise are presumed to frequent this group. And finally, there is an overlap between the last hour of sidr and grow. One of the sidr co-chairs is a grow co-chair (yes, grow was on the sidr do-not-conflict list). There are bgp operationally oriented folk in sidr who will likely depart for grow. So I have attempted to compress all the topics into the 9-11, 11:20-12:20 slots. Additional discussion of any particular topic that needs more time can be during the 12:30-13:30 time slot, but with a potentially reduced audience. We have about 40 min reserved for a free-wheeling discussion of the impact of the ARIN relying party agreement. The tools site displays blanks oddly in some browsers. So I am copying the plain text of the agenda below. --Sandy Secure Inter-Domain Routing WG (sidr) IETF 85 - Atlanta, GA, US CHAIR(s): Sandra Murphy Sandra.Murphy at Sparta.com Chris Morrow morrowc at ops-netman.net Alexey Melnikov alexey.melnikov at isode.com ===================================================== FRIDAY, November 9, 2012 0900-1100 Morning Session I 1120-1220 Afternoon Session I 1230-1330 Afternoon Session II Grand Ballroom C AGENDA: Morning Session I 0900-1100 1) Administrivia & Draft status 5 min - Mailing list: http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/index.html - WG Resources: http:\/\/tools.ietf.org\/wg\/sidr\/ - Minute taker? - Jabber Scribe? - Blue Sheets - Agenda Bashing 2) Existing Drafts a) BGPSEC Protocol Specification 25 min draft-ietf-sidr-bgpsec-protocol-06.txt http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-06 Presenter: Matt Lepinski b) Local Trust Anchor Management for the Resource Public Key 10 min Infrastructure draft-ietf-sidr-ltamgmt-07.txt http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-ltamgmt-07 Presenter: Richard Barnes c) BGPSEC router key rollover as an alternative to beaconing 10 min draft-ietf-sidr-bgpsec-rollover-01.txt http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-rollover-01 Presenter: Brian Weis 3) Previous Topics a)Discussion and Analysis of Variants of Key Rollover Method for Replay Protection 10 min draft-sriram-replay-protection-design-discussion-00 http:\/\/tools.ietf.org\/html\/draft-sriram-replay-protection-design-discussion-00 Presenter: Kotikalapudi Sriram b) AS Aliasing 10 min BGPSec Considerations for AS Migration draft-george-sidr-as-migration-00 http:\/\/tools.ietf.org\/html\/draft-george-sidr-as-migration-00 Presenter: Wes George (remotely) c) Multiple Publication Points 10 min Multiple Repository Publication Points support in the Resource Public Key Infrastructure (RPKI) draft-rogaglia-sidr-multiple-publication-points-01 http:\/\/tools.ietf.org\/html\/draft-rogaglia-sidr-multiple-publication-points-01 Presenter: Carlos Martinez d) Policy Qualifier of the CP 10 min Presenter: Andy Newton e) Retrieval\/Validation Separation 10 min Persenter: Tim Bruijnzeels [tim@ripe.net] 4) Real World Experiences a) RPSTIR Validator Testing 10 min Presenter: Andrew Chi b) LACNIC Experiences with Origin Validation 10 min Presenter: Carlos Martinez Afternoon Session I 1120-1220 1) IETF 85 Experiences with Origin Validation 10 min Presenter: Warren Kumari 2) L3VPN 10 min Authenticating L3VPN Origination Signaling draft-ymbk-l3vpn-origination-02 http:\/\/tools.ietf.org\/html\/draft-ymbk-l3vpn-origination-02 Presenter: Arjun Sreekantiah 3) General Discussion of Relying Party Agreement 40 min Presenter: Sandra Murphy Afternoon Session II 1230-1330 <This session overlaps with GROW, so this slot is left for additional discussion of any topic that got cut off in the time slots above, given the possibility that operationally oriented folk might depart for grow>"}
{"_id":"doc-en-sidr-Wb7A-iBKSsvNmOQanpRzfL2Ea18","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-06.txt\nGreetings. I posted a new -06 version of the BGPSEC protocol specification. This includes all of the changes that we discussed at the interim meeting in Amsterdam last month. Note: I took out Additional_Info. It wasn't clear to me whether or not the working group wanted an extension mechanism to enable to originator to add additional signed data. However, it was clear at the interim that the -05 version of Additional_Info wasn't very useful, so I took it out. If the working group decides that we need a mechanism to fill the role of Additional_Info, I am happy to add one back in. As previously mentioned, I would be quite happy to see discussion of this topic on the list. Also, with regards to error handling, it wasn't clear after the interim what was the correct way forward with regards to error handling. I would love to get some Working Group Chair guidance on how best to proceed with error handling. (The -06 version does NOT have a Normative Reference to the IDR error handling draft, is one required?) Finally, I got a bunch of incredibly detailed reviews with lots of helpful fixes. I believe that I have incorporated almost all of the fixes suggested in those reviews. However, there's a good chance that I missed one or two given the volume of small changes that I was making. I plan to go through each of the recent reviews and double-check that I addressed all of the requested changes. If I find that I missed something, I will issue a small -07 update after Atlanta. In any case, I greatly appreciate the detailed reviews. I am pretty certain that I have incorporated all the major fixes, and I apologize if I missed a small fix that you suggested. A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-06.txt Pages : 35 Date : 2012-10-22 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-06 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-06 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-4xX9tfQLTLcTNLHYMaOlNXSK-Ts","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-06.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-06.txt Pages : 35 Date : 2012-10-22 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the path of autonomous systems through which a BGP update message passes. BGPSEC is implemented via a new optional non-transitive BGP path attribute that carries a digital signature produced by each autonomous system that propagates the update message. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-06 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-06 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-x7283tgt8RfYrxLDLgKauMMYRmw","title":"","text":"Re: [sidr] [fixed] Confirming that the last interim reflects working\n group consensus\nOn Thu, Oct 11, 2012 at 2:06 PM, Eric Osterweil <eosterweil@verisign.com> wrote: Chris, I think that you and Sandy mentioned that draft-ietf-sidr-bgpsec-threats and draft-ietf-sidr-bgpsec-threats should be done before draft-ietf-sidr-bgpsec-protocol but it was just by email, I believe. http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05078.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05080.html I was not in the interim, so I do not know if you discussed the issue there again. fwiw, I was at the interim, and I do recall the comment being made. at least I wasn't misremembering. (and the notes were posted by sandy a bit ago) That said (and at the risk of stating the obvious), can we not agree that the protocol draft will almost certainly need changes and\/or an overhaul depending on the scale of the changes that may be coming to the threats and reqs drafts? I'm just thinking that if we are going to continue to pursue those drafts as prerequisites, then iterating over and polishing their derivative work (the protocol draft) now seems like it may yield text that becomes obsoleted by those prerequisites, right? protocol may, indeed, require changes, or not... read threats to make sure it's ok and we can concentrate on the requirements doc now? :) I suppose we'll send a more official 'read the threats doc, kthxbi' today as a reminder. -chris"}
{"_id":"doc-en-sidr-aFaZaGJ9RAeyLQ1O3WV0RFpcjTI","title":"","text":"Re: [sidr] [fixed] Confirming that the last interim reflects working\n group consensus\nChris, I think that you and Sandy mentioned that draft-ietf-sidr-bgpsec-threats and draft-ietf-sidr-bgpsec-threats should be done before draft-ietf-sidr-bgpsec-protocol but it was just by email, I believe. http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05078.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05080.html I was not in the interim, so I do not know if you discussed the issue there again. fwiw, I was at the interim, and I do recall the comment being made. That said (and at the risk of stating the obvious), can we not agree that the protocol draft will almost certainly need changes and\/or an overhaul depending on the scale of the changes that may be coming to the threats and reqs drafts? I'm just thinking that if we are going to continue to pursue those drafts as prerequisites, then iterating over and polishing their derivative work (the protocol draft) now seems like it may yield text that becomes obsoleted by those prerequisites, right? Eric"}
{"_id":"doc-en-sidr-7N86ZPIrrR0siTRppX-Tqr-z0bk","title":"","text":"Re: [sidr] [fixed] Confirming that the last interim reflects working\n group consensus\nChris, I think that you and Sandy mentioned that draft-ietf-sidr-bgpsec-threats and draft-ietf-sidr-bgpsec-threats should be done before draft-ietf-sidr-bgpsec-protocol but it was just by email, I believe. http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05078.html http:\/\/www.ietf.org\/mail-archive\/web\/sidr\/current\/msg05080.html I was not in the interim, so I do not know if you discussed the issue there again. Regards, as On 11\/10\/2012 14:12, Christopher Morrow wrote: On Thu, Oct 11, 2012 at 10:59 AM, Danny McPherson <danny@tcb.net> wrote: i had thought there was agreement at the last interim that threats\/requirements needed to get baked before the protocol doc move to the next step in the process. While I am happy to hear this, it's not clear to me from the proceedings available, can you please provide a pointer? sadly I can't find the notes on the interwebs... I'll see if we\/chairs forgot to post them, or my search-foo with webcrawler is crap. I do note that there's a new revision ('new' as of 9\/14-ish?) of threats: <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-threats> requirements is still june-only: <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-threats> Did you get a chance (I think you had some questions\/comments\/etc outstanding) to review -threats since 9\/14? -chris _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-SIaV9-x24ZEULkdPVMyyYITX7wE","title":"","text":"[sidr] [fixed] Confirming that the last interim reflects working\n group consensus\nNote: My apologies for the previous, incomplete, email. I accidently hit \"Send\" before the message was complete. At the interim meeting in Amsterdam, we had a discussion on open issues in draft-ietf-sidr-bgpsec-protocol-05. Here is a link to the slides that I presented at that meeting. ( http:\/\/www.ietf.org\/proceedings\/interim\/2012\/09\/29\/sidr\/slides\/slides-interim-2012-sidr-6-1.pdf ) I would like to confirm on the list that the discussions at the last interim reflect the consensus of the working group. In this message, I list for each open issue, my understanding of the sense of the room in Amsterdam. If you believe that for any of these issues that I may be misunderstanding the consensus of the working group, please start a discussion on the list as soon as possible. I am currently working on the -06 version of the protocol draft, therefore, if you have an objection to anything in this message, please raise it promptly. -------------------------------- 1.1. In referring to the data that is typically carried in the AS_PATH attribute, I will a phrase similar to \"The sequence of ASes through which an update passes\". 1.2. With regards to transport security, the document will specify \"SHOULD\" use transport security to protect BGP sessions. However, the document will NOT specify (as either a MUST or a SHOULD) and specific transport security mechanism. 1.3. There is no information in the current Editor's Notes that is worth retaining in future versions of the document 2.1. The document will recommend that if there is a failure to negotiate BGPSEC in a session with a peer, the BGP-speaker should fall back to BGP-4 without BGPSEC (instead of closing the session). 2.2. Unless someone comes to the list with a use-case for including SAFI in the BGPSEC capability advertisement, I will remove SAFI from the BGPSEC capability advertisement. 2.3. BGPSEC support and 4-byte ASN support are negotiated separately. However, the document will explicitly state that if 4-byte ASN support is not negotiated, then implementations shall consider BGPSEC to have not been negotiated. 2.4. The document should specify two separate BGP considerations: one for receiving BGPSEC, and one for sending of BGPSEC. 3.1. I will shorten the name of the BGPSEC_PATH_SIGNATURES attribute to BGPSEC_PATH attribute. 3.2. BGPSEC will not put Router_ID on the wire as part of the BGPSEC_PATH attribute. 3.3. My impression of the sense of the room in Amsterdam was that a majority of people were leaning towards removing the Additional_Info field form the BGPSEC_PATH attribute. However, several individuals spoke in favor of improving Additional_Info to be a more general extension mechanism. In the absence of discussion on the list, I will remove Additional_Info. However, I can see both sides of this issues and so I would be happy to see productive discussion of this on the list. 3.4. After discussion at the interim, I believe there is no issue here. I may add another pointer to the ops document if I can find a useful place to do so. 3.5. I will make sure the document is consistent throughout on the the issue of length fields. All length fields will include octets used to express the length itself. 4.1. When originating an update message within an AS. Whenever BGPSEC is negotiated on the i-BGP session, updates sent in this will be sent with a null BGPSEC_PATH attribute instead of a AS_PATH 5.1. I will change the names of the validation states to be \"Valid\" and \"Not Valid\". For now I am going to stay with two validation states. If you have a good use-case for three validation states, please bring it to the list. 5.2. There was no resolution to the issue of error handling at the interim. The options seem to be: (1) Normative reference to 4271; (2) Normative reference to the IDR error-handling draft; or (3) We pick a particular mechanism for error handling such as \"treat as withdrawal\", \"drop session\", or \"drop update\". Note: This is an area where guidance from the chairs would be very useful to the document editor! 5.3. The issue of deferred validation seemed to be a rat hole we want to avoid. The next version of the document will have less text on deferred validation. (In particular phrases like \"as soon as possible\" seem not to be helpful). The working group chairs will help the document authors get some implementer eyes on the -06 version of the document. If we get feedback that there is additional guidance on deferment that would be useful, we can always add something after Atlanta. 5.4. I will shrink the text on edge validation by combining the 2nd and 3rd sentence shown on the slide. In particular, I will avoid the phrase \"MAY be conveyed via iBGP\" and will instead go with something like \"MAY be conveyed via some mechanism\". 5.5. The protocol document will be silent on the issue of using the validation state. This type of issue will be left entirely to the bgpsec-ops document 5.6. I will add text to the document specifying that when RPKI state changes the router will re-run policy on all affected updates. I will look to 4271 to see if I can find any guidance in writing this text on re-evaluation of received updates. 5.7. I believe that a normative reference to rpki-rtr-keys draft. It was not clear to me whether an informative reference to rpki-rtr-keys is needed. However, based on discussion in Amsterdam, it seems that an informative reference to rpki-rtr-keys might be helpful. Note: My apologies for the previous, incomplete, email. I accidently hit \"Send\" before the message was complete. At the interim meeting in Amsterdam, we had a discussion on open issues in draft-ietf-sidr-bgpsec-protocol-05. Here is a link to the slides that I presented at that meeting. (http:\/\/www.ietf.org\/proceedings\/interim\/2012\/09\/29\/sidr\/slides\/slides-interim-2012-sidr-6-1.pdf) I would like to confirm on the list that the discussions at the last interim reflect the consensus of the working group. In this message, I list for each open issue, my understanding of the sense of the room in Amsterdam. If you believe that for any of these issues that I may be misunderstanding the consensus of the working group, please start a discussion on the list as soon as possible. I am currently working on the -06 version of the protocol draft, therefore, if you have an objection to anything in this message, please raise it promptly. -------------------------------- 1.1. In referring to the data that is typically carried in the AS_PATH attribute, I will a phrase similar to \"The sequence of ASes through which an update passes\". 1.2. With regards to transport security, the document will specify \"SHOULD\" use transport security to protect BGP sessions. However, the document will NOT specify (as either a MUST or a SHOULD) and specific transport security mechanism. 1.3. There is no information in the current Editor's Notes that is worth retaining in future versions of the document 2.1. The document will recommend that if there is a failure to negotiate BGPSEC in a session with a peer, the BGP-speaker should fall back to BGP-4 without BGPSEC (instead of closing the session). 2.2. Unless someone comes to the list with a use-case for including SAFI in the BGPSEC capability advertisement, I will remove SAFI from the BGPSEC capability advertisement. 2.3. BGPSEC support and 4-byte ASN support are negotiated separately. However, the document will explicitly state that if 4-byte ASN support is not negotiated, then implementations shall consider BGPSEC to have not been negotiated. 2.4. The document should specify two separate BGP considerations: one for receiving BGPSEC, and one for sending of BGPSEC. 3.1. I will shorten the name of the BGPSEC_PATH_SIGNATURES attribute to BGPSEC_PATH attribute. 3.2. BGPSEC will not put Router_ID on the wire as part of the BGPSEC_PATH attribute. 3.3. My impression of the sense of the room in Amsterdam was that a majority of people were leaning towards removing the Additional_Info field form the BGPSEC_PATH attribute. However, several individuals spoke in favor of improving Additional_Info to be a more general extension mechanism. In the absence of discussion on the list, I will remove Additional_Info. However, I can see both sides of this issues and so I would be happy to see productive discussion of this on the list. 3.4. After discussion at the interim, I believe there is no issue here. I may add another pointer to the ops document if I can find a useful place to do so. 3.5. I will make sure the document is consistent throughout on the the issue of length fields. All length fields will include octets used to express the length itself. 4.1. When originating an update message within an AS. Whenever BGPSEC is negotiated on the i-BGP session, updates sent in this will be sent with a null BGPSEC_PATH attribute instead of a AS_PATH 5.1. I will change the names of the validation states to be \"Valid\" and \"Not Valid\". For now I am going to stay with two validation states. If you have a good use-case for three validation states, please bring it to the list. 5.2. There was no resolution to the issue of error handling at the interim. The options seem to be: (1) Normative reference to 4271; (2) Normative reference to the IDR error-handling draft; or (3) We pick a particular mechanism for error handling such as \"treat as withdrawal\", \"drop session\", or \"drop update\". Note: This is an area where guidance from the chairs would be very useful to the document editor! 5.3. The issue of deferred validation seemed to be a rat hole we want to avoid. The next version of the document will have less text on deferred validation. (In particular phrases like \"as soon as possible\" seem not to be helpful). The working group chairs will help the document authors get some implementer eyes on the -06 version of the document. If we get feedback that there is additional guidance on deferment that would be useful, we can always add something after Atlanta. 5.4. I will shrink the text on edge validation by combining the 2nd and 3rd sentence shown on the slide. In particular, I will avoid the phrase \"MAY be conveyed via iBGP\" and will instead go with something like \"MAY be conveyed via some mechanism\". 5.5. The protocol document will be silent on the issue of using the validation state. This type of issue will be left entirely to the bgpsec-ops document 5.6. I will add text to the document specifying that when RPKI state changes the router will re-run policy on all affected updates. I will look to 4271 to see if I can find any guidance in writing this text on re-evaluation of received updates. 5.7. I believe that a normative reference to rpki-rtr-keys draft. It was not clear to me whether an informative reference to rpki-rtr-keys is needed. However, based on discussion in Amsterdam, it seems that an informative reference to rpki-rtr-keys might be helpful."}
{"_id":"doc-en-sidr-OvfTHvJnfaeMX09SNGKsntw5czM","title":"","text":"[sidr] Confirming that the last interim reflects working group\n concensus\nAt the interim meeting in Amsterdam, we had a discussion on open issues in draft-ietf-sidr-bgpsec-protocol-05. Here is a link to the slides that I presented at that meeting. ( http:\/\/www.ietf.org\/proceedings\/interim\/2012\/09\/29\/sidr\/slides\/slides-interim-2012-sidr-6-1.pdf ) I would like to confirm on the list that the discussions at the last interim reflect the consensus of the working group. In this message, I list for each open issue, my understanding of the sense of the room in Amsterdam. If you believe that for any of these issues that I may be misunderstanding the consensus of the working group, please start a discussion on the list as soon as possible. I am currently working on the -06 version of the protocol draft, therefore, if you have an objection to anything in this message, please raise it promptly. -------------------------------- 1.1. In referring to the data that is typically carried in the AS_PATH attribute, I will a phrase similar to \"The sequence of ASes through which an update passes\" 1.2 With regards to transport security, the document will specify \"SHOULD\" use transport security to protect BGP sessions. However, the document will NOT specify (as either a MUST or a SHOULD) and specific transport security mechanism. At the interim meeting in Amsterdam, we had a discussion on open issues in draft-ietf-sidr-bgpsec-protocol-05.Here is a link to the slides that I presented at that meeting. (http:\/\/www.ietf.org\/proceedings\/interim\/2012\/09\/29\/sidr\/slides\/slides-interim-2012-sidr-6-1.pdf) I would like to confirm on the list that the discussions at the last interim reflect the consensus of the working group. In this message, I list for each open issue, my understanding of the sense of the room in Amsterdam. If you believe that for any of these issues that I may be misunderstanding the consensus of the working group, please start a discussion on the list as soon as possible. I am currently working on the -06 version of the protocol draft, therefore, if you have an objection to anything in this message, please raise it promptly. --------------------------------1.1. In referring to the data that is typically carried in the AS_PATH attribute, I will a phrase similar to \"The sequence of ASes through which an update passes\" 1.2 With regards to transport security, the document will specify \"SHOULD\" use transport security to protect BGP sessions. However, the document will NOT specify (as either a MUST or a SHOULD) and specific transport security mechanism."}
{"_id":"doc-en-sidr-oTasDXirL_2Ehj5GylwydzlGHbI","title":"","text":"Re: [sidr] agenda requests for IETF85\nSandy, I would like a little bit of time to talk about draft-ietf-sidr-bgpsec-protocol to follow-up on the discussion at our interim meeting. - Matt Lepinski On Fri, Oct 5, 2012 at 9:35 AM, Murphy, Sandra <Sandra.Murphy@sparta.com>wrote: If you have a topic that you would like to see discussed at the IETF84 Atlanta meeting, please send a request to the list. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr Sandy,I would like a little bit of time to talk about draft-ietf-sidr-bgpsec-protocol to follow-up on the discussion at our interim meeting. - Matt Lepinski If you have a topic that you would like to see discussed at the IETF84 Atlanta meeting, please send a request to the list. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-9_-dVaoC11TH2BDEvFTV9BUl5FI","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nRob, At Fri, 28 Sep 2012 09:54:01 -0400, Stephen Kent wrote: 4.1. Originating a New BGPSEC Update ... In particular, this AS number MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. \"The\" or \"an\"? Is it legal for the EE certificate to cover more RFC 3779 resources than just a single ASN? yes, an EE cert can contain multiple ASNs, if they were allocated to the cert holder by the same parent. I know that RFC 3779 allows multiple ASNs, having implemented it. :) and I wrote it, so ... What I'm asking is whether it was Matt's intent to restrict BGPSEC to requiring that only a single ASN be certified in the relevant EE certificate. I do not recall any such restriction during earlier discussions of this protocol, which is why I flagged it. OK, that was not clear from you question. 6.1. Algorithm Suite Considerations ... To this end, a mandatory algorithm suites document will be created which specifies a mandatory-to-use 'current' algorithm suite for use by all BGPSEC speakers [12]. Additionally, the document specifies an additional 'new' algorithm suite that is recommended to implement. Badly phrased, unless the real intent here is to say that we're going to pick both the current and next algorithms right off the bat, which seems unlikely to me. I think it would be more correct to say that we will specify an initial mandatory algorithm suite, and, once we have some idea of what the next algorithm should be, we will publish a series of updated documents phasing in the new one and (eventually, years later) phasing out the old one. that would be consistent with the alg migration strategy described in draft-ietf-sidr-algorithm-agility-07 I assume (please correct if wrong) that your comment refers to my suggested rephrasing being consistent with the algorithm migration strategy. yes. Steve"}
{"_id":"doc-en-sidr-oTf8AasXCNuhVHlfE_VuNhJwJa8","title":"","text":"Re: [sidr] Reviews of draft-ietf-sidr-bgpsec-protocol\nOkay, I have now caught up on my incoming mail and I am going to add Rob Austein to my Thank You list. Thanks a lot, Rob, appreciate the review. On Fri, Sep 28, 2012 at 10:06 AM, Matthew Lepinski <mlepinski.ietf@gmail.com wrote: I am going to ignore the process questions related to whether or not \"WGLC\" were appropriate letters in conjunction with draft-ietf-sidr-bgpsec-protocol. Instead, I would like to focus on thanking Sean, Randy, and Sandy for producing incredibly detailed reviews of the protocol document, and I would like to thank Wes for his comments as well. I am currently in the process of going through the reviews and making those changes to the protocol document that are obvious fixes. Additionally, I am collecting the open issues from these reviews that require working group attention. I will present those open issues at the interim meeting tomorrow. Thanks again Okay, I have now caught up on my incoming mail and I am going to add Rob Austein to my Thank You list. Thanks a lot, Rob, appreciate the review. I am going to ignore the process questions related to whether or not \"WGLC\" were appropriate letters in conjunction with draft-ietf-sidr-bgpsec-protocol. Instead, I would like to focus on thanking Sean, Randy, and Sandy for producing incredibly detailed reviews of the protocol document, and I would like to thank Wes for his comments as well. I am currently in the process of going through the reviews and making those changes to the protocol document that are obvious fixes. Additionally, I am collecting the open issues from these reviews that require working group attention. I will present those open issues at the interim meeting tomorrow. Thanks again"}
{"_id":"doc-en-sidr-h8xXWxhMqpW2AG6oj4tzJCVJkPI","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nAt Fri, 28 Sep 2012 09:54:01 -0400, Stephen Kent wrote: 4.1. Originating a New BGPSEC Update ... In particular, this AS number MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. \"The\" or \"an\"? Is it legal for the EE certificate to cover more RFC 3779 resources than just a single ASN? yes, an EE cert can contain multiple ASNs, if they were allocated to the cert holder by the same parent. I know that RFC 3779 allows multiple ASNs, having implemented it. :) What I'm asking is whether it was Matt's intent to restrict BGPSEC to requiring that only a single ASN be certified in the relevant EE certificate. I do not recall any such restriction during earlier discussions of this protocol, which is why I flagged it. 6.1. Algorithm Suite Considerations ... To this end, a mandatory algorithm suites document will be created which specifies a mandatory-to-use 'current' algorithm suite for use by all BGPSEC speakers [12]. Additionally, the document specifies an additional 'new' algorithm suite that is recommended to implement. Badly phrased, unless the real intent here is to say that we're going to pick both the current and next algorithms right off the bat, which seems unlikely to me. I think it would be more correct to say that we will specify an initial mandatory algorithm suite, and, once we have some idea of what the next algorithm should be, we will publish a series of updated documents phasing in the new one and (eventually, years later) phasing out the old one. that would be consistent with the alg migration strategy described in draft-ietf-sidr-algorithm-agility-07 I assume (please correct if wrong) that your comment refers to my suggested rephrasing being consistent with the algorithm migration strategy."}
{"_id":"doc-en-sidr-18HQ0aL0sDttVr93d1Y1VrCJFtE","title":"","text":"[sidr] Reviews of draft-ietf-sidr-bgpsec-protocol\nI am going to ignore the process questions related to whether or not \"WGLC\" were appropriate letters in conjunction with draft-ietf-sidr-bgpsec-protocol. Instead, I would like to focus on thanking Sean, Randy, and Sandy for producing incredibly detailed reviews of the protocol document, and I would like to thank Wes for his comments as well. I am currently in the process of going through the reviews and making those changes to the protocol document that are obvious fixes. Additionally, I am collecting the open issues from these reviews that require working group attention. I will present those open issues at the interim meeting tomorrow. Thanks again I am going to ignore the process questions related to whether or not \"WGLC\" were appropriate letters in conjunction with draft-ietf-sidr-bgpsec-protocol. Instead, I would like to focus on thanking Sean, Randy, and Sandy for producing incredibly detailed reviews of the protocol document, and I would like to thank Wes for his comments as well. I am currently in the process of going through the reviews and making those changes to the protocol document that are obvious fixes. Additionally, I am collecting the open issues from these reviews that require working group attention. I will present those open issues at the interim meeting tomorrow. Thanks again"}
{"_id":"doc-en-sidr-r46f-X0-ssPHvtwXIQ63G8qWxMc","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nRob, A reply to a couple of your comments: 4.1. Originating a New BGPSEC Update ... In particular, this AS number MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. \"The\" or \"an\"? Is it legal for the EE certificate to cover more RFC 3779 resources than just a single ASN? yes, an EE cert can contain multiple ASNs, if they were allocated to the cert holder by the same parent. 6.1. Algorithm Suite Considerations ... To this end, a mandatory algorithm suites document will be created which specifies a mandatory-to-use 'current' algorithm suite for use by all BGPSEC speakers [12]. Additionally, the document specifies an additional 'new' algorithm suite that is recommended to implement. Badly phrased, unless the real intent here is to say that we're going to pick both the current and next algorithms right off the bat, which seems unlikely to me. I think it would be more correct to say that we will specify an initial mandatory algorithm suite, and, once we have some idea of what the next algorithm should be, we will publish a series of updated documents phasing in the new one and (eventually, years later) phasing out the old one. that would be consistent with the alg migration strategy described in draft-ietf-sidr-algorithm-agility-07 Steve"}
{"_id":"doc-en-sidr-L8OyhCFwFmQSxdLWKahqawkj8kg","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nAnother review of draft-ietf-sidr-bgpsec-protocol-05. 1. Introduction ... BGPSEC relies on the Resource Public Key Infrastructure (RPKI) certificates that attest to the allocation of AS number and IP address resources. (For more information on the RPKI, see [6] and the documents referenced therein.) Any BGPSEC speaker who wishes to send BGP update messages to external peers (eBGP) containing the BGPSEC_Path_Signatures must have an RPKI end-entity certificate (as well as the associated private signing key) corresponding to the BGPSEC speaker's AS number. Note, however, that a BGPSEC speaker does not require such a certificate in order to validate update messages containing the BGPSEC_Path_Signatures attribute. The BGPSEC speaker doesn't need the certificate, only the private key. The certificate needs to exist in the RPKI, but unless I'm missing something the BGPSEC speaker need never see its own certificate. 2. BGPSEC Negotiation ... Capability Value: 0 1 2 3 4 5 6 7 +---------------------------------------+ | Send | Receive | Reserved | Version | +---------------------------------------+ | AFI | +---------------------------------------+ | | +---------------------------------------+ | Reserved | +---------------------------------------+ | SAFI | +---------------------------------------+ ... The fifth octet in the capability contains the 8-bit Subsequent Address Family Identifier (SAFI). This value is encoded as in the BGP multiprotocol extensions [2]. Is zero SAFI the same thing as null SAFI? It's not in RFC 3779: an OCTET STRING of length two is not the same as an OCTET STRING of length three with the third octet zeroed. I suspect that presence of SAFI may require a flag bit, unless we are certain that zero SAFI always means the same thing as null SAFI. 3. The BGPSEC_Path_Signatures Attribute ... High-Level Diagram of the BGPSEC_Path_Signatures Attribute BGPSEC_Path_Signatures What's the doubled attribute name supposed to mean? +---------------------------------------------------------+ | +-----------------+ | | | Secure Path | +-----------------+ | | +-----------------+ | Additional Info | | | | AS X | +-----------------+ | | | pCount X | | Info Type | | | | Flags X | | Info Length | | | | AS Y | | Info Value | | | | pCount Y | +-----------------+ | | | Flags Y | | | | ... | | | +-----------------+ | | | | +-----------------+ +-----------------+ | | | Sig Block 1 | | Sig Block 2 | | | +-----------------+ +-----------------+ | | | Alg Suite 1 | | Alg Suite 2 | | | | SKI X | | SKI X | | | | Sig Length X | | Sig Length X | | | | Signature X | | Signature X | | | | SKI Length Y | | SKI Length Y | | | | SKI Y | | SKI Y | | | | Sig Length Y | | Sig Length Y | | | | Signature Y | | Signature Y | | | | ... | | .... | | | +-----------------+ +-----------------+ | | | +---------------------------------------------------------+ I did not find this picture very clear and I thought I knew this protocol. Generally, in diagrams of this type, one does not assume row major ordering of internal boxes. The following is a more detailed explanation of the format of the BGPSEC_Path_Signatures attribute. BGPSEC_Path_Signatures Attribute +-------------------------------------------------------+ | Secure_Path (variable) | +-------------------------------------------------------+ | Additional_Info (variable) | +-------------------------------------------------------+ | Sequence of one or two Signature_Blocks (variable) | +-------------------------------------------------------+ It's not more detailed, but it is clearer, because at least it's obvious how the sections match up with the following text. 3.2. Additional_Info Here we provide a detailed description of the Additional_Info in the BGPSEC_Path_Signatures attribute. Additional_Info +---------------------------------------------+ | Info Type (1 octet) | +---------------------------------------------+ | Info Length (1 octet) | +---------------------------------------------+ | Info Value (variable) | +---------------------------------------------+ The Info Type field is a one-octet value that identifies the type of additional information included in the Info Value field. This specification defines a single (null) type of Additional_Info. The Info Type for this null type is zero. The Info Length field contains the length in octets of the Info Value field. For the (null) Info Type zero specified in this document, the Info Length MUST be zero. The syntax and semantics contained in the Info Value field depends on the type contained in the Info Type field. For the (null) Info Type zero specified in this document, the Info Value field is empty (since the Info Length field must be zero). Implementations compliant with this specification MUST set the Info Type to zero in BGPSEC update messages for route advertisements that they originate (see Section 4.1 for more details). When an implementation compliant with this specification receives a BGPSEC update message with an Info Type field that it does not understand (i.e., an Info Type other than zero), the implementation MUST use the Additional_Info when it verifies digital signatures (as per Section 5.2). However, other than signature verification, the implementation MUST ignore the Info Value field when it does not understand the Info Type. So this is an expansion mechanism, fine, got that. How many of these appear in a message? Looks like exactly one. Not very flexible. We need to include this instead of just going to a new attribute type because? Overall, this extension format looks like it wants to be IPv4 header options when it grows up, but the rest of the formats doom this to being a singleton. Kind of strange. I don't really object, it's just more than a little odd as a placeholder for we-have-no-real-idea-what. 4.1. Originating a New BGPSEC Update ... In particular, this AS number MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. \"The\" or \"an\"? Is it legal for the EE certificate to cover more RFC 3779 resources than just a single ASN? 4.2. Propagating a Route Advertisement ... The BGPSEC speaker next copies the Additional_Info portion of the BGPSEC_Path_Signatures directly from the received update message to the new update message (that it is constructing). Note that the BGPSEC speaker MUST NOT change the Additional_Info as any change to Additional_Info will cause the new BGPSEC update message to fail validation (see Section 5). So Additional_Info is generated only by the originator. It would have been kind to mention this earlier in the document. If the received BGPSEC update message contains two Signature_ Blocks and the BGPSEC speaker supports both of the corresponding algorithms suites, then the new update message generated by the BGPSEC speaker SHOULD include both of the Signature_Blocks. If the received BGPSEC update message contains two Signature_Blocks and the BGPSEC speaker only supports one of the two corresponding algorithm suites, then the BGPSEC speaker MUST remove the Signature_Block corresponding to the algorithm suite that it does not understand. If the BGPSEC speaker does not support the algorithm suites in any of the Signature_Blocks contained in the received update message, then the BGPSEC speaker MUST NOT propagate the route advertisement with the BGPSEC_Path_Signatures attribute (i.e., propagate it as an unsigned BGP update message). Parenthetical phrase says opposite of what I suspect it was intended to mean. I suspect you meant something like: \"(i.e., if it chooses to propagate this route advertisement at all, it MUST do so as an unsigned BGP update message)\". 4.3. Processing Instructions for Confederation Members ... When a confederation member receives a BGPSEC update message from a peer within the confederation and propagates it to a peer outside the confederation, it must remove all of the Secure_Path Segments added by confederation members as well as the corresponding Signature Segments. To do this, the confederation member propagating the route outside the confederation does the following: o First, starting with the least recently added Secure_Path segments, remove all of the consecutive Secure_Path segments that have the Confed_Segment flag set to one. Stop this process once a Scure_Path segment is reached which has its Confed_Segment flag set to zero. Keep a count of the number of segments removed in this fashion. o Second, starting with the most recently added Signature Segment, remove a number of Signature Segments equal to the number of Secure_Path Segments removed in the previous step. (That is, remove the K most recently added signature segments, where K is the number of Secure_Path Segments removed in the previous step.) Is \"least recently added\" in first bullet item a mistake? Sure looks like one. If not, this seriously violates the Principal of Least Astonishment, so the text needs a coherent explanation of why we remove the least recent Secure_Path segments and the most recent Signature Segments. More generally, it would be nice if the document were clearer on the circumstances under which there would ever be two or more blocks of segments with the Confed_Segment flag turned on. My guess is that this should never happen, but, if so, the above description is an awfully compled way of saying \"strip out every Secure_Path segment with the Confed_segment flag turned on, along with the corresponding signature_segments.\" 5. Processing a Received BGPSEC Update ... Implementations that support such deferment of validation MUST perform validation of these messages as soon as possible (i.e., as soon as resources are available to perform validation) and MUST re- run best path selection once the validation status of such update messages is known. Is it OK to do this incrementally if the implementation so desires, or must the implementation only do this after catching up completely? If the latter, what should the implementation do if the flood continues and the implementation doubts it will ever catch up? 5.2. Validation Algorithm This section specifies an algorithm for validation of BGPSEC update messages. A conformant implementation MUST include a BGPSEC update validation algorithm that is functionally equivalent to the external behavior of this algorithm. s\/external\/externally visible\/ If there are two Signature_Blocks within the BGPSEC_Path_Signatures attribute and one of them is poorly formed (or contains the wrong number of Signature segments) , then the recipient should log that an error occurred, strip off that particular Signature_Block and process the update message as though it arrived with a single Signature_Block. If the BGPSEC_Path_Signatures attribute contains an error that is not local to one of two Signature_Blocks, then the recipient should log that an error occurred and drop the update message containing the error. (In particular, if any of checks 3-5 above fail, the recipient should log that an error occurred and drop the update message containing the error.) Do routers \"log that an error occurred\"? Does incrementing a MIB variable count? What's the expected load from this logging? What bad thing (if any) happens if this logging is dropped or ignored? signature is invalid, then mark the entire Signature-List Block as 'Not Good' and proceed to the next Signature_Block. If the signature validation algorithm determines that the signature is valid, then continue processing Signature-Segments (within the current Signature-List Block). What's a \"Signature-List Block\"? Never defined. If all Signature-Segments within a Signature-List Block pass validation (i.e., all segments are processed and the Signature-List Block has not yet been marked 'Not Good'), then the Signature_Block is marked as 'Good'. What's a \"Signature-Segment\"? Never defined. If at least one Signature_Block is marked as 'Good', then the validation algorithm terminates and the BGPSEC update message is deemed to be 'Good'. (That is, if a BGPSEC update message contains two Signature_Blocks then the update message is deemed 'Good' if the first Signature_Block is marked 'Good' OR the second Signature_Block is marked 'Good'.) I think this is saying that the validation algorithm requires that there exist a complete valid chain for some single algorithm, ie, that one cannot construct a valid chain by hopping between algorithms in the middle of the chain. This makes sense, since otherwise the signature chaining won't work. Might want to say so. 6.1. Algorithm Suite Considerations ... To this end, a mandatory algorithm suites document will be created which specifies a mandatory-to-use 'current' algorithm suite for use by all BGPSEC speakers [12]. Additionally, the document specifies an additional 'new' algorithm suite that is recommended to implement. Badly phrased, unless the real intent here is to say that we're going to pick both the current and next algorithms right off the bat, which seems unlikely to me. I think it would be more correct to say that we will specify an initial mandatory algorithm suite, and, once we have some idea of what the next algorithm should be, we will publish a series of updated documents phasing in the new one and (eventually, years later) phasing out the old one. It is anticipated By whom? Once the transition has successfully been completed in this manner, BGPSEC speakers SHOULD include only a single Signature_Block (corresponding to the 'new' algorithm). So we're going to start out with only one, right? 6.2. Extensibility Considerations ... At this point a transition would begin which is analogous to the algorithm transition discussed in Section 6.2. Specifying section numbers manually instead of using <xref\/>, are we? 7. Security Considerations ... (It should be noted that BGPSEC does not offer a precise guarantee that the data packets would propagate along the indicated path; it only guarantees that the BGP update conveying the path indeed propagated along the indicated path.) \"Precise guarantee\", hell. It provides no guarantee of any kind on this point. AFAIK nobody knows how to do that (yet)."}
{"_id":"doc-en-sidr-GE-uzSGlcxCQgkUOL3SN8HCUBmE","title":"","text":"[sidr] comments on draft-ietf-sidr-bgpsec-protocol\nHere are my comments on the protocol draft. These are long. Many are editorial, but not all. I have put in the page number for each piece of text I'm commenting on to help find the right text. Quotes from the text are right shifted as they are in the doc, my comments are left justified and surrounded by **** comment **** --Sandy IDnits reports 4 errors. - There's no IANA considerations section, which is a required section. - Two normative downrefs. - No separation of references into normative vs informative. (Fixing this might fix the downrefs.) \"least recently added\", \"most recently added\", \"next most recently added\", \"n order from most recently added to least recently added\", \"a current Secure_Path Segment that has the Confed_Segment flag set to zero, if the next most recently added Secure_Path segment\" -- there must be a reason why you decided not to use a subscripted naming scheme. It may be just me, but I think subscripts work. There are places where \"should\" is used, which do not seem to be \"SHOULD\". But it would be good for one pass to make sure. Purists say that SHOULD should (:-)) be accompanied by an explanation of legitimate reasons why you might not. Secure_Path Segment vs Secure_Path segment. Similarly consistency in underscores and hyphens (least-recently) etc. AS Number vs AS number. Where do we put the discussion that a change in RPKI state should cause re-run of the decision process? I think somewhere we need an overarching statement that in receiving updates that do not contain the bgpsec attribute and in propagating those non-bgpsec updates, the implementation behaves exactly as is specified in 4271. for a message with bgpsec attribute: bgpsec speaker -> bgpsec speaker: SHOULD add attribute, MAY remove block MAY remove attribute bgpsec seaker -> non-bgpsec speaker: MUST remove bgpsec attribute, MUST add AS_PATH for a message with no bpgsec attribute (and therefore an AS_PATH): bgpsec speaker --> bgpsec speaker : MUST NOT add bgpsec attribute bgpsec speaker --> non-bgpsec speaker: MUST NOT add bgpsec attribute, MUST continue normal AS_PATH construction page 3 2. Every AS listed in the AS_Path attribute of the update explicitly authorized the advertisement of the route to the subsequent AS in the AS_Path. *** The AS_PATH is gone, so maybe you mean the list of ASs that appear in the bgpsec attribute *** Any BGPSEC speaker who wishes to send BGP update messages to external peers (eBGP) containing the BGPSEC_Path_Signatures must have an RPKI end-entity certificate (as well as the associated private signing key) corresponding to the BGPSEC speaker's AS number. *** wrt \"must have\" There must exist such a EE cert, but the router may not need to have possession on-box of that cert. If the AS is using the same keys on all routers, then maybe the router needs the common AS wide cert (verifying signatures generated at confed boundaries, maybe?) but if there are per-router keys then the router need not hold its own cert on-box. I'd say the router definitely needs to have possession of its own private key (as long as you allow an off-box crypto engine as incorporated into the \"router\" by reference) Right? *** Note, however, that a BGPSEC speaker does not require such a certificate in order to validate update messages containing the BGPSEC_Path_Signatures attribute. *** Kinda my point above. Quibbling about the \"such a cert\" words - the bgp speaker requires lots of such certificates to provide keys that validate signatures. It does not validate signatures that it has created itself, it is validating signatures created by other bgp speakers. *** Page 4 If version 0 is the only version of BGPSEC for which both peers (in a BGP session) advertise support, then the use of BGPSEC has been negotiated and the BGPSEC peers MUST adhere to the specification of BGPSEC provided in this document. (If there are multiple versions of BGPSEC which are supported by both peers, then the behavior of those peers is outside the scope of this document.) *** Do we need to add \"Any future specification of a version other than 0 MUST specify the behavior of bgp speakers who support multiple versions and how they determine the version to use to communicate. *** Page 5 Note that if the BGPSEC speaker wishes to use BGPSEC with two different address families (i.e., IPv4 and IPv6) over the same BGP session, then the speaker must include two instances of this capability (one for each address family) in the BGP OPEN message. A BGPSEC speaker SHOULD NOT advertise the capability of BGPSEC support for any <AFI, SAFI> combination unless it has also advertises the ^^^^^^^^^^ advertised multiprotocol extension capability for the same <AFI, SAFI> combination [2]. By indicating support for receiving BGPSEC update messages, a BGP speaker is, in particular, indicating that the following are true: o The BGP speaker understands the BGPSEC_Path_Signatures attribute (see Section 3). o The BGP speaker supports 4-byte AS numbers (see RFC 4893). *** So what if the \"Support for 4-octet AS number capability\" capability is not also negotiated at the same time? Then what? Does negotiating this capability mean you do not need to negotiate the 4byte capability? *** Note that BGPSEC update messages can be quite large, therefore any BGPSEC speaker announcing the capability to receive BGPSEC messages SHOULD also announce support for the capability to receive BGP extended messages [9]. *** So what if the extended msg capability is not negotiated at the same time? Then what? Etc. *** A BGP speaker MUST NOT send an update message containing the BGPSEC_Path_Signatures attribute within a given BGP session unless both of the following are true: o The BGP speaker indicated support for sending BGPSEC update messages in its open message. o The peer of the BGP speaker indicated support for receiving BGPSEC update messages in its open message. *** If both these statements are true, is sending a bgpsec attribute a MUST? SHOULD? MAY? [expect answer is SHOULD] Maybe there needs to be a caveat about \"only where this spec allows addition of the bgpsec attribute\". *** Page 6 The BGPSEC_Path_Signatures attribute is a new optional (non- transitive) BGP path attribute. *** ibgp speakers will drop this if they are non-bgpsec-aware, which if I have things correct means that route reflectors better be upgraded early on. The bgpsec ops doc says that. Perhaps a ref to that doc? if one edge router is not bgpsec aware, it might make inconsistent decisions. I think. Is this a problem? Or a reason why we should be doing the validation-signalling draft? *** This document registers a new attribute type code for this attribute : TBD The BGPSEC_Path_Signatures algorithm carries the secured AS Path information, including the digital signatures that protect this AS Path information. We refer to those update messages that contain the BGPSEC_Path_Signatures attribute as \"BGPSEC Update messages\". The BGPSEC_Path_Signatures attribute replaces the AS_PATH attribute, in a BGPSEC update message. That is, update messages that contain the BGPSEC_Path_Signatures attribute MUST NOT contain the AS_PATH attribute. *** On a personal note, I like to think of the bgpsec attribute as \"encapsulating\" the AS_PATH. A quibble about terms, but \"encapsulate\" for me captures the idea that it contains the same AS list as the AS_PATH in another form, so loop checking still works, and AS_PATH length can still be computed, etc. *** Page 7 High-Level Diagram of the BGPSEC_Path_Signatures Attribute BGPSEC_Path_Signatures +---------------------------------------------------------+ | +-----------------+ | | | Secure Path | +-----------------+ | | +-----------------+ | Additional Info | | | | AS X | +-----------------+ | | | pCount X | | Info Type | | | | Flags X | | Info Length | | | | AS Y | | Info Value | | | | pCount Y | +-----------------+ | | | Flags Y | | | | ... | | | +-----------------+ | | | | +-----------------+ +-----------------+ | | | Sig Block 1 | | Sig Block 2 | | | +-----------------+ +-----------------+ | | | Alg Suite 1 | | Alg Suite 2 | | *** The Signature_Block picture on page 11 says that there is a Signature_Block Length field here *** | | SKI X | | SKI X | | | | Sig Length X | | Sig Length X | | | | Signature X | | Signature X | | | | SKI Length Y | | SKI Length Y | | *** why is this SKI Length not included for X as well? (figure this is an editing error) *** | | SKI Y | | SKI Y | | | | Sig Length Y | | Sig Length Y | | | | Signature Y | | Signature Y | | | | ... | | .... | | | +-----------------+ +-----------------+ | | | +---------------------------------------------------------+ Page 8 be contained in the AS_PATH attribute. A BGPSEC update message containing the BGPSEC_PATH_SIGNATURES attribute MUST NOT contain the AS_PATH attribute. The path information is used by BGPSEC speakers in the same way that information from the AS_PATH is used by non- BGPSEC speakers. The format of the Secure_Path is described below in Section 3.1. *** \"path information\" meaning the list of ASs that appear in the list of secure_path segments. I think. This needs to be more precise. in cases where current bgp code refers to the AS_PATH (as in read access), the code can refer to the as_path extracted from the bgpsec signature attributes iaw section xyz. in cases where current bgp speakers add ASs to the AS_PATH, the code should be adding bgpsec signature attributes. *** *** curiousity here: do current bgp implemenations ensure that you *ONLY* add the local ASN on external sessions? *** Note that this means the Secure_Path Length is six times the number Secure_Path ^of Segments (i.e., the number of AS numbers in the path). Page 9 *** Is it Secure_Path segment or Secure_Path Segment? (case consistency) **** Page 10 Page 11 Here we provide a detailed description of the Signature_Blocks in the ^^^^^^^^^^^^^^^^ Signature_Block Page 12 Signature Segments +---------------------------------------------+ | Subject Key Identifier (20 octets) | +---------------------------------------------+ | Signature Length (2 octets) | +---------------------------------------------+ | Signature (variable) | +---------------------------------------------+ *** Page 7 has an SKI length, but as I said there I think that was a remnant from editing. *** 4. Generating a BGPSEC Update *** I think somewhere we need an overarching statement that in receiving updates that do not contain the bgpsec attribute and in propagating those non-bgpsec updates, the implementation behaves exactly as is specified in 4271. *** Page 13 Note that in order to create or add a new signature to a BGPSEC update message with a given algorithm suite, the BGPSEC speaker must possess a private key suitable for generating signatures for this algorithm suite. Additionally, this private key must correspond to the public key in a valid Resource PKI end-entity certificate whose AS number resource extension includes the BGPSEC speaker's AS number [11]. Note also that new signatures are only added to a BGPSEC update message when a BGPSEC speaker is generating an update message to send to an external peer (i.e., when the AS number of the peer is not equal to the BGPSEC speaker's own AS number). *** I think that this restriction has not been previously mentioned. There is previous text that talks about adding signatures when sending to an external peer, but not the constraint that this is the *ONLY* case when the bgpsec attribute is added Note also. In the AS aliasing case, the peer may be in the same AS in some sense, but have a different ASN. We will have to pay careful attention to Wes\/Shane's description of the aliasing case. *** 4.1. Originating a New BGPSEC Update *** See comment on page 17 about what happens when an internal bgpsec speaker originates a route to a network. *** In an update message that originates a new route advertisement (i.e., an update whose path will contain only a single AS number), when *** path -> Secure Path *** First, the BGPSEC speaker constructs the Secure_Path with a single Secure_Path Segment. The AS in this path is the BGPSEC speaker's own AS number. In particular, this AS number MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. *** \"will be used\" - this is not a action constraint on the protocol, but more an operational or configuration problem. That is, how does the sender know what the recipient will use? A: by putting the AS in the field. That's circular. This should be a note to operators - make sure there's a RPKI cert for the AS you are configuring for the implementation *** Page 14 If the BGPSEC speaker is not a member of an autonomous system confederation [3], then the Flags field of the Secure_Path Segment MUST be set to zero. (Members of a confederation should follow the special processing instructions for confederation members in Section 4.4.) *** It is not just that the speaker is in some confederation. I think the flag is set to 1 if you and your neighbor are in the same confederation. I don't think this text says that. I think phrasing it as \"when speaker and neighbor are in same confed, then 1, else 0\" might be easier phrasing. *** The BGPSEC speaker next constructs the Additional_Info portion of the BGPSEC_Path_Signatures attribute. The Info Type MUST be set to zero and the Info Length MUST also be set to zero. The Info Value field is empty (has length zero). It is anticipated that future specifications may specify values of Info Type other than zero. Therefore, BGPSEC receivers compliant with this specification must be able to accept Additional_Info fields with non-zero Info Type. Such receivers will use the Additional_Field to verify digital signatures (see Section 5) but will otherwise ignore Additional_Field non-zero Info Fields. *** Is it OK if people use the A.I. field to trnasmit info to people who know what to do with it? (we just created a covert channel? can't come up with a reason why that is bad, just curious.) *** Page 15 The Subject Key Identifier field (see Section 3) is populated with the identifier contained in the Subject Key Identifier extension of the RPKI end-entity certificate used by the BGPSEC speaker. This Subject Key Identifier will be used by recipients of the route advertisement to identify the proper certificate to use in verifying the signature. *** I don't think that \"used by the BGPSEC speaker\" is quite right. You mean something like \"corresponding to\" or something vague like that. *** Page 16 If a BGPSEC router has received only non-BGPSEC update messages (without the BGPSEC_Path_Signatures attribute), containing the AS_Path attribute, from a peer for a given prefix and if it chooses to propagate that peer's route for the prefix, then it MUST NOT attach any BGPSEC_Path_Signatures attribute to the corresponding update being propagated. *** I think this is the case whenever the path you choose to propagate has no bgpsec attribute, whether or not *all* the paths you have received have no bgpsec attribute. I think this is just a wording issue, but people should be sure. Verify: we DO NOT mandate that you choose and propagate a non-bgpsec message only if you have received NO bgpsec messages. *** (Note that a BGPSEC router may also receive Page 17 a non-BGPSEC update message from an internal peer without the AS_Path attribute, i.e., with just the NLRI in it. In that case, the prefix is originating from that AS and hence the BGPSEC speaker SHOULD sign and forward the update to its external peers, as specified in Section 4.1.) *** First: the AS_PATH is empty, not missing. Second, when an edge router receives a route from an internal peer when the nlri is originated internally, the update will contain an as-path that is empty if the internal originator is a non-bgpsec speaker. Yep. What if the originator is a bgpsec speaker? What does an internal originator do when originating a route? no bgpsec attribute at all? an empty bgpsec attribute? Empty attribute emulates the behavior in the as_path case but the as_path is mandatory so they have to include it. No bgpsec attribute follows the rule that the attribute is not added over internal sessions, is only added on the edge. But means lots of special cases for the as_path extraction and tools that need to know that no attribute and no as_path means a bgpsec message. Etc. *** Conversely, if a BGPSEC router has received a BGPSEC update message (with the BGPSEC_Path_Signatures attribute) from a peer for a given prefix and it chooses to propagate that peer's route for the prefix, then it SHOULD propagate the route as a BGPSEC update message containing the BGPSEC_Path_Signatures attribute. *** propagate to all neighbors who have negotiated the bgpsec attribute *** However, the BGPSEC speaker MAY propagate the route as a (unsigned) BGP update message without the BGPSEC_Path_Signatures attribute. Note that removing BGPSEC signatures (i.e., propagating a route advertisement without the BGPSEC_Path_Signatures attribute) has significant security ramifications. (See Section 7 for discussion of the security ramifications of removing BGPSEC signatures.) Therefore, when a route advertisement is received via a BGPSEC update message, propagating the route advertisement without the BGPSEC_Path_Signatures attribute is NOT RECOMMENDED. *** propagating to a neighbor how has neogiated the bgpsec attribut *** To generate the BGPSEC_Path_Signatures attribute on the outgoing update message, the BGPSEC speaker first prepends a new Secure_Path Segment (places in first position) to the Secure_Path. The AS number in this Secure_Path segment MUST match the AS number in the AS number resource extension field of the Resource PKI end-entity certificate(s) that will be used to verify the digital signature(s) constructed by this BGPSEC speaker. *** Again, this is an operational comment, not a protocol behavior. There must exist a cert corresponding to the private key *** The pCount is typically set to the value 1. A BGPSEC speaker may set the pCount field to a value greater than 1. (See Section 4.1 for a discussion of setting pCount to a value greater than 1.) A route server that participates in the BGP control path, but does not act as Page 18 a transit AS in the data plane, may choose to set pCount to 0. This option enables the route server to participate in BGPSEC and obtain the associated security guarantees without increasing the effective length of the AS path. *** We are now considering the use of pcount=0 to allow for as aliasing. We don't know yet if that will be effective (see Wes George's recent draft). But who knows there might be others. It might be good to say There might be operational need that would be met by employing a pcount value of 0. One example is route servers. *** (Note that BGPSEC speakers compute the effective length of the AS path by summing the pCount values in the BGPSEC_Path_Signatures attribute, see Section 5.) However, when a route server sets the pCount value to 0, it still inserts its AS number into the Secure_Path segment, as this information is needed to validate the signature added by the route server. Note that the option of setting pCount to 0 is intended only for use by route servers that desire not to increase the effective AS-PATH length of routes they advertise. The pCount field SHOULD NOT be set to 0 in other circumstances. *** as aliasing is a possible other use. whether or not that works out, putting this statement here seems inadvisable. *** BGPSEC speakers SHOULD drop incoming update messages with pCount set to zero in cases where the BGPSEC speaker does not expect its peer to set pCount to zero (i.e., cases where the peer is not acting as a route server). *** Again, we might not end up limiting the use to route servers, so... *** Page 19 corresponding Signature_Block) that is deemed 'Good'. This means that a 'Good' BGPSEC update message may contain a Signature_Block which is not deemed 'Good' (e.g., contains signatures that the BGPSEC does not successfully verify). Nonetheless, such Signature_Blocks MUST NOT be removed. (See Section 7 for a discussion of the security ramifications of this design choice.) *** There is only a SHOULD NOT for removing the signatures in total when they invalidate. So why this MUST NOT for when just one algorithm fails? Is it a worse security concern? *** Page 20 Sequence of Octets to be Signed +--------------------------------------+ | Target AS Number (4 octets) | +--------------------------------------+ | Signer's AS Number (4 octets) | ---\\ +--------------------------------------+ \\ | pCount (1 octet) | > Secure_Path +--------- ----------------------------+ \/ | Flags (1 octet) | ---\/ +--------------------------------------+ | Most Recent Sig Field (variable) | +--------------------------------------+ *** This is a Secure_Path *Segment*, I think. *** Within a confederation, the verification of BGPSEC signatures added by other members of the confederation is optional. If a *** Isn't verification always optional? *** Page 21 message to a peer that is a member of the same confederation, the confederation MAY set the Signature field within the Signature_Segment that it generates to be zero (in lieu of calculating the correct digital signature as described in Sections 4.1 and 4.2). Note that if a confederation chooses not to verify digital signatures within the confederation, then BGPSEC is able to provide no assurances about the integrity of the (private) Member-AS Numbers placed in Secure_Path segments where the Confed_Segment flag is set to one. *** Should there be a security considerations discussion of this? *** When a confederation member receives a BGPSEC update message from a peer within the confederation and propagates it to a peer outside the confederation, it must remove all of the Secure_Path Segments added by confederation members as well as the corresponding Signature Segments. To do this, the confederation member propagating the route outside the confederation does the following: o First, starting with the least recently added Secure_Path segments, remove all of the consecutive Secure_Path segments that have the Confed_Segment flag set to one. Stop this process once a Scure_Path segment is reached which has its Confed_Segment flag set to zero. Keep a count of the number of segments removed in this fashion. *** Why does this start with the least recently added segment? Isn't that the origin segment? (Oh, for an indexed name!) *** o Second, starting with the most recently added Signature Segment, remove a number of Signature Segments equal to the number of Secure_Path Segments removed in the previous step. (That is, remove the K most recently added signature segments, where K is the number of Secure_Path Segments removed in the previous step.) *** Why two passes through the bgpsec attribute? Why not a loop that looks at the secure_path segment list and signature_block segment list in lock step? And break the loop when you hit flag(i)=0? They are completely synchronous aren't they? *** o Finally, add a Secure_Path Segment containing, in the AS field, the AS Confederation Identifier (the public AS number of the confederation) as well as a corresponding Signature Segment. Note that all fields other that the AS field are populated as per Sections 4.1 and 4.2. When validating a received BGPSEC update message, confederation members must make the following adjustment to the algorithm presented in Section 5.2. When a confederation member processes (validates) a Signature Segment and its corresponding Secure_Path Segment, the confederation member must note that for a signature produced by a BGPSEC speaker outside of a confederation, the Target AS will always be the AS Confederation Identifier (the public AS number of the confederation) as opposed to the Member-AS Number. *** This should be mentioned in the validation section. As well as here or instead of here. (both places or only there) *** To handle this case, when a BGPSEC speaker (that is a confederation member) processes a current Secure_Path Segment that has the Confed_Segment flag set to zero, if the next most recently added Page 22 Secure_Path segment has the Confed_Segment flag set to one then, when computing the digest for the current Secure_Path segment, the BGPSEC speaker takes the Target AS Number to be the AS Confederation Identifier of the validating BGPSEC speaker's own confederation. (Note that the algorithm in Section 5.2 processes Secure_Path Segments in order from most recently added to least recently added, therefore this special case will apply to the first Secure_Path segment that the algorithm encounters that has the Confed_Segment flag set to one.) *** Don't you mean \"flag set to zero\" in that last line? I can't claim to have followed the order here, so I could be wrong. *** (Such an error is treated in exactly the same way as receipt of a non-BGPSEC update message containing an AS_CONFED_SEQUENCE from a peer that is not a member of the same AS confederation.) *** See section 5 of rfc 5064, but that refers to 4271 section 6.3. That would send a Notification that breaks the session. Not what we want, I think. And there's a work going on in idr right now that is reviewing the whole subject of how bgp does error handling. But we do want to modify the behavior of 6.3, which mandates an error if a mandatory attribute is not present (like, oh, AS_PATH). *** Page 23 5. Processing a Received BGPSEC Update Upon receiving a BGPSEC update message from an external (eBGP) peer, a BGPSEC speaker SHOULD validate the message to determine the authenticity of the AS PATH information contained in the Page 24 BGPSEC_Path_Signatures attribute. Section 5.1 provides an overview of BGPSEC validation and Section 5.2 provides a specific algorithm for performing such validation. (Note that an implementation need not follow the specific algorithm in Section 5.2 as long as the input output behavior of the validation is identical to that of the *** input output -> \"input and output\"? \"input\/output\"? *** BGPSEC_Path_Signatures attribute. Whenever the use of AS path information is called for (e.g., loop detection, or use of AS path length in best path selection) the externally visible behavior of the ^, implementation shall be the same as if the implementation had run the algorithm in Section 4.4 and used the resulting AS_PATH attribute as it would for a non-BGPSEC update message. However, in practice, it is expected that most implementations will not actually run the algorithm from Section 4.4, and will instead transform the BGPSEC_Path_Signatures attribute directly into some internal representation of AS path. *** I'm not sure the \"However\" sentence is necessary. We do intend for the implementation to follow 4.4, whether they end up with an actual AS_PATH attribute or some internal representation of the same, right? Or maybe you are trying to distinguish running the 4.4 algorithm for each use vs run once and store the result? Aren't implementers already accustomed to using their internal representation for any structure mentioned in a specification? *** Page 25 between two update messages then the two updates are not duplicates. With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different). If the first update message is not valid, then an implementation SHOULD run the validation procedure on the second duplicate update message (as the signatures in the second update may be valid even though the first contained a signature that was invalid). *** Why is the converse not also true? Could RPKI state change not just as well make the second validation result differ from the first -- the first update signature looked valid but now the signature looks invalid? *** 5.1. Overview of BGPSEC Validation Validation of a BGPSEC update messages makes use of data from RPKI certificates and signed Route Origination Authorizations (ROA). In particular, to validate update messages containing the BGPSEC_Path_Signatures attribute, it is necessary that the recipient have access to the following data obtained from valid RPKI certificates and ROAs: o For each valid RPKI end-entity certificate containing an AS Number extension, the AS Number, Public Key and Subject Key Identifier are required, *** \"containing an AS number extension\" -> that's a way to refer to router certs, right? Perhaps we can name them? Needs a reference to the router certs I-D. *** policy mechanisms. It is expected that BGP peers will generally prefer routes received via 'Good' BGPSEC update messages over routes received via 'Not Good' BGPSEC update messages as well as routes received via update messages that do not contain the BGPSEC_Path_Signatures attribute. However, BGPSEC specifies no *** The \"as well as\" confuses me. I think you mean \"prefer ... Good ... over ... Not Good ... and over ... non-bgpsec\". But I had to think about that. *** Page 26 changes to the BGP decision process and leaves to the operator the selection of an appropriate policy mechanism to achieve the operator's desired results within the BGP decision process. BGPSEC validation needs only be performed at eBGP edge. The ^need only be? (admit I'm not sure) validation status of a BGP signed\/unsigned update MAY be conveyed via bgpsec\/non-bgpsec iBGP from an ingress edge router to an egress edge router. Local policy in the AS determines the specific means for conveying the validation status through various pre-existing mechanisms (e.g., modifying an attribute). As discussed in Section 4, when a BGPSEC *** did you mean \"community\" rather than \"attribute\"? isn't every mechanism modifying some attribute? *** 5.2. Validation Algorithm Some of this looks like syntax checking, not really validation. Do the syntac checks need to be separated, or is all one task? Page 27 Signature_Block. If the BGPSEC_Path_Signatures attribute contains an error that is not local to one of two Signature_Blocks, then the ^the recipient should log that an error occurred and drop the update message containing the error. (In particular, if any of checks 3-5 above fail, the recipient should log that an error occurred and drop the update message containing the error.) *** Is it not the case that if 1 or 2 fail, the error should be logged and the update dropped? If so, why this comment? If not, why not? *** Next, the BGPSEC speaker verifies that the origin AS is authorized to advertise the prefix in question. To do this, consult the valid ROA data to obtain a list of AS numbers that are associated with the given IP address prefix in the update message. Then locate the last (least recently added) AS number in the Secure_Path portion of the BGPSEC_Path_Signatures attribute. If the origin AS in the Secure_Path is not in the set of AS numbers associated with the given prefix, then the BGPSEC update message is 'Not Good' and the validation algorithm terminates. *** To answer those who are confused by the origin validation having three states and bgpsec having two, should a note be put here that bgpsec messages will only allow origins that are \"Valid\" and not origins that are \"Unkown\"? So in bgpsec, the \"unknown\" origins get lumped in with the \"invalid\" origins into the \"Not Good\" category? *** Finally, the BGPSEC speaker examines the Signature_Blocks in the BGPSEC_Path_Signatures attribute. A Signature_Block corresponding to an algorithm suite that the BGPSEC speaker does not support is not considered in validation. If there does not exist a Signature_Block corresponding to an algorithm suite that the BGPSEC speaker supports, then the BGPSEC speaker MUST treat the update message in the same manner that the BGPSEC speaker would treat an (unsigned) update message that arrived without a BGPSEC_Path_Signatures attribute. *** I thought that sig blocks for unrecognized sig algs were dropped, not just ignored in validation. *** Page 28 Sequence of Octets to be Hashed +-------------------------------------------+ | AS Number of Target AS (4 octets) | +-------------------------------------------+ | AS Number (4 octets) | ---\\ +-------------------------------------------+ \\ | pCount (1 octet) | > Secure_Path +-------------------------------------------+ \/ | Flags (1 octet) | ---\/ +-------------------------------------------+ | Sig Field in the Next Segment (variable) | +-------------- ----------------------------+ *** Think this is supposed to be Secure_Path Segment This happens other places as well, I'm not going to note it everywhere *** Page 29 Page 30 signature is invalid, then mark the entire Signature-List Block as 'Not Good' and proceed to the next Signature_Block. If the signature validation algorithm determines that the signature is valid, then continue processing Signature-Segments (within the current Signature-List Block). If all Signature-Segments within a Signature-List Block pass validation (i.e., all segments are processed and the Signature-List Block has not yet been marked 'Not Good'), then the Signature_Block is marked as 'Good'. If at least one Signature_Block is marked as 'Good', then the validation algorithm terminates and the BGPSEC update message is deemed to be 'Good'. (That is, if a BGPSEC update message contains two Signature_Blocks then the update message is deemed 'Good' if the first Signature_Block is marked 'Good' OR the second Signature_Block is marked 'Good'.) *** So if one is good, is there any reason to try to the other? you would propagage it even if it were not, and by this point you know it is syntactically valid, right? **** 6. Algorithms and Extensibility 6.1. Algorithm Suite Considerations *** How much of this section is needed and how much can just refer to the algorithm agility draft? *** complete, use of the old 'current' algorithm will be deprecated, use of the 'new' algorithm will be mandatory, and a subsequent 'even Page 31 newer' algorithm suite may be specified as recommend to implement. *** I do not believe that once algorithm transition has completed that there will necessarily be a \"even newer\" algorithm proposed. *** Once the transition has successfully been completed in this manner, BGPSEC speakers SHOULD include only a single Signature_Block (corresponding to the 'new' algorithm). *** What is the signal to revert to just sending on sig block? The end of life deadline in the alg agility draft? I believe that alg agility draft allows for router certs to be of mixed algorithm. That might affect the timeline. *** In the case that such a change to BGPSEC were deemed desirable, it is expected that a subsequent version of BGPSEC would be created and that this version of BGPSEC would specify a new BGP Path Attribute, *** If BGP Path Attribute means the attribute defined here, you should call it by the name used here. *** let's call it BGPSEC_PATH_SIG_TWO, which is designed to accommodate the desired changes to BGPSEC. In such a case, the mandatory algorithm suites document would be updated to specify algorithm suites appropriate for the new version of BGPSEC. *** Any such new version of BGP would also have to produce a new version of this draft to talk about generating and validating the new attribute. *** Page 32 path.) Furthermore, the recipient is assured that this path terminates in an autonomous system that has been authorized by the IP address space holder as a legitimate destination for traffic to the given prefix. *** I'd say that the legitimate destination is the prefix, not the AS that is originating a route to the prefix. I think the path terminates in an AS that has a direct connection to the prefix. That is probably subject to the caveats that seem to always show up. (We've disallowed AS_SETs, so that caveat does not apply). Hm. Terminates in an AS that can deliver traffic to the prefix without the assistance of any other publically announced AS (ie it could go through private ASs to get there.) *** Note that although BGPSEC provides a mechanism for an AS to validate that a received update message has certain security properties, the use of such a mechanism to influence route selection is completely a matter of local policy. Therefore, a BGPSEC speaker can make no assumptions about the validity of a route received from an external BGPSEC peer. That is, a compliant BGPSEC peer may (depending on the local policy of the peer) send update messages that fail the validity test in Section 5. Thus, a BGPSEC speaker MUST completely validate all BGPSEC update messages received from external peers. (Validation of update messages received from internal peers is a matter of local policy, see Section 5). *** What does MUST completely validate mean? what is a not completely validated message? And why is this a MUST? Since we allow propagation of messages that are Not Good, this seems an odd requirement. *** Page 33 To understand the reason for such a design decision consider the case where the BGPSEC speaker receives an update message with both a set of algorithm A signatures which are 'Good' and a set of algorithm B signatures which are 'Not Good'. In such a case it is possible (perhaps even quite likely) that some of the BGPSEC speaker's peers (or other entities further 'downstream' in the BGP topology) do not support algorithm A. Therefore, if the BGPSEC speaker were to remove the 'Not Good' set of signatures corresponding to algorithm B, such entities would treat the message as though it were unsigned. By including the 'Not Good' set of signatures when propagating a route advertisement, the BGPSEC speaker ensures that 'downstream' entities have as much information as possible to make an informed opinion about the validation status of a BGPSEC update. Note also that during a period of partial BGPSEC deployment, a 'downstream' entity might reasonably treat unsigned messages different from BGPSEC updates that contain a single set of 'Not Good' ^differently *** actually, it is more than they might be treated differently, it is that unsigned might be preferred over Not Good. *** signatures. That is, by removing the set of 'Not Good' signatures the BGPSEC speaker might actually cause a downstream entity to 'upgrade' the status of a route advertisement from 'Not Good' to unsigned. Finally, note that in the above scenario, the BGPSEC speaker might have deemed algorithm A signatures 'Good' only because of some issue with RPKI state local to his AS (for example, his AS might not yet have obtained a CRL indicating that a key used to verify an algorithm A signature belongs to a newly revoked certificate). In such a case, it is highly desirable for a downstream entity to treat the update as 'Not Good' (due to the revocation) and not as 'unsigned' (which would happen if the 'Not Good' Signature_Blocks were removed). Page 34 The mechanism of setting the pCount field to zero is included in this specification to enable route servers in the control path to participate in BGPSEC without increasing the effective length of the AS-PATH. However, entities other than route servers could conceivably use this mechanism (set the pCount to zero) to attract traffic (by reducing the effective length of the AS-PATH) illegitimately. This risk is largely mitigated if every BGPSEC speaker drops incoming update messages that set pCount to zero but come from a peer that is not a route server. However, note that a recipient of a BGPSEC update message in which an upstream entity that is two or more hops away set pCount to zero is unable to verify for themselves whether pCount was set to zero legitimately. *** As there are suggestions of using pcount=0 for the AS aliasing work, we might not want to be specific about the use case here. The recipient should check to be sure that pcount=0 only when it expects that peer to be using pcount=0. We can't force the reasoning behind the configuration anyway. *** EDITOR'S NOTE: Do we want to mandate a specific transport security mechanism (e.g., TCP-AO)? *** If we do, then implementers would be required to use that transport for compliance - last I heard the TCP-AO implementations were not there yet. Tho' it will be a long while before this implementation is there yet either, so it may not matter. *** Page 35 Randy Bush begin_of_the_skype_highlighting end_of_the_skype_highlighting Internet Initiative Japan randy@psg.com *** figure this is a cut and paste error ***"}
{"_id":"doc-en-sidr-urXlPuav7uAFWm9eMGpgF6SgXO4","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nmy apologies for the bald and boring ascii text. if you wish i can put it in word perfect or pdf. :) <\/in joke> the document seems to have lost that Router Certificates for key sets may be per router, not just per AS. see section 3.1.1.1 (sic), Subject, of draft-ietf-sidr-bgpsec-pki-profiles. as an AS may have hundreds of BGPSEC speaking edge routers, you don't want to have to search the whole bag of Router Certificates for an AS to find the cert\/key that verifies a particular signature. and you can not just use the router-id of the peer AS received in the bgp open, as you will also need the router-ids of the signers further down the path. the document repeaytedly refers to EE Certs etc. where it should simply reference BGPsec Router Certificates as described in Section 3.1 of [I-D.ietf-sidr-bgpsec-pki-profiles] in general, i think the wording is redundant and unnecessarily complex in many places. but that is probably as much my disease than the editor's. --- Abstract This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. uh, the bgp attribute is AS_PATH, note the underbar and since it removes the AS_PATH attribute, it does not really secure it. in general, i think the nomenclature needs tightening, and it needs a clear phrase for the ASs through which the announcement has been routed. -- Requirements Language fwiw, recently i have been using more specific language The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in RFC 2119 [RFC2119] only when they appear in all upper case. They may also appear in lower or mixed case as English words, without normative meaning. -- 1. Introduction 2. Every AS listed in the AS_Path attribute of the update explicitly authorized the advertisement of the route to the subsequent AS in the AS_Path. ain't no as_path attribute in a bgpsec update. it seems to be the bgpsec_path_signatures attribute. btw, why not just bgpsec_path? or more formally BGPSEC_PATH -- This document specifies a new optional (non-transitive) BGP path why is \"non-transitive\" in parens? -- the documents referenced therein.) Any BGPSEC speaker who wishes to send BGP update messages to external peers (eBGP) containing the BGPSEC_Path_Signatures scrambled. the external peers do not contain the BGPSEC_Path_Signatures -- must have an RPKI end-entity certificate (as well as the associated private signing key) corresponding to the BGPSEC speaker's AS number. i think you want to refer to BGPsec Router Certificates as described in Section 3.1 of [I-D.ietf-sidr-bgpsec-pki-profiles] -- 2. BGPSEC Negotiation This document defines a new BGP capability [4]that allows a BGP speaker to advertise to its neighbors the ability to send and\/or it advertises to *a* neighbor -- 0 1 2 3 4 5 6 7 +---------------------------------------+ | Send | Receive | Reserved | Version | +---------------------------------------+ | AFI | +---------------------------------------+ | | +---------------------------------------+ | Reserved | +---------------------------------------+ | SAFI | +---------------------------------------+ remove the middle part of the line between AFI and the following octet. e.g. +---------------------------------------+ | | +---- AFI --------+ | | +---------------------------------------+ -- The high order bit (bit 0) of the first octet is set to 1 to indicate that the sender is able to send BGPSEC update messages, and is set to zero otherwise. The next highest order bit (bit 1) of this octet is set to 1 to indicate that the sender is able to receive BGPSEC update messages, and is set to zero otherwise. this leaves open that both may be zero -- The BGPSEC_Path_Signatures algorithm carries the secured AS Path information, including the digital signatures that protect this AS \"algorithm?\" attribute, i suspect -- BGPSEC_Path_Signatures attribute replaces the AS_PATH attribute, in a BGPSEC update message. That is, update messages that contain the BGPSEC_Path_Signatures attribute MUST NOT contain the AS_PATH attribute. and vice versa -- BGPSEC_Path_Signatures Attribute +-------------------------------------------------------+ | Secure_Path (variable) | +-------------------------------------------------------+ | Additional_Info (variable) | +-------------------------------------------------------+ | Sequence of one or two Signature_Blocks (variable) | +-------------------------------------------------------+ The Secure_Path contains AS Path information for the BGPSEC update \"Path\" should probably be lower case to avoid confusion -- message. This is logically equivalent to the information that would be contained in the AS_PATH attribute. s\/would be contained in the\/is contained in a non-BGPSEC\/ -- The path information is used by BGPSEC speakers in the same way that information from the AS_PATH is used by non- BGPSEC speakers. s\/path information\/Secure_Path\/ -- suite. Each of the Signature_Blocks will contain a signature segment for each AS number (i.e, secure path segment) in the Secure_Path. s\/each\/one\/ -- However, in order to enable a transition from an old algorithm suite to a new algorithm suite without a flag day -- The Secure_Path Length contains the length (in octets) of the variable-length sequence of Secure_Path Segments. As explained below, each Secure_Path segment is six octets long. Note that this means the Secure_Path Length is six times the number Secure_Path Segments (i.e., the number of AS numbers in the path). imiho, L in TLV includes itself so that you can just skip over that many octets. i.e. it would be 2 x segments + 2. this occurs throughout. -- The Secure_Path contains one Secure_Path segment for each (distinct) capitalize Segment -- Autonomous System in the path to the NLRI specified in the update message. in the path to the origiating AS of the NLRI -- Secure_Path Segment +----------------------------+ | AS Number (4 octets) | +----------------------------+ | pCount (1 octet) | +----------------------------+ | Flags (1 octet) | +----------------------------+ you are going to need the Router-ID of the signing router so that the verifier knows which BGPsec Router Certificate to choose. -- The pCount field contains the number of repetitions of the associated autonomous system number that the signature covers. This field enables a BGPSEC speaker to mimic the semantics of adding multiple s\/adding\/prepending\/ -- The remaining seven bits of the Flags field are reserved for future use. These bits MUST be set to zero by the sender. The receiver uses the entire Flags octet to verify the digital signature (regardless of what value the reserved bits contain) The remaining seven bits of the Flags MUST be set to zero by the sender, and the signature is computed over all seven bits of the Flags. -- Signature Segments +---------------------------------------------+ | Subject Key Identifier (20 octets) | +---------------------------------------------+ | Signature Length (2 octets) | +---------------------------------------------+ | Signature (variable) | +---------------------------------------------+ The Subject Key Identifier contains the value in the Subject Key Identifier extension of the RPKI end-entity certificate again. please refer to BGPsec Router Certificates as described in Section 3.1 of [I-D.ietf-sidr-bgpsec-pki-profiles] -- 4. Generating a BGPSEC Update Note that in order to create or add a new signature to a BGPSEC update message with a given algorithm suite, the BGPSEC speaker must possess a private key suitable for generating signatures for this algorithm suite. Additionally, this private key must correspond to the public key in a valid Resource PKI end-entity certificate whose AS number resource extension includes the BGPSEC speaker's AS number [11]. you do not mention that it could be a per-router-id key set. -- 4.1. Originating a New BGPSEC Update The pCount field of the Secure_Path Segment is typically set to the value 1. However, a BGPSEC speaker may set the pCount field to a value greater than 1. Setting the pCount field to a value greater than one has the same semantics as repeating an AS number multiple times in the AS_PATH of a non-BGPSEC update message (e.g., for traffic engineering purposes). Setting the pCount field to a value greater than one permits this repetition without requiring a separate digital signature for each repetition. it may be zero in certain special circumstances, see section 42.666 -- o Construct a sequence of octets by concatenating the Target AS Number, the Secure_Path (Origin AS, pCount, and Flags), the ^ Router-ID -- 4.2. Propagating a Route Advertisement If a BGPSEC router has received only non-BGPSEC update messages (without the BGPSEC_Path_Signatures attribute), containing the AS_Path attribute, from a peer for a given prefix s\/messages\/message\/ -- Note that removing BGPSEC signatures (i.e., propagating a route advertisement without the BGPSEC_Path_Signatures attribute) has significant security ramifications. (See Section 7 for discussion of the security ramifications of removing BGPSEC signatures.) Therefore, when a route advertisement is received via a BGPSEC update message, propagating the route advertisement without the BGPSEC_Path_Signatures attribute is NOT RECOMMENDED. unless the peer to which the BGPSEC speaker is sending did not signal the ability to receive BGPSEC in the capability negotiation. if this is the case, see section 42.666 for converting to AS_PATH. -- If the BGPSEC speaker is not a member of an autonomous system confederation [3], then the Flags field of the Secure_Path Segment MUST be set to zero. it might be prudent to not talk about the whole flags field, as we do not know what exciting future may lie before it. just talk about the Confed_Segment flag. -- If the received BGPSEC update message contains two Signature_ Blocks and the BGPSEC speaker supports both of the corresponding algorithms suites, then the new update message generated by the BGPSEC speaker SHOULD include both of the Signature_Blocks. If the received BGPSEC update message contains two Signature_Blocks and the BGPSEC speaker only supports one of the two corresponding algorithm suites, then the BGPSEC speaker MUST remove the Signature_Block corresponding to the algorithm suite that it does not understand. If the BGPSEC speaker does not support the algorithm suites in any of the Signature_Blocks contained in the received update message, then the BGPSEC speaker MUST NOT propagate the route advertisement with the BGPSEC_Path_Signatures attribute (i.e., propagate it as an unsigned BGP update message). explain why. the speaker can not add its info to a sig block for which it does not understand the alg. and there can not be a gap in the sig block. -- 4.3. Processing Instructions for Confederation Members o First, starting with the least recently added Secure_Path segments, remove all of the consecutive Secure_Path segments that have the Confed_Segment flag set to one. s\/least\/most\/ -- 4.4. Reconstructing the AS_PATH Attribute 2. If the Confed_Segment flag in the Secure_Path segment is set to zero, then look at the most-recently added segment in the AS_PATH. * In the case where the AS_PATH is empty then add (prepend to the AS_PATH) a new AS_PATH segment of type AS_SEQUENCE. In the case where the AS_PATH is empty and pcount is greater than zero, ... -- 5. Processing a Received BGPSEC Update Upon receiving a BGPSEC update message from an external (eBGP) peer, a BGPSEC speaker SHOULD validate the message to determine the authenticity of the AS PATH information contained in the BGPSEC_Path_Signatures attribute. AS PATH is confusing. maybe Upon receiving a BGPSEC update message from an external (eBGP) peer, a BGPSEC speaker SHOULD validate the message to determine the authenticity of the data covered by the BGPSEC_Path_Signatures attribute. -- However, in practice, it is expected that most implementations will not actually run the algorithm from Section 4.4, and will instead transform the BGPSEC_Path_Signatures attribute directly into some internal representation of AS path. how about just saying that it will behave the same, and do not say it actually has to transform it in any way? -- With regards to the processing of duplicate update messages, if the first update message is valid, then an implementation SHOULD NOT run the validation procedure on the second, duplicate update message (even if the bits of the signature field are different). If the first update message is not valid, then an implementation SHOULD run the validation procedure on the second duplicate update message (as the signatures in the second update may be valid even though the first contained a signature that was invalid). in the very next section, you use the words \"Good\" and \"Not Good.\" there is a consistency problem, and not just here. -- 5.1. Overview of BGPSEC Validation Validation of a BGPSEC update messages makes use of data from RPKI certificates and signed Route Origination Authorizations (ROA). In particular, to validate update messages containing the BGPSEC_Path_Signatures attribute, it is necessary that the recipient have access to the following data obtained from valid RPKI certificates and ROAs: o For each valid RPKI end-entity certificate containing an AS Number extension, the AS Number, Public Key and Subject Key Identifier are required, and router-id -- o For each valid ROA, the AS Number and the list of IP address prefixes. what is a 'valid' roa? -- Note that the BGPSEC speaker could perform the validation of RPKI certificates and ROAs on its own and extract the required data, or it could receive the same data from a trusted cache that performs RPKI validation on behalf of (some set of) BGPSEC speakers. (The latter case in analogous to the use of the RPKI-RTR protocol [13] for origin validation.) draft-ymbk-rpki-rtr-keys is soon to describe a new rpki-rtr pdu to handle the per-as and per-router keys -- It is expected that the output of the validation procedure will be used as an input to BGP route selection. However, BGP route selection and thus the handling of the two validation states is a matter of local policy, and shall be handled using existing local policy mechanisms. s\/existing\/\/ i.e. a vendor could create a new testable attribute bgpsec-state. -- It is expected that BGP peers will generally prefer routes received via 'Good' BGPSEC update messages over routes received via 'Not Good' BGPSEC update messages as well as routes received via update messages that do not contain the BGPSEC_Path_Signatures attribute. However, BGPSEC specifies no changes to the BGP decision process and leaves to the operator the selection of an appropriate policy mechanism to achieve the operator's desired results within the BGP decision process. someone should write a draft something like draft-ietf-sidr-bgpsec-ops -- BGPSEC validation needs only be performed at eBGP edge. The validation status of a BGP signed\/unsigned update MAY be conveyed via iBGP from an ingress edge router to an egress edge router. how? where are the bits to carry validation state? -- Local policy in the AS determines the specific means for conveying the validation status through various pre-existing mechanisms (e.g., modifying an attribute). imiho, this document should not get into all the lovely things local policy might do unless it is required for bgpsec, and nothing should be in that set. -- As discussed in Section 4, when a BGPSEC speaker chooses to forward a (syntactically correct) BGPSEC update message, it SHOULD be forwarded with its BGPSEC_Path_Signatures attribute intact (regardless of the validation state of the update message). no. not when the speaker does not understand one of the algorithms. -- Based entirely on local policy settings, an egress router MAY trust the validation status conveyed by an ingress router or it MAY perform its own validation. or it can just sign it and not test anything at all. this does not need to be said -- 5.2. Validation Algorithm 3. Check that the update message does not contain both a BGPSEC_Path_Signatures attribute and an AS_PATH attribute. this sentence implies bgpsec validation could happen on an update with only as_path. you want to simply say no as_path is allowed. -- If there are two Signature_Blocks within the BGPSEC_Path_Signatures attribute and one of them is poorly formed (or contains the wrong number of Signature segments) , then the recipient should log that an error occurred s\/log\/inform the operator\/ i.e. it could snmp trap etc -- strip off that particular Signature_Block and process the update message as though it arrived with a single Signature_Block. If the BGPSEC_Path_Signatures attribute contains an error that is not local to one of two Signature_Blocks, then the recipient should log that an error occurred s\/log\/inform the operator\/ -- message containing the error. (In particular, if any of checks 3-5 above fail, the recipient should log that an error occurred and drop the update message containing the error.) s\/log\/inform the operator\/ -- o (Step II): Compute the digest function (for the given algorithm suite) on the appropriate data. If the segment is not the (least recently added) segment corresponding to the origin AS, then the digest function should be computed on the following sequence of octets: Sequence of Octets to be Hashed +-------------------------------------------+ | AS Number of Target AS (4 octets) | +-------------------------------------------+ | AS Number (4 octets) | ---\\ +-------------------------------------------+ \\ | pCount (1 octet) | > Secure_Path +-------------------------------------------+ \/ | Flags (1 octet) | ---\/ +-------------------------------------------+ | Sig Field in the Next Segment (variable) | +-------------- ----------------------------+ ^ did the router-id fall through that little hole? :) -- 7. Security Considerations o The origin AS number corresponds to an autonomous system that has been authorized by the IP address space holder to originate route ^ in the RPKI advertisements for the given prefix. o For each AS number in the AS Path, a BGPSEC speaker authorized by in the RPKI ^ the holder of the AS number intentionally chose (in accordance with local policy) to propagate the route advertisement to the next AS in the Secure_Path. -- That is, the recipient of a valid BGPSEC Update message is assured that the Secure_Path corresponds to a sequence of autonomous systems who have all agreed in principle to forward packets to the given prefix along the indicated path. we do not know what the bgp announcement is signaling. while willingness to forward has been the classic, idr is declaring bgp to be a competitor to the dns for arbitrary signaling. -- (It should be noted that BGPSEC does not offer a precise guarantee that the data packets would propagate along the indicated path; it only guarantees that the BGP update conveying the path indeed propagated along the indicated path.) this is more like it -- Therefore, it is important to note that when a BGPSEC speaker signs an outgoing update message, it is not attesting to a belief that all signatures prior to its are valid. Instead it is merely asserting that: o The BGPSEC speaker received the given route advertisement with the indicated NLRI and Secure_Path; and o The BGPSEC speaker chose to propagate an advertisement for this route to the peer (implicitly) indicated by the 'Target AS' and that it is capable of that particular algorithm suite (trivial) -- Finally, BGPSEC does not provide protection against all attacks at the transport layer. s\/all\/\/ -- EDITOR'S NOTE: Do we want to mandate a specific transport security mechanism (e.g., TCP-AO)? slippery slope. -- Samuel Weiler Cobham sparta again -30-"}
{"_id":"doc-en-sidr-DMZrr0jTGMAwTujk9py-4c06Tc8","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\ni note that you got one actual reivew, which is good. the only other stuff i have seen is people telling the chairs what the process should be, embarrassing. I concur - the stated fact that we're still awaiting revisions to the threats document and the requirements draft has long-standing unaddressed comments and the protocol document is being WG last called -- it is indeed embarrassing. Given the potential array of implications of work here, as well as the climate surrounding Internet governance and the global stability of the routing system, open standards development and transparency, we ought to have the good sense to follow our own processes. If solutions champions want less friction take it to the IRTF and make it EXPERIMENTAL... Feeling a bit like \"the wall\" here [1].... -danny [1] http:\/\/archive.psg.com\/051000.ccr-ivtf.html"}
{"_id":"doc-en-sidr-m7ajgzAFg5O38z4Hgn5F6Hy_vj0","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\ner. The three documents have been in the working group for the same length of time, so you'd think that they, being so tied, would have had equal attention and be equally mature. Sandy - The very fact that \"The three documents have been in the working group for the same length of time\" is PRECISELY why I have this concern. Until we've agreed upon requirements we intend to design for I don't know what problems we profess to be solving in a proposed protocol and therefore I am not capable of assessing if a protocol is meeting said requirements - the point of transparency here is so that others [who didn't bring these documents into the WG as a set] can have a fair say about their content before we progress. Further, if there wasn't such an apparent disconnect at the earlier stages of the process (e.g., what problems we are solving for), or IF we were designing these things in an IRTF group as EXPERIMENTAL and not as IETF Standards Track documents, I might be afforded the opportunity to care less. -danny"}
{"_id":"doc-en-sidr-n3EEZxwj35EsXoKkf-TworNtbjc","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nMy comments on the requirements draft have never been addressed. not ignoring you. i have kept them and plan a rev. chairs have not told me it's a rush so i am trying not to do a rev a day on this one. randy"}
{"_id":"doc-en-sidr-LnH6VqjVnHQEuC19ZNHMTzow0B4","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nDear wg and wg chairs (those without and those with hats), My comments on the requirements draft have never been addressed. This thread highlights a dependency that exists between the requirements of this protocol and the design of this protocol. I do not think that (as engineers) should embrace the backward nature of this situation. I object to this draft until we can mature the drafts it depends on. Eric ----- Original Message ----- From: Randy Bush [mailto:randy@psg.com] Sent: Friday, September 21, 2012 08:32 PM To: Sandra Murphy <Sandra.Murphy@sparta.com> Cc: sidr wg <sidr@ietf.org> Subject: Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05 The newest protocol draft came out on 7 Sep and I asked the working group to \"look at this draft right away\" because it would be discussed at the interim meeting. After eight days with no comments, a wglc seemed a good idea. Sad that our lives need a wglc to produce participation, but it is what it is. i note that you got one actual reivew, which is good. the only other stuff i have seen is people telling the chairs what the process should be, embarrassing. i promise a detailed re-read in the next days. randy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-QdhZ8_Ks7t3FrogtW3jW0CyrEZA","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\ni note that you got one actual reivew, which is good. the only other stuff i have seen is people telling the chairs what the process should be, embarrassing. i promise a detailed re-read in the next days. thnx!"}
{"_id":"doc-en-sidr-sShq4SmUk1-n61jf7nsfaMNhLfs","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nI think your objection was noted... no need to belabour the point (or become uncivil) thanks for your opinion. -chris"}
{"_id":"doc-en-sidr-R7MA6ueSyNvDRI524ewrfx3NQi4","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nThe newest protocol draft came out on 7 Sep and I asked the working group to \"look at this draft right away\" because it would be discussed at the interim meeting. After eight days with no comments, a wglc seemed a good idea. Sad that our lives need a wglc to produce participation, but it is what it is. i note that you got one actual reivew, which is good. the only other stuff i have seen is people telling the chairs what the process should be, embarrassing. i promise a detailed re-read in the next days. randy"}
{"_id":"doc-en-sidr-kYWQWGQoEbQxaAF-G1fmgV691t0","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nDiscussion yes, revisions, not so much, and in particular, -threats is not done. WGLC is inappropriate prior to -threats completion in WG. Plus, -threats has not adequately accommodated criticism. Doing s\/BGPSEC\/ANOTHER_NAME\/g does not qualify as \"substantive\", IMHO. There was no review post -05 publication. Review prior to that point is not relevant, IMHO. At a minimum, those whose comments were in theory addressed, should be given the opportunity, each and every one of them, to speak up and be heard. It is the job of the chairs to track issues and confirm with commentators that revisions are adequate. I am not a chair. Brian On Fri, Sep 21, 2012 at 8:20 PM, Christopher Morrow <morrowc.lists@gmail.com wrote: On Fri, Sep 21, 2012 at 8:18 PM, Brian Dickson <brian.peter.dickson@gmail.com> wrote: I don't believe it is at all appropriate to WGLC a document prior to substantive review and maturity. it's on it's 5th revision, with substantive discussion along the way... Discussion yes, revisions, not so much, and in particular, -threats is not done. WGLC is inappropriate prior to -threats completion in WG.Plus, -threats has not adequately accommodated criticism. Doing s\/BGPSEC\/ANOTHER_NAME\/g does not qualify as \"substantive\", IMHO. There was no review post -05 publication. Review prior to that point is not relevant, IMHO.At a minimum, those whose comments were in theory addressed, should be given the opportunity, each and every one of them, to speak up and be heard. It is the job of the chairs to track issues and confirm with commentators that revisions are adequate.I am not a chair.BrianOn Fri, Sep 21, 2012 at 8:20 PM, Christopher Morrow <morrowc.lists@gmail.com> wrote: I don't believe it is at all appropriate to WGLC a document prior to substantive review and maturity. it's on it's 5th revision, with substantive discussion along the way..."}
{"_id":"doc-en-sidr-5T57jY3cSLpU3eVDTda8Q_lfjAM","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nWith all due respect, Sandy, what are you smoking? If there is a dependency that goes \"A, then B, then C\", then CLEARLY \"C\" needs to bake longer than \"B\", and \"B\" longer than \"A\". Maybe not strictly relative elapsed time, but certainly there would need to be a post-A significant time before \"B\" finishes. Ditto for B->C. In most cases, effort on C and B is likely to be potentially wasted prior to A, and worse, it leads to work on \"C\" and \"B\" resulting in wrong-headed decisions concerning \"A\", precisely *because* of the work on \"B\" and \"C\" would otherwise be wasted. The history of tech is littered with (frequently DOD subcontractors') wasted efforts that end up bloating projects or putting them into dead-end paths. ADA, anyone? Let's look at the reality, rather than the theory, when evaluating documents' progress and status, please. Especially when one is \"chair\" of a WG. I don't think putting any sort of time pressure is appropriate when we are talking about a critical infrastructure security protocol. Brian On Fri, Sep 21, 2012 at 7:27 PM, Murphy, Sandra <Sandra.Murphy@sparta.com>wrote: The protocol, threats and requirements documents are definitely tied together and will progress together. The three documents have been in the working group for the same length of time, so you'd think that they, being so tied, would have had equal attention and be equally mature. On the non-process, reality side of things: The newest protocol draft came out on 7 Sep and I asked the working group to \"look at this draft right away\" because it would be discussed at the interim meeting. After eight days with no comments, a wglc seemed a good idea. Sad that our lives need a wglc to produce participation, but it is what it is. --Sandy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr With all due respect, Sandy, what are you smoking?If there is a dependency that goes \"A, then B, then C\", then CLEARLY \"C\" needs to bake longer than \"B\", and \"B\" longer than \"A\". Maybe not strictly relative elapsed time, but certainly there would need to be a post-A significant time before \"B\" finishes. Ditto for B->C. In most cases, effort on C and B is likely to be potentially wasted prior to A, and worse, it leads to work on \"C\" and \"B\" resulting in wrong-headed decisions concerning \"A\", precisely *because* of the work on \"B\" and \"C\" would otherwise be wasted. The history of tech is littered with (frequently DOD subcontractors') wasted efforts that end up bloating projects or putting them into dead-end paths. ADA, anyone?Let's look at the reality, rather than the theory, when evaluating documents' progress and status, please. Especially when one is \"chair\" of a WG. I don't think putting any sort of time pressure is appropriate when we are talking about a critical infrastructure security protocol.Brian The protocol, threats and requirements documents are definitely tied together and will progress together. The three documents have been in the working group for the same length of time, so you'd think that they, being so tied, would have had equal attention and be equally mature. On the non-process, reality side of things: The newest protocol draft came out on 7 Sep and I asked the working group to \"look at this draft right away\" because it would be discussed at the interim meeting. After eight days with no comments, a wglc seemed a good idea. Sad that our lives need a wglc to produce participation, but it is what it is. --Sandy _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-AXHbY3dVyIqtbTcO6fPTV2c3iJg","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nI don't believe it is at all appropriate to WGLC a document prior to substantive review and maturity. it's on it's 5th revision, with substantive discussion along the way..."}
{"_id":"doc-en-sidr-VFFPGOiJl3_UBILUVCIGVyMoIXA","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nIMHO, attempting to generate discussion on a document by doing WGLC, is completely bass-ackwards. I don't believe it is at all appropriate to WGLC a document prior to substantive review and maturity. I.e. the chairs should ask FIRST, informally, if folks think we're ready to WGLC, and wait a bit for answers. The bar for saying \"no\" should be fairly low, and only in the absence of lots of positive \"hum\" should WGLC proceed. I would suggest the chairs review the processes adopted in other (more mature) WGs, such as dnsext, for better processes and procedures. E.g. commitment of >=5 reviewers to review, prior to WGLC. This excludes authors, of course, from the review process. It has worked very well there, IMHO. Given that, as Danny notes, the entire content of -protocol depends on -requirements, which itself depends on -threats, I have to concur with him - \"NO\" to proceeding at this time. So, to be clear: - I don't think that, even if it were otherwise ready, that it wold be appropriate to WGLC the -protocol doc - I do not believe the -protocol doc is ready to go (independent of the gating issue) There are several areas that are not adequately settled, especially in the pcount=0 and transition areas. Consider this a formal request to bounce this document out of WGLC. It would be fine to discuss on the interim meeting, and there does not need to be a WGLC just to get discussion. Brian On Fri, Sep 21, 2012 at 7:13 PM, Christopher Morrow <morrowc.lists@gmail.com wrote: On Fri, Sep 21, 2012 at 6:20 PM, Danny McPherson <danny@tcb.net> wrote: I do not intend to review this document in it's current state and am confused how we can WG LC it while the threat and [presumably subsequent] requirements documents are still being developed by the WG. I would like an explanation from the chairs regarding what the intention is here. I believe the hope was to stir up some discussion, interest and readers prior to the interim meeting next saturday. As with all WGLC's perhaps this document needs to wait on something else, or isn't ready yet, or has other considerations to deal with... or is ready to fly like a baby birdie. we won't know without some discussion, and I believe there will be a bunch more of that in 8 days time. -chris On Sep 20, 2012, at 10:42 AM, Danny McPherson wrote: Sandy, I don't understand how we can WG LC this document when the requirements document isn't complete, and the requirements document isn't complete because we're still working out the threats document. Can you explain the logic here? -danny On Sep 15, 2012, at 7:45 AM, Murphy, Sandra wrote: This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr IMHO, attempting to generate discussion on a document by doing WGLC, is completely bass-ackwards.I don't believe it is at all appropriate to WGLC a document prior to substantive review and maturity.I.e. the chairs should ask FIRST, informally, if folks think we're ready to WGLC, and wait a bit for answers. The bar for saying \"no\" should be fairly low, and only in the absence of lots of positive \"hum\" should WGLC proceed.I would suggest the chairs review the processes adopted in other (more mature) WGs, such as dnsext, for better processes and procedures. E.g. commitment of >=5 reviewers to review, prior to WGLC. This excludes authors, of course, from the review process.It has worked very well there, IMHO.Given that, as Danny notes, the entire content of -protocol depends on -requirements, which itself depends on -threats, I have to concur with him - \"NO\" to proceeding at this time. So, to be clear:- I don't think that, even if it were otherwise ready, that it wold be appropriate to WGLC the -protocol doc- I do not believe the -protocol doc is ready to go (independent of the gating issue) There are several areas that are not adequately settled, especially in the pcount=0 and transition areas.Consider this a formal request to bounce this document out of WGLC.It would be fine to discuss on the interim meeting, and there does not need to be a WGLC just to get discussion. BrianOn Fri, Sep 21, 2012 at 7:13 PM, Christopher Morrow <morrowc.lists@gmail.com> wrote: On Fri, Sep 21, 2012 at 6:20 PM, Danny McPherson <danny@tcb.net> wrote: I do not intend to review this document in it's current state and am confused how we can WG LC it while the threat and [presumably subsequent] requirements documents are still being developed by the WG. I would like an explanation from the chairs regarding what the intention is here. I believe the hope was to stir up some discussion, interest and readers prior to the interim meeting next saturday. As with all WGLC's perhaps this document needs to wait on something else, or isn't ready yet, or has other considerations to deal with... or is ready to fly like a baby birdie. we won't know without some discussion, and I believe there will be a bunch more of that in 8 days time. -chris On Sep 20, 2012, at 10:42 AM, Danny McPherson wrote: Sandy, I don't understand how we can WG LC this document when the requirements document isn't complete, and the requirements document isn't complete because we're still working out the threats document. Can you explain the logic here? -danny This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-892cUi42xUMLpNY1E0cL8Hl1kd4","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nThe protocol, threats and requirements documents are definitely tied together and will progress together. The three documents have been in the working group for the same length of time, so you'd think that they, being so tied, would have had equal attention and be equally mature. On the non-process, reality side of things: The newest protocol draft came out on 7 Sep and I asked the working group to \"look at this draft right away\" because it would be discussed at the interim meeting. After eight days with no comments, a wglc seemed a good idea. Sad that our lives need a wglc to produce participation, but it is what it is. --Sandy"}
{"_id":"doc-en-sidr-Z6i6fMXELJjcrI-4UKSrtPndzUU","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nOn Fri, Sep 21, 2012 at 6:20 PM, Danny McPherson <danny@tcb.net> wrote: I do not intend to review this document in it's current state and am confused how we can WG LC it while the threat and [presumably subsequent] requirements documents are still being developed by the WG. I would like an explanation from the chairs regarding what the intention is here. I believe the hope was to stir up some discussion, interest and readers prior to the interim meeting next saturday. As with all WGLC's perhaps this document needs to wait on something else, or isn't ready yet, or has other considerations to deal with... or is ready to fly like a baby birdie. we won't know without some discussion, and I believe there will be a bunch more of that in 8 days time. -chris On Sep 20, 2012, at 10:42 AM, Danny McPherson wrote: Sandy, I don't understand how we can WG LC this document when the requirements document isn't complete, and the requirements document isn't complete because we're still working out the threats document. Can you explain the logic here? -danny This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-1s6XlknTqGfhMMMK9VTmzcdLliI","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nI do not intend to review this document in it's current state and am confused how we can WG LC it while the threat and [presumably subsequent] requirements documents are still being developed by the WG. I would like an explanation from the chairs regarding what the intention is here. -danny On Sep 20, 2012, at 10:42 AM, Danny McPherson wrote: Sandy, I don't understand how we can WG LC this document when the requirements document isn't complete, and the requirements document isn't complete because we're still working out the threats document. Can you explain the logic here? -danny This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-ShzAMJ1WPnsO3y4PwM2N9SvhX8U","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nHere's my review: One biggie: 1) MUST have an \"IANA Considerations\" section even if it says \"none\". But, I think you've Flags and Info Types to register right? Algs are getting done elsewhere ;) One not so biggie but a required formatting thing: 1) s9: If all references are normative, put \"Normative\" in the section title. A bunch of nits mixed in with requests for additional clarifications (i.e., no biggies): 1) s1: r\/must have an\/needs an 2) s1: r\/does not require\/does not need 3) s2: r\/[4]that\/[4] that 4) s2, bits 2 and 3 as well as the fourth octet: normally this should would be a must any reason it's not a must?: These reserved bits should be set to zero by the sender and ignored by the receiver. 5) s2: contains the following: If there does not exist at least one version of BGPSEC that is supported by both peers in a BGP session, then the use of BGPSEC has not been negotiated. (That is, in such a case, messages containing the BGPSEC_Path_Signatures MUST NOT be sent.) Should this paragraph say something about the BGP NOTIFICATION message with the Error Code 2 (OPEN Message Error) and the OPEN Message Error SubCode 4 (Unsupported Optional Parameter) or is it the SubCode 7 (Unsupported Capability) MUST be returned if both don't support bgpsec? 6) s2, Figure: If the AFI is 2 octets can we do the following: +---------------------------------------+ | AFI | + + | | +---------------------------------------+ so people won't ask what's in the blank line ;) 7) s2: Is there a reference for AFI that we can point to? 8) s2: ? r\/speaker must include two\/speaker includes two 9) s2: r\/it has also advertises\/it has also advertised 10) s2: r\/(see RFC 4893).\/[RFC 4893] - and add a reference. 11) s2: X2 (aligns with earlier sentences) r:\/its open message\/its BGP OPEN message\/ 12) s3: r\/new optional\/new OPTIONAL 13) High-Level Diagram of the BGPSEC_Path_Signatures Attribute BGPSEC_Path_Signatures figure: I might be reading way to much in to this but I don't want people to get the impression that signature X and Y for alg 1 and 2 are the same. You might draw that conclusion from this: | +-----------------+ +-----------------+ | | | Sig Block 1 | | Sig Block 2 | | | +-----------------+ +-----------------+ | | | Alg Suite 1 | | Alg Suite 2 | | | | SKI X | | SKI X | | | | Sig Length X | | Sig Length X | | | | Signature X | | Signature X | | | | SKI Length Y | | SKI Length Y | | | | SKI Y | | SKI Y | | | | Sig Length Y | | Sig Length Y | | | | Signature Y | | Signature Y | | | | ... | | .... | | | +-----------------+ +-----------------+ | Maybe in Sig Block 1 r\/X\/X1 and r\/Y\/Y1 and in Sig block 2 r\/X\/X2 and r\/Y\/Y2? 14) s3: If it does include the AS_PATH attribute what happens: That is, update messages that contain the BGPSEC_Path_Signatures attribute MUST NOT contain the AS_PATH attribute. 15) s3.1: Should probably add some ascii art for the flags: +-+-+-+-+-+-+-+-+ |C| Reserved | +-+-+-+-+-+-+-+-+ 16) s3.1: r\/These bits MUST be set to zero by the sender. \/These bits MUST be set to zero by the sender and ignored by the recipient. 17) s3.1\/3.2: Are the editor's notes going to get removed at some point or are we planning on keeping it? 18) s3.3: Probably worth adding the the SKI is copied from the signers certificate and need not be generated. Or, is that implementation specific? 19) s4: In the last paragraph should the \"must\" be \"MUST\" x2. It's in a \"Note\" paragraph so I could see not use MUST, but in that case maybe r\/must possess\/needs and r\/must\/needs to. If you use the MUST strike \"Note\" - I don't think requirements should appear in Note paragraphs (though they often do). 20) s4.1: I'd just strike \"Note that\" from the those two paragraphs (x3). 21) s4.2: If we're going to keep NOT RECOMMENDED then you need to add it to the conventions. Put it after RECOMMENDED so the nit checker won't barf on it. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [8]. Actually, the RFC editor is going to move the requirements language to the mainbody so might as well do it now. Just slap it in as s1.1. 22) s4.3: MUST instead of must: Members of autonomous system confederations [3] must additionally follow the instructions in this section for processing BGPSEC update messages. 23) s4.3: r\/it must remove all \/it MUST remove all ? r\/confederation members must make \/confederation members MUST make ? 24) s5.2: I think there a link missing to how you determine whether the certificate is valid in the following: To do this, consult the valid RPKI end-entity certificate data and look up all valid (AS, SKI, Public Key) triples in which the AS matches the AS number in the corresponding Secure_Path segment. To me that means do the RPKI certificate checks in RFC 6487 as augmented by s3.3 of draft-ietf-sidr-bgpsec-pki-profiles. Probably just adding a pointer to [11] would wfm. To do this, consult the valid RPKI end-entity certificate data and look up all valid (AS, SKI, Public Key) triples, see Section 3.3 of [11], in which the AS matches the AS number in the corresponding Secure_Path segment. or something like that. 25) s6.1, 1st para: r\/must\/needs to X2 26) s6.1, 2nd para, 2nd sentence: I think the bit about the 'new' algorithm being specified in [12] should be deleted. It doesn't say anything about 'new' algorithm right now and the 3rd paragraph says if and when the new alg is chosen that draft will be updated. 27) s6.1: r\/the future the mandatory\/the future mandatory That's it for now. spt This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-K6o7YJgzk2iUXN5v2Zgap_dxg1c","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nSandy, I don't understand how we can WG LC this document when the requirements document isn't complete, and the requirements document isn't complete because we're still working out the threats document. Can you explain the logic here? -danny This starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-WNJZVNgD8BddTFR0fY2zIyrhXD8","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nSent: Tuesday, September 18, 2012 5:04 PM To: George, Wes; sidr@ietf.org Subject: RE: WGLC for draft-ietf-sidr-bgpsec-protocol-05 The use of pcount=0 was hoped\/expected to require NO changes in the update validation algorithm. If you have discovered places where it would require changes, it will indeed be interesting to see and discuss. [WEG] use of pcount=0 for AS migration may not require changes to the *algorithm* itself, as much as it will simply require discussion of the process for handling pcount=0 in the cases where it is used and the neighbor is not a transparent route-server, since currently that case is discussed specifically in the draft, and there is a specific recommendation that pcount=0 updates be dropped if they didn't come from a known route-server neighbor. That said, I'm not convinced it completely solves the problem, as I (hopefully) articulated in my pending draft, and *that* may require algorithm changes. Wes This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-UJ5NIDBCGopA7bctf9CLlpAPN5Y","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nThere's been some discussion of using pcount=0 to manage some parts of this, but that would have to be covered in the update validation and origination algorithm if we choose to solve the problem that way. The use of pcount=0 was hoped\/expected to require NO changes in the update validation algorithm. If you have discovered places where it would require changes, it will indeed be interesting to see and discuss. --Sandy ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of George, Wes [wesley.george@twcable.com] Sent: Tuesday, September 18, 2012 4:21 PM To: Murphy, Sandra; sidr@ietf.org Subject: Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05 Nits: Multiple sections have \"musts\" and \"shoulds\" that are not 2119-formatted (lower-case) - please ensure that this is intentional Substantial: Any reason why we're using \"good\" and \"not good\" for validation state instead of valid\/invalid (and unknown)? I'd think that consistency between this and the language in the origin validation stuff would be helpful unless we have a specific reason not to use the same language. And I realize that there isn't really an \"unknown\" status as the result of trying to validate a BGPSec update, but as far as the implementation is concerned, standard BGP updates (those without BGPSec) are considered unknown, and it might be good to explicitly state that as a part of the validation algorithm. I'm awaiting co-author review of the I-D version of the email I wrote about AS-Migration, and am hoping to have it posted next week sometime. I think that we need to discuss the considerations from that issue to ensure that no changes need to be made in the protocol spec document\/design before we progress this. There's been some discussion of using pcount=0 to manage some parts of this, but that would have to be covered in the update validation and origination algorithm if we choose to solve the problem that way. Also I'm not completely certain that pcount will solve the use case completely. I'm not opposed to using the draft as a follow-on to the protocol draft (update it) to handle this specific case, but I'd like to have WG consensus that this is the route we should take rather than incorporating any solution for this use case into the current document since it is still in draft. Thanks, Wes George -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Murphy, Sandra Sent: Saturday, September 15, 2012 7:45 AM To: sidr@ietf.org Subject: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05 This starts a working group last call for draft-ietf-sidr-bgpsec- protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-dVepV1btNLAtIQF5ZVb2XsH_LdA","title":"","text":"Re: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nNits: Multiple sections have \"musts\" and \"shoulds\" that are not 2119-formatted (lower-case) - please ensure that this is intentional Substantial: Any reason why we're using \"good\" and \"not good\" for validation state instead of valid\/invalid (and unknown)? I'd think that consistency between this and the language in the origin validation stuff would be helpful unless we have a specific reason not to use the same language. And I realize that there isn't really an \"unknown\" status as the result of trying to validate a BGPSec update, but as far as the implementation is concerned, standard BGP updates (those without BGPSec) are considered unknown, and it might be good to explicitly state that as a part of the validation algorithm. I'm awaiting co-author review of the I-D version of the email I wrote about AS-Migration, and am hoping to have it posted next week sometime. I think that we need to discuss the considerations from that issue to ensure that no changes need to be made in the protocol spec document\/design before we progress this. There's been some discussion of using pcount=0 to manage some parts of this, but that would have to be covered in the update validation and origination algorithm if we choose to solve the problem that way. Also I'm not completely certain that pcount will solve the use case completely. I'm not opposed to using the draft as a follow-on to the protocol draft (update it) to handle this specific case, but I'd like to have WG consensus that this is the route we should take rather than incorporating any solution for this use case into the current document since it is still in draft. Thanks, Wes George -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Murphy, Sandra Sent: Saturday, September 15, 2012 7:45 AM To: sidr@ietf.org Subject: [sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05 This starts a working group last call for draft-ietf-sidr-bgpsec- protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-QduINkI6ecYNIDobkkXl3SfsWg8","title":"","text":"[sidr] WGLC for draft-ietf-sidr-bgpsec-protocol-05\nThis starts a working group last call for draft-ietf-sidr-bgpsec-protocol-05. The draft is available at http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 and https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/ Please review this draft to see if you think it is ready for publication. Send end comments to the list. The WGLC will end on 29 September 2012. --Sandy, speaking as wg co-chair"}
{"_id":"doc-en-sidr-tC_THy1hLVioDoFhUJAJ-vh_cME","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-05.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-05.txt Pages : 37 Date : 2012-09-07 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-05 A diff from the previous version is available at: http:\/\/www.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-05 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-9BqBQnSb1ZZ4wAPHWu_ws7byVYk","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-04.txt\nThe main difference between the -03 version of this document and the -04 version is support for confederations as discussed at the June interim meetings. A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-04.txt Pages : 33 Date : 2012-07-16 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-04 A diff from previous version is available at: http:\/\/tools.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-04 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-6JDR2oUC_3xS4Rg7-sKkNBENpHg","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-04.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-04.txt Pages : 33 Date : 2012-07-16 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. The IETF datatracker status page for this draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol There's also a htmlized version available at: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-04 A diff from previous version is available at: http:\/\/tools.ietf.org\/rfcdiff?url2=draft-ietf-sidr-bgpsec-protocol-04 Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/"}
{"_id":"doc-en-sidr-wRs1xpYGqGGAt3qtToH5JNFxUfo","title":"","text":"Re: [sidr] request for agenda items for interim meeting 6 Jun\nSandy, In my opinion the biggest open issue in the bgpsec protocol draft is the confederation issue that we discussed at the previous interim. (That is, if we don't include AS4_Path or AS_Path in a bgpsec signed update, then we need to somehow encode the information that would be in the AS_confed_sequence segments of the AS_Path.) At the April interim there were three possible solutions that people put forward to address this issue. However, we didn't decide on what was the best way forward. Now that people have had some more time to think about the issue, I would very much like to try and reach concensus at the Vancouver interim so that we can close this issue. If it would be helpful, I'm happy to throw together a few slides for the interim summarizing the problem and the possible solutions discussed at the April interim. Also, recently submitted a new version of draft-ietf-sidr-bgpsec-protocol (the -03 version). This document has significant changes from the (-02) version. Most, if not all of the changes were discussed at the Paris sidr meeting, so it probably isn't necessary to present them again. However, I would encourage anyone who is able to read Section 3 (the format for the BGPSEC_Path_Signatures attribute) of the -03 version before Vancouver. There may be places in the draft where the foolish document editor failed to produce text that reflects what the working group agreed to in Paris, and it would be good to get those issues (if they exist) resolved sooner rather than later. - Matt Lepinski Agenda deadline is Wed 23 Jun (day after tomorrow). Please send suggestions to the list. --Sandy, speaking as wg co-chair ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of Murphy, Sandra [Sandra.Murphy@sparta.com] Sent: Wednesday, May 16, 2012 6:05 PM To: sidr@ietf.org Subject: [sidr] request for agenda items for interim meeting 6 Jun Potential agenda items for the 6 Jun interim meeting. The agenda needs to be announced two weeks ahead of time, which is next Wednesday. Please send suggested topics to the list. Below are two suggestions to spark the discussion. (1) AS_PATH There was one agenda topic that we never directly addressed at the 30 Apr meeting. That topic was the absence of the AS_PATH attribute from the bgpsec protocol. (The info normally contained in the AS_PATH is contained in the bgpsec attributes.) The absence of the AS_PATH did come up in discussing other topics (see the minutes), but we did not discuss it directly. (2) router private key provisioning. In the interim in San Diego, there were requests (from operators) that guidance to operators of how to provision a router with the needed keys would be a good idea. We had some discussion in the Paris meeting of two drafts discussing provisioning the routers with their needed private keys. There's also been a recent flurry of discussion on the list. --Sandy, speaking as wg co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-4vKgsJaWxZJ_JAhjGt4IQPF06IE","title":"","text":"[sidr] Fwd: New Version Notification for\n draft-ietf-sidr-bgpsec-protocol-03.txt\nI have just submitted a revised -03 version of the core BGPSEC specification. This version incorporates the new format for the BGPSEC_Path_Signatures attribute and other changes that were discussed at the Paris IETF meeting. A known issue in the -03 version of this document is that it does not solve the confederation issue (which was discussed at the April 30 interim meeting). - Matt Lepinski -------- Original Message -------- Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-03.txt Date: Fri, 11 May 2012 11:19:58 -0700 From: internet-drafts@ietf.org To: mlepinski@bbn.com A new version of I-D, draft-ietf-sidr-bgpsec-protocol-03.txt has been successfully submitted by Matthew Lepinski and posted to the IETF repository. Filename: draft-ietf-sidr-bgpsec-protocol Revision: 03 Title: BGPSEC Protocol Specification Creation date: 2012-05-11 WG ID: sidr Number of pages: 31 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. The IETF Secretariat I have just submitted a revised -03 version of the core BGPSEC specification. This version incorporates the new format for the BGPSEC_Path_Signatures attribute and other changes that were discussed at the Paris IETF meeting. A known issue in the -03 version of this document is that it does not solve the confederation issue (which was discussed at the April 30 interim meeting). - Matt Lepinski -------- Original Message -------- Subject: New Version Notification for draft-ietf-sidr-bgpsec-protocol-03.txt Date: Fri, 11 May 2012 11:19:58 -0700 From: internet-drafts@ietf.org To: mlepinski@bbn.com A new version of I-D, draft-ietf-sidr-bgpsec-protocol-03.txt has been successfully submitted by Matthew Lepinski and posted to the IETF repository. Filename: draft-ietf-sidr-bgpsec-protocol Revision: 03 Title: BGPSEC Protocol Specification Creation date: 2012-05-11 WG ID: sidr Number of pages: 31 Abstract: This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. The IETF Secretariat"}
{"_id":"doc-en-sidr-NliUNPZqcdFPmiGLgXWF7FMLLdo","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-03.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-03.txt Pages : 31 Date : 2012-05-11 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-03.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-03.txt The IETF datatracker page for this Internet-Draft is: https:\/\/datatracker.ietf.org\/doc\/draft-ietf-sidr-bgpsec-protocol\/"}
{"_id":"doc-en-sidr-DCAXEhhYLeb2h_W8JYPWlTHWW54","title":"","text":"Re: [sidr] bgpsec-spec S. 4.2 comments\nthat's also flawed. You should be able to sign anything that you can. Suppose you receive it from an ibgp peer that sourced it but didn't sign it. -- Jakob Heitz. John Scudder asked the following question in an email to the authors of draft-ietf-sidr-bgpsec-protocol: From: John G. Scudder <jgs@juniper.net> Date: Wed, Apr 18, 2012 at 8:00 PM Subject: bgpsec-spec S. 4.2 comments A few misc questions\/comments I noticed while perusing S. 4.2: \"A BGPSEC speaker MUST NOT generate an update message containing the BGPSEC_Path_Signatures attribute unless it has selected, as the best route to the given prefix, a route that it received in an update message containing the BGPSEC_Path_Signatures attribute.\" What's the rationale for this MUST NOT? Certainly it's an assumption of the base protocol, but I assume it wouldn't need to be called out here unless it bore on some BGPSEC-specific issue. This is relevant in the context of draft-ietf-idr-add- paths, which allows non-best paths to be sent in BGP. The authors have agreed that the above text in the bgpsec spec document (quoted by John) certainly seems problematic. The authors agreed to make the following text substitution: (there was also consensus on this at the SIDR Interim meeting April 30, 2012): \"If a BGPSEC router has received an _unsigned_ route from a peer and if it chooses to propagate that route, then it MUST NOT attach any BGPSEC_Path_Signatures attribute to the corresponding update being propagated.\" It was also agreed that we further add (if not already clearly stated elsewhere in the spec): \"If a BGPSEC router has received a _signed_ update, and if it chooses to propagate that route, then the router SHOULD propagate the corresponding update with BGPSEC_Path_Signatures attribute (after adding its own signature).\" These substitutions would help keep the text unambiguous, and also inclusive of (or at least not conflicting with) draft-ietf-idr-add-paths. Sriram _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-EpFxjDLdWIE40Bkvau93ORugpAo","title":"","text":"[sidr] bgpsec-spec S. 4.2 comments\nJohn Scudder asked the following question in an email to the authors of draft-ietf-sidr-bgpsec-protocol: From: John G. Scudder <jgs@juniper.net> Date: Wed, Apr 18, 2012 at 8:00 PM Subject: bgpsec-spec S. 4.2 comments A few misc questions\/comments I noticed while perusing S. 4.2: \"A BGPSEC speaker MUST NOT generate an update message containing the BGPSEC_Path_Signatures attribute unless it has selected, as the best route to the given prefix, a route that it received in an update message containing the BGPSEC_Path_Signatures attribute.\" What's the rationale for this MUST NOT? Certainly it's an assumption of the base protocol, but I assume it wouldn't need to be called out here unless it bore on some BGPSEC-specific issue. This is relevant in the context of draft-ietf-idr-add- paths, which allows non-best paths to be sent in BGP. The authors have agreed that the above text in the bgpsec spec document (quoted by John) certainly seems problematic. The authors agreed to make the following text substitution: (there was also consensus on this at the SIDR Interim meeting April 30, 2012): \"If a BGPSEC router has received an _unsigned_ route from a peer and if it chooses to propagate that route, then it MUST NOT attach any BGPSEC_Path_Signatures attribute to the corresponding update being propagated.\" It was also agreed that we further add (if not already clearly stated elsewhere in the spec): \"If a BGPSEC router has received a _signed_ update, and if it chooses to propagate that route, then the router SHOULD propagate the corresponding update with BGPSEC_Path_Signatures attribute (after adding its own signature).\" These substitutions would help keep the text unambiguous, and also inclusive of (or at least not conflicting with) draft-ietf-idr-add-paths. Sriram"}
{"_id":"doc-en-sidr-SAPQTfFDs0uHXqcZBy8v9t2aZIw","title":"","text":"Re: [sidr] iBGP,\n BGPSEC and incremental deployment (was No BGPSEC intradomain ?)\nConfeds are out of scope. VPN address families are out of scope. If the BGPSEC path does not match the AS_PATH, the update is invalid. The validity of an update is used as an input to route selection. If you have been replace\/override\/removing ASNs, you are free to use that information in route selection too. IOW, the BGPSEC validity of an update does not necessarily prevent you from using the update if you have inside knowledge about AS path mucking. How you use the BGPSEC validity in your route selection is a private matter. On Wednesday, April 11, 2012 7:21 AM, Jeffrey Haas <> wrote: I'm not at my usual spot in the week to catch up on IETF mail, but this thread is noisy enough that it's caught my attention anyway. :-) I think that sone of the biggest issues to keep in mind with carrying the \"same\" data in two places is what to do when you suddenly discover that they are not actually the same? The apparent issue in this thread is basically, \"what happens to AS_PATH?\" Glancing at draft-ietf-sidr-bgpsec-protocol-02 (and not thoroughly reading it), there's commentary about what should be done with the AS_PATH. That commentary is mostly correct in the sense that all of the path loop detection is already present. (And the mostly is important.) IMO, there are two specific issues with regard to removing the AS_PATH and one with keeping it. 1. What do you do about confederations? These ASes are not only typically internal but would have to use some sort of internal certs if we decided to cover the confederation case. Additionally, the current encoding format doesn't include AS_PATH segment type as part of the signature. Note in particular that confederation segments MUST be stripped when crossing an eBGP boundary. 2. More generally, what do you do about incremental deployment *within* the AS? One presumption I've been working on that I *thought* was shared by the WG was that BGPSEC procedures only had to be done at eBGP edges. While this is primarily true for signature validation purposes, a desired side effect of having the signature as a optional,transitive that paralleled the AS_PATH was that iBGP speakers don't have to even be BGPSEC aware. This lets you upgrade your network from the outside first and get benefit. As John Scudder likes to say, \"a hard, crunchy shell\". :-) IMO, we should keep the AS_PATH. 3. Which brings us to the third point - what do we do when the signature and the AS_PATH disagree with each other? Note that this was also a problem for 4-byte ASes (RFC 4893). That spec chose to simply trust the 4-byte path beyond a certain point. (I don't necessarily agree with it, but that's what consensus was.) Exactly what we do here needs to be specified, and some of that specification will come from deciding what we want to do about some things. For example, we want to prevent the path from being shortened. As long as the ASes involved in both signature and path are congruent, we can use the length in the signature if the number of ASes in the path are shorter than the signature. In the case where the paths are still congruent but the AS_PATH has a longer prepend (see my ingress prepending use case from a few sessions back), it may be fine to use the AS_PATH (and its length for route selection purposes). Yes, I understand there isn't consensus here. In the case where the paths are not congruent (which shouldn't happen unlike the AS4_PATH case in RFC 4893 - we don't tunnel bgpsec across other BGP), we probably have some sort of hard error case. One reasonable assumption is that a non-BGPSEC speaker mucked with the AS_PATH - perhaps an iBGP speaker doing path manipulations for policy. IMO, the proper behavior here is to *not* propagate the route at a BGPSEC ASBR boundary; any BGP speaker that manipulates the AS_PATH in such a way as to break the congruency of ASes between AS_PATH and signature MUST be a BGPSEC speaker. The above still doesn't deal with common deployment considerations such as as-override, replace-as and remove-private. I see there's a thread about proxy signing and perhaps that discussion is over there. I'll hopefully get to it in a few days. (And if you're not familiar with those three features and their deployment scenarios, please take some time to become familiar. Not dealing with them will be a significant deployment hurdle.) -- Jeff -- Jakob Heitz."}
{"_id":"doc-en-sidr-TTl-eZvNBDzKp4L7pSjgA0NI1k4","title":"","text":"[sidr] iBGP,\n BGPSEC and incremental deployment (was No BGPSEC intradomain ?)\nI'm not at my usual spot in the week to catch up on IETF mail, but this thread is noisy enough that it's caught my attention anyway. :-) I think that sone of the biggest issues to keep in mind with carrying the \"same\" data in two places is what to do when you suddenly discover that they are not actually the same? The apparent issue in this thread is basically, \"what happens to AS_PATH?\" Glancing at draft-ietf-sidr-bgpsec-protocol-02 (and not thoroughly reading it), there's commentary about what should be done with the AS_PATH. That commentary is mostly correct in the sense that all of the path loop detection is already present. (And the mostly is important.) IMO, there are two specific issues with regard to removing the AS_PATH and one with keeping it. 1. What do you do about confederations? These ASes are not only typically internal but would have to use some sort of internal certs if we decided to cover the confederation case. Additionally, the current encoding format doesn't include AS_PATH segment type as part of the signature. Note in particular that confederation segments MUST be stripped when crossing an eBGP boundary. 2. More generally, what do you do about incremental deployment *within* the AS? One presumption I've been working on that I *thought* was shared by the WG was that BGPSEC procedures only had to be done at eBGP edges. While this is primarily true for signature validation purposes, a desired side effect of having the signature as a optional,transitive that paralleled the AS_PATH was that iBGP speakers don't have to even be BGPSEC aware. This lets you upgrade your network from the outside first and get benefit. As John Scudder likes to say, \"a hard, crunchy shell\". :-) IMO, we should keep the AS_PATH. 3. Which brings us to the third point - what do we do when the signature and the AS_PATH disagree with each other? Note that this was also a problem for 4-byte ASes (RFC 4893). That spec chose to simply trust the 4-byte path beyond a certain point. (I don't necessarily agree with it, but that's what consensus was.) Exactly what we do here needs to be specified, and some of that specification will come from deciding what we want to do about some things. For example, we want to prevent the path from being shortened. As long as the ASes involved in both signature and path are congruent, we can use the length in the signature if the number of ASes in the path are shorter than the signature. In the case where the paths are still congruent but the AS_PATH has a longer prepend (see my ingress prepending use case from a few sessions back), it may be fine to use the AS_PATH (and its length for route selection purposes). Yes, I understand there isn't consensus here. In the case where the paths are not congruent (which shouldn't happen unlike the AS4_PATH case in RFC 4893 - we don't tunnel bgpsec across other BGP), we probably have some sort of hard error case. One reasonable assumption is that a non-BGPSEC speaker mucked with the AS_PATH - perhaps an iBGP speaker doing path manipulations for policy. IMO, the proper behavior here is to *not* propagate the route at a BGPSEC ASBR boundary; any BGP speaker that manipulates the AS_PATH in such a way as to break the congruency of ASes between AS_PATH and signature MUST be a BGPSEC speaker. The above still doesn't deal with common deployment considerations such as as-override, replace-as and remove-private. I see there's a thread about proxy signing and perhaps that discussion is over there. I'll hopefully get to it in a few days. (And if you're not familiar with those three features and their deployment scenarios, please take some time to become familiar. Not dealing with them will be a significant deployment hurdle.) -- Jeff"}
{"_id":"doc-en-sidr-fx5aPwH--sKg1EBFgmjocHxxvXc","title":"","text":"Re: [sidr] [Idr] No BGPSEC intradomain ?\nHi, And intradomain BGP speakers do not use bgpsec (ebgp sessions only). I do not understand. How a BGP Update will transit via an AS where each router is a real BGP speaker and where as some proposed BGP mandatory AS_PATH attribute is not present ? The last sentence, it doesn't parse quite clearly for me... could you re-state it? Are you assuming each AS today is BGP Free with full mesh of MPLS\/IP tunnel ASBR to ASBR as transport ? Even in this case ASBRs are connected directly or indirectly (RRs) via IBGP. no assumption was made of this sort. As you proposing to remove AS_PATH selection criteria from best path for updates which come over IBGP ? What happens if you need to compare paths no received over EBGP and IBGP on a given BGP speaker ? I think what you want is actually sort of discussed in: <http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-4> -chris"}
{"_id":"doc-en-sidr-feJU--Od43bYjB8L1G4iNqgHlGQ","title":"","text":"Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nstill speaking as regular ol' member by \"no reverse direction\", it was in answer to your question \"What happens in the opposite direction ? \". I should have used your words exactly. I meant what I said in the second line I wrote. \"Incoming paths that are unsigned are not propagated by bgpsec speakers as signed paths.\". They are propagated as unsigned paths. So there's no need to try to produce signatures for unsigned paths. Routes that come in unsigned, stay unsigned. There is no loss of reachability, because the routes are propagated. --Sandy, speaking as regular ol' member ________________________________________ From: Robert Raszuk [robert@raszuk.net] Sent: Monday, April 09, 2012 1:22 PM To: Murphy, Sandra Cc: Sriram, Kotikalapudi; idr@ietf.org List; sidr@ietf.org Subject: Re: [Idr] [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening & lengthening Hi Sandy, There is no reverse direction. What do you mean there is no reverse direction ? Sriram said: \"When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island.\" That means that there is EBGP peering at the two ASes which on one side supports BGPSEC on the other does not. In order to establish any form of bidirectional communication sites on the left need to know how to reach sites on the right and vice versa. So your below \"Don't worry, no problem\" directly means \"no reachability\". I am afraid there is slight problem with that. Best regards, R. speaking as regular ol' member There is no reverse direction. Incoming paths that are unsigned are not propagated by bgpsec speakers as signed paths. And intradomain BGP speakers do not use bgpsec (ebgp sessions only). And AS4_PATH is not needed in bgpsec speakers - who are assumed to be 4-byte aware. So no need to worry about ASBRs, flag days, etc. Don't worry, no problem. --Sandy, speaking as regular ol' member. ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of Robert Raszuk [robert@raszuk.net] Sent: Monday, April 09, 2012 12:29 PM To: Sriram, Kotikalapudi Cc: idr@ietf.org List; sidr@ietf.org Subject: Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Hi Sriram, When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. What happens in the opposite direction ? How AS_PATH\/AS4_PATH can be converted to BGPSEC_Path_Signatures without all necessary information present at the ASBR at any arbitrary Autonomous System ? Are you going to propose NULL signatures ? How are you planning on a flag date where all ASBRs in the Internet are BGPSEC complaint ? Why one needs to upgrade also all P routers (intra domain BGP speakers) to be BGPSEC complaint provided he is not using BGP as an overlay today? If you think removal of AS_PATH\/AS4_PATH is helpful in any way the much simpler would be to define new set of AFIs and call it \"SECURED\" leaving current AFI 1 and AFI 2 unchanged BGP protocol wise. Thx, R. The updates in a BGPSEC island can be BGPSEC (i.e., signed) or BGP-4 (i.e., unsigned). In either case, the update necessarily has AS-path info. If the update is BGP-4 (i.e., unsigned), it has the BGP-4 AS_PATH (mandatory) in it. If the update is BGPSEC (i.e., signed), then it MUST have the \"Secure Path\" in it. The Secure Path is in the form of {ASN1, pCount1, ASN2, pCount2, ...., ASN-k, pCount-k}. Please refer to slide 8 in Matt's presentation (BGPSEC Protocol) in Paris. The Secure Path is semantically equivalent to the BGP-4 AS_PATH. When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. Any prepend ASN that was collapsed in BGPSEC will be repeated pCount number of times, and any transparent route server ASN (with pCount=0) in BGPSEC will be removed. Is this semantic equivalence (of the Secure Path) and the guarantee of convertibility to BGP-4 AS_PATH not enough? Should we really require in BGPSEC that the BGP-4 AS_PATH be carried (in a pristine way) in addition to the Secure Path, albeit at the cost of duplication and associated processing cost\/confusion? Just a honest question seeking people's opinion. Sriram -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Robert Raszuk Sent: Monday, April 09, 2012 3:19 AM To: sidr@ietf.org Cc: idr@ietf.org List Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Your analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R."}
{"_id":"doc-en-sidr-ovFW3X5YQhMyQIbsdFgFkZ-ImtI","title":"","text":"Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nHi Sandy, There is no reverse direction. What do you mean there is no reverse direction ? Sriram said: \"When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island.\" That means that there is EBGP peering at the two ASes which on one side supports BGPSEC on the other does not. In order to establish any form of bidirectional communication sites on the left need to know how to reach sites on the right and vice versa. So your below \"Don't worry, no problem\" directly means \"no reachability\". I am afraid there is slight problem with that. Best regards, R. speaking as regular ol' member There is no reverse direction. Incoming paths that are unsigned are not propagated by bgpsec speakers as signed paths. And intradomain BGP speakers do not use bgpsec (ebgp sessions only). And AS4_PATH is not needed in bgpsec speakers - who are assumed to be 4-byte aware. So no need to worry about ASBRs, flag days, etc. Don't worry, no problem. --Sandy, speaking as regular ol' member. ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of Robert Raszuk [robert@raszuk.net] Sent: Monday, April 09, 2012 12:29 PM To: Sriram, Kotikalapudi Cc: idr@ietf.org List; sidr@ietf.org Subject: Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Hi Sriram, When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. What happens in the opposite direction ? How AS_PATH\/AS4_PATH can be converted to BGPSEC_Path_Signatures without all necessary information present at the ASBR at any arbitrary Autonomous System ? Are you going to propose NULL signatures ? How are you planning on a flag date where all ASBRs in the Internet are BGPSEC complaint ? Why one needs to upgrade also all P routers (intra domain BGP speakers) to be BGPSEC complaint provided he is not using BGP as an overlay today? If you think removal of AS_PATH\/AS4_PATH is helpful in any way the much simpler would be to define new set of AFIs and call it \"SECURED\" leaving current AFI 1 and AFI 2 unchanged BGP protocol wise. Thx, R. The updates in a BGPSEC island can be BGPSEC (i.e., signed) or BGP-4 (i.e., unsigned). In either case, the update necessarily has AS-path info. If the update is BGP-4 (i.e., unsigned), it has the BGP-4 AS_PATH (mandatory) in it. If the update is BGPSEC (i.e., signed), then it MUST have the \"Secure Path\" in it. The Secure Path is in the form of {ASN1, pCount1, ASN2, pCount2, ...., ASN-k, pCount-k}. Please refer to slide 8 in Matt's presentation (BGPSEC Protocol) in Paris. The Secure Path is semantically equivalent to the BGP-4 AS_PATH. When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. Any prepend ASN that was collapsed in BGPSEC will be repeated pCount number of times, and any transparent route server ASN (with pCount=0) in BGPSEC will be removed. Is this semantic equivalence (of the Secure Path) and the guarantee of convertibility to BGP-4 AS_PATH not enough? Should we really require in BGPSEC that the BGP-4 AS_PATH be carried (in a pristine way) in addition to the Secure Path, albeit at the cost of duplication and associated processing cost\/confusion? Just a honest question seeking people's opinion. Sriram -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Robert Raszuk Sent: Monday, April 09, 2012 3:19 AM To: sidr@ietf.org Cc: idr@ietf.org List Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Your analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R."}
{"_id":"doc-en-sidr-pxI_LF5IUpUu173TgSBWTYmiBAg","title":"","text":"Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nspeaking as regular ol' member There is no reverse direction. Incoming paths that are unsigned are not propagated by bgpsec speakers as signed paths. And intradomain BGP speakers do not use bgpsec (ebgp sessions only). And AS4_PATH is not needed in bgpsec speakers - who are assumed to be 4-byte aware. So no need to worry about ASBRs, flag days, etc. Don't worry, no problem. --Sandy, speaking as regular ol' member. ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of Robert Raszuk [robert@raszuk.net] Sent: Monday, April 09, 2012 12:29 PM To: Sriram, Kotikalapudi Cc: idr@ietf.org List; sidr@ietf.org Subject: Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening & lengthening Hi Sriram, > When the update is to leave a BGPSEC island to go to a BGP-4 only AS, > then the Secure Path is easily converted to BGP-4 AS_PATH at the edge > of the BGPSEC island. What happens in the opposite direction ? How AS_PATH\/AS4_PATH can be converted to BGPSEC_Path_Signatures without all necessary information present at the ASBR at any arbitrary Autonomous System ? Are you going to propose NULL signatures ? How are you planning on a flag date where all ASBRs in the Internet are BGPSEC complaint ? Why one needs to upgrade also all P routers (intra domain BGP speakers) to be BGPSEC complaint provided he is not using BGP as an overlay today? If you think removal of AS_PATH\/AS4_PATH is helpful in any way the much simpler would be to define new set of AFIs and call it \"SECURED\" leaving current AFI 1 and AFI 2 unchanged BGP protocol wise. Thx, R. The updates in a BGPSEC island can be BGPSEC (i.e., signed) or BGP-4 (i.e., unsigned). In either case, the update necessarily has AS-path info. If the update is BGP-4 (i.e., unsigned), it has the BGP-4 AS_PATH (mandatory) in it. If the update is BGPSEC (i.e., signed), then it MUST have the \"Secure Path\" in it. The Secure Path is in the form of {ASN1, pCount1, ASN2, pCount2, ...., ASN-k, pCount-k}. Please refer to slide 8 in Matt's presentation (BGPSEC Protocol) in Paris. The Secure Path is semantically equivalent to the BGP-4 AS_PATH. When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. Any prepend ASN that was collapsed in BGPSEC will be repeated pCount number of times, and any transparent route server ASN (with pCount=0) in BGPSEC will be removed. Is this semantic equivalence (of the Secure Path) and the guarantee of convertibility to BGP-4 AS_PATH not enough? Should we really require in BGPSEC that the BGP-4 AS_PATH be carried (in a pristine way) in addition to the Secure Path, albeit at the cost of duplication and associated processing cost\/confusion? Just a honest question seeking people's opinion. Sriram -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Robert Raszuk Sent: Monday, April 09, 2012 3:19 AM To: sidr@ietf.org Cc: idr@ietf.org List Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Your analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R. _______________________________________________ Idr mailing list Idr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/idr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-XnZ7NG1nOZ8t1j9JyULY7GBt-60","title":"","text":"Re: [sidr] [Idr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nHi Sriram, > When the update is to leave a BGPSEC island to go to a BGP-4 only AS, > then the Secure Path is easily converted to BGP-4 AS_PATH at the edge > of the BGPSEC island. What happens in the opposite direction ? How AS_PATH\/AS4_PATH can be converted to BGPSEC_Path_Signatures without all necessary information present at the ASBR at any arbitrary Autonomous System ? Are you going to propose NULL signatures ? How are you planning on a flag date where all ASBRs in the Internet are BGPSEC complaint ? Why one needs to upgrade also all P routers (intra domain BGP speakers) to be BGPSEC complaint provided he is not using BGP as an overlay today? If you think removal of AS_PATH\/AS4_PATH is helpful in any way the much simpler would be to define new set of AFIs and call it \"SECURED\" leaving current AFI 1 and AFI 2 unchanged BGP protocol wise. Thx, R. The updates in a BGPSEC island can be BGPSEC (i.e., signed) or BGP-4 (i.e., unsigned). In either case, the update necessarily has AS-path info. If the update is BGP-4 (i.e., unsigned), it has the BGP-4 AS_PATH (mandatory) in it. If the update is BGPSEC (i.e., signed), then it MUST have the \"Secure Path\" in it. The Secure Path is in the form of {ASN1, pCount1, ASN2, pCount2, ...., ASN-k, pCount-k}. Please refer to slide 8 in Matt's presentation (BGPSEC Protocol) in Paris. The Secure Path is semantically equivalent to the BGP-4 AS_PATH. When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. Any prepend ASN that was collapsed in BGPSEC will be repeated pCount number of times, and any transparent route server ASN (with pCount=0) in BGPSEC will be removed. Is this semantic equivalence (of the Secure Path) and the guarantee of convertibility to BGP-4 AS_PATH not enough? Should we really require in BGPSEC that the BGP-4 AS_PATH be carried (in a pristine way) in addition to the Secure Path, albeit at the cost of duplication and associated processing cost\/confusion? Just a honest question seeking people's opinion. Sriram -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Robert Raszuk Sent: Monday, April 09, 2012 3:19 AM To: sidr@ietf.org Cc: idr@ietf.org List Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening& lengthening Your analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R. _______________________________________________ Idr mailing list Idr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/idr"}
{"_id":"doc-en-sidr-JdcWBz0sAcG21eosNkEJAxdPK7Y","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nThe updates in a BGPSEC island can be BGPSEC (i.e., signed) or BGP-4 (i.e., unsigned). In either case, the update necessarily has AS-path info. If the update is BGP-4 (i.e., unsigned), it has the BGP-4 AS_PATH (mandatory) in it. If the update is BGPSEC (i.e., signed), then it MUST have the \"Secure Path\" in it. The Secure Path is in the form of {ASN1, pCount1, ASN2, pCount2, ...., ASN-k, pCount-k}. Please refer to slide 8 in Matt's presentation (BGPSEC Protocol) in Paris. The Secure Path is semantically equivalent to the BGP-4 AS_PATH. When the update is to leave a BGPSEC island to go to a BGP-4 only AS, then the Secure Path is easily converted to BGP-4 AS_PATH at the edge of the BGPSEC island. Any prepend ASN that was collapsed in BGPSEC will be repeated pCount number of times, and any transparent route server ASN (with pCount=0) in BGPSEC will be removed. Is this semantic equivalence (of the Secure Path) and the guarantee of convertibility to BGP-4 AS_PATH not enough? Should we really require in BGPSEC that the BGP-4 AS_PATH be carried (in a pristine way) in addition to the Secure Path, albeit at the cost of duplication and associated processing cost\/confusion? Just a honest question seeking people's opinion. Sriram -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Robert Raszuk Sent: Monday, April 09, 2012 3:19 AM To: sidr@ietf.org Cc: idr@ietf.org List Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening & lengthening Your analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R."}
{"_id":"doc-en-sidr-fe1lC8ZZh5sEZKIEDH10W_tiyuo","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening &\n lengthening\nYour analysis assumes that there a conventional BGP-4 AS_PATH field and then there is is BGPSEC_Path_Signatures from which AS path info can be inferred separately. This is not true in the latest BGPSEC update format as Matt presented it in Paris. How an optional attribute replace well-known mandatory one ? Sorry but for such step formal IDR WG approval is necessary if you choose to propose BGPSEC_Path_Signatures as mandatory attribute. This is major BGP protocol change. Documentation of partial deployment is required as well as two interoperable implementations ;). RFC4271: 5.1.2. AS_PATH AS_PATH is a well-known mandatory attribute. This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. The components of this list can be AS_SETs or AS_SEQUENCEs. draft-ietf-sidr-bgpsec-protocol-02.txt This document specifies a new optional (non-transitive) BGP path attribute, BGPSEC_Path_Signatures. Best regards, R."}
{"_id":"doc-en-sidr-bSCk9oNRFzrK44lvXRD7JPtr8dg","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening\n &\tlengthening\nSpeaking as regular ol' member Shane, I'm having some trouble following your argument. Here's what I think you are saying. You are exploring options for dropping an update based on detecting a loop - whether the loop detection should be before or after the check of the path signatures. If you do the loop detection first, you say, that's a potential dos attack, because.... \"But the problem is: how do you know it's *not* \"legitimate reachability info\" if you've (only) based the decision to drop the UPDATE based on unverified info in the AS_PATH attribute? If you do, that's a _threat_ of a DoS attack, which presumably the whole point of BGPSEC is designed to protect against.\" And that's where I lose you. I don't see why detecting the loop first provides a dos attack Case 1: If the update has actually looped, then dropping the update because of loop detection is just fine. Case 2: If the update has not actually looped, then someone has managed to inject an AS (yours) into the AS_PATH *illegitimately* (the update did not actually go trough your AS). So dropping the update is just fine here also, because this is an attack. In this case, testing the bgpsec signatures will necessarily fail. So dropping the update because of loop detection is not a denial of service. Whether you do loop detection first or bgpsec signature test first, the update will be dropped. So where's the dos attack? (Do note that the bgpsec signatures would detect this at the first point that checked the signatures, so your neighbor would have spotted the injection - unless it was the source of the injection.) --Sandy, regular ol' member ________________________________________ From: sidr-bounces@ietf.org [sidr-bounces@ietf.org] on behalf of Shane Amante [shane@castlepoint.net] Sent: Friday, April 06, 2012 1:02 PM To: Andrew Chi Cc: sidr wg list Subject: Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening & lengthening On Apr 6, 2012, at 10:20 AM, Andrew Chi wrote: a) BGP performs loop detection on the AS_PATH attribute *before* verifying any BGPSEC_Path_Signature, in which case you drop the UPDATE, thus causing a DoS because you're not propagating what *may* be legitimate reachability info further downstream. Right, I'm familiar with loop detection and K\/P. If someone has modified AS_PATH to cause another AS to drop it, then they inserted someone else's AS. This no longer counts as \"legitimate reachability info\", and therefore it should be dropped, and the sooner the better. But the problem is: how do you know it's *not* \"legitimate reachability info\" if you've (only) based the decision to drop the UPDATE based on unverified info in the AS_PATH attribute? If you do, that's a _threat_ of a DoS attack, which presumably the whole point of BGPSEC is designed to protect against. At some point in the future, the SIDR WG will resolve *how* it's going to prescribe that BGP loop detection is supposed to work. Either way, it needs to acknowledge there are two types of potential threats: a) Use unverified AS_PATH info for loop detection; or, b) Use verified BGPSEC_Path_Signature info for loop detection. Ultimately, if the SIDR WG prescription *eventually* resolves that loop detection is only going to be performed on the BGPSEC_Path_Signature attribute, then the text in sidr-threats can be modified, at that future point in time, to say something like: - Attacks against BGP loop detection are mitigated by only using verified info on the path from reconstruction of the path in BGPSEC_Path_Signature; however, - This has the potential to introduce a DoS on the BGP control plane itself, either through normal operation (high churn) or an operator injecting false UPDATE's, into the system, which exceed the capacity of routers to perform crypto verification fast enough ... It sounds like there's another issue mixed up in here (but perhaps not in scope of the -bgpsec-threats document): you're trying to resolve the ambiguity on what to do with AS_PATH, as Matt notes at the end of the following section. http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5 EDITOR'S NOTE: Text will be inserted here for dealing with the AS_PATH attribute. Note that the BGPGSEC_Path_Signatures attribute now contains all of the information needed to construct the AS_PATH attribute. Therefore, there seem to be two options. One option the BGPSEC speaker checks the AS_PATH attribute against the information in the BGPSEC_Path_Signatures attribute and returns \"Not Good\" if the two do not match. The other option is that the BGPSEC speaker discards anything in the AS_PATH attribute and reconstructs the AS_PATH from the data in the BGPSEC_Path_Signatures attribute. I believe that there are no interoperability problems if the choice between these two options is left up to the BGPSEC speaker. Given the above, then I suggest the next revision of draft-ietf-sidr-bgpsec-protocol explicitly says: \"Updates: RFC 4271\" and that future updates of draft-ietf-sidr-bgpsec-protocol start to be shared with IDR WG mailing list, (particularly in light of discussions at the recent IDR WG meeting where the SIDR co-chairs have pointed out the need for cooperation between SIDR & IDR). I do not believe that the SIDR WG is in a position to make a call as to whether, or to what extent, there are going to be interoperability concerns with legacy, non-BGPSEC capable routers wrt AS_PATH loop detection ... IMO, that should be the responsibility and call of the IDR WG. b) BGP performs loop detection on the AS_PATH attribute only \/after\/ verifying the BGPSEC_Path_Signature is valid, in which case there is a \/potential\/ for another type of DoS, because there will always be a limited amount of crypto verifications\/sec that can be performed. There's also the concern that this will slow down propagation of reachability information, because it first needs to be crypto-verified before it's used\/propagated. Note, this is unlikely to be a problem during \"steady-state\", but is more likely to appear during some amount of churn in BGP due to link and\/or router failures, for example. Yes, this is true -- there's always DoS by feeding garbage to your neighbor, BGPSEC or not, but crypto lets you waste more CPU. DoS on a BGP router is mentioned briefly at the end of 4.1 -- would you like more text? Yes. I think the text \"... DoS attacks against BGP routers\" is extremely vague, because there are two things that come to mind: a) A packet DDoS attack against the router, which may not have anything to do with the BGP control plane itself -- i.e.: some attacker trying to overwhelm links with too much traffic causing [severe] packet loss; and, b) A DoS attack against the actual BGP _control_plane_ itself. More specifically, threats that either: i) overwhelm the I\/O, CPU (and\/or, memory) capabilities of the BGP router; and, ii) in the future, overwhelm a new component, namely, the crypto verification capabilities of the BGP protocol. I care about the latter (b), in the context of the SIDR WG, and I believe that is what the current text in Section 4.1 is attempting to say, just not well enough, yet. Thanks, -shane _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-WlTLqLQSqluaHTZKtnJjj3DU7kE","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening &\n lengthening\nOn Apr 6, 2012, at 10:20 AM, Andrew Chi wrote: a) BGP performs loop detection on the AS_PATH attribute *before* verifying any BGPSEC_Path_Signature, in which case you drop the UPDATE, thus causing a DoS because you're not propagating what *may* be legitimate reachability info further downstream. Right, I'm familiar with loop detection and K\/P. If someone has modified AS_PATH to cause another AS to drop it, then they inserted someone else's AS. This no longer counts as \"legitimate reachability info\", and therefore it should be dropped, and the sooner the better. But the problem is: how do you know it's *not* \"legitimate reachability info\" if you've (only) based the decision to drop the UPDATE based on unverified info in the AS_PATH attribute? If you do, that's a _threat_ of a DoS attack, which presumably the whole point of BGPSEC is designed to protect against. At some point in the future, the SIDR WG will resolve *how* it's going to prescribe that BGP loop detection is supposed to work. Either way, it needs to acknowledge there are two types of potential threats: a) Use unverified AS_PATH info for loop detection; or, b) Use verified BGPSEC_Path_Signature info for loop detection. Ultimately, if the SIDR WG prescription *eventually* resolves that loop detection is only going to be performed on the BGPSEC_Path_Signature attribute, then the text in sidr-threats can be modified, at that future point in time, to say something like: - Attacks against BGP loop detection are mitigated by only using verified info on the path from reconstruction of the path in BGPSEC_Path_Signature; however, - This has the potential to introduce a DoS on the BGP control plane itself, either through normal operation (high churn) or an operator injecting false UPDATE's, into the system, which exceed the capacity of routers to perform crypto verification fast enough ... It sounds like there's another issue mixed up in here (but perhaps not in scope of the -bgpsec-threats document): you're trying to resolve the ambiguity on what to do with AS_PATH, as Matt notes at the end of the following section. http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5 EDITOR'S NOTE: Text will be inserted here for dealing with the AS_PATH attribute. Note that the BGPGSEC_Path_Signatures attribute now contains all of the information needed to construct the AS_PATH attribute. Therefore, there seem to be two options. One option the BGPSEC speaker checks the AS_PATH attribute against the information in the BGPSEC_Path_Signatures attribute and returns \"Not Good\" if the two do not match. The other option is that the BGPSEC speaker discards anything in the AS_PATH attribute and reconstructs the AS_PATH from the data in the BGPSEC_Path_Signatures attribute. I believe that there are no interoperability problems if the choice between these two options is left up to the BGPSEC speaker. Given the above, then I suggest the next revision of draft-ietf-sidr-bgpsec-protocol explicitly says: \"Updates: RFC 4271\" and that future updates of draft-ietf-sidr-bgpsec-protocol start to be shared with IDR WG mailing list, (particularly in light of discussions at the recent IDR WG meeting where the SIDR co-chairs have pointed out the need for cooperation between SIDR & IDR). I do not believe that the SIDR WG is in a position to make a call as to whether, or to what extent, there are going to be interoperability concerns with legacy, non-BGPSEC capable routers wrt AS_PATH loop detection ... IMO, that should be the responsibility and call of the IDR WG. b) BGP performs loop detection on the AS_PATH attribute only \/after\/ verifying the BGPSEC_Path_Signature is valid, in which case there is a \/potential\/ for another type of DoS, because there will always be a limited amount of crypto verifications\/sec that can be performed. There's also the concern that this will slow down propagation of reachability information, because it first needs to be crypto-verified before it's used\/propagated. Note, this is unlikely to be a problem during \"steady-state\", but is more likely to appear during some amount of churn in BGP due to link and\/or router failures, for example. Yes, this is true -- there's always DoS by feeding garbage to your neighbor, BGPSEC or not, but crypto lets you waste more CPU. DoS on a BGP router is mentioned briefly at the end of 4.1 -- would you like more text? Yes. I think the text \"... DoS attacks against BGP routers\" is extremely vague, because there are two things that come to mind: a) A packet DDoS attack against the router, which may not have anything to do with the BGP control plane itself -- i.e.: some attacker trying to overwhelm links with too much traffic causing [severe] packet loss; and, b) A DoS attack against the actual BGP _control_plane_ itself. More specifically, threats that either: i) overwhelm the I\/O, CPU (and\/or, memory) capabilities of the BGP router; and, ii) in the future, overwhelm a new component, namely, the crypto verification capabilities of the BGP protocol. I care about the latter (b), in the context of the SIDR WG, and I believe that is what the current text in Section 4.1 is attempting to say, just not well enough, yet. Thanks, -shane"}
{"_id":"doc-en-sidr-EYeSsywbXx_FbN2CyCHT-N96wuI","title":"","text":"Re: [sidr] draft-ietf-sidr-bgpsec-threats-02: Path shortening &\n lengthening\na) BGP performs loop detection on the AS_PATH attribute *before* verifying any BGPSEC_Path_Signature, in which case you drop the UPDATE, thus causing a DoS because you're not propagating what *may* be legitimate reachability info further downstream. Right, I'm familiar with loop detection and K\/P. If someone has modified AS_PATH to cause another AS to drop it, then they inserted someone else's AS. This no longer counts as \"legitimate reachability info\", and therefore it should be dropped, and the sooner the better. It sounds like there's another issue mixed up in here (but perhaps not in scope of the -bgpsec-threats document): you're trying to resolve the ambiguity on what to do with AS_PATH, as Matt notes at the end of the following section. http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5 EDITOR'S NOTE: Text will be inserted here for dealing with the AS_PATH attribute. Note that the BGPGSEC_Path_Signatures attribute now contains all of the information needed to construct the AS_PATH attribute. Therefore, there seem to be two options. One option the BGPSEC speaker checks the AS_PATH attribute against the information in the BGPSEC_Path_Signatures attribute and returns \"Not Good\" if the two do not match. The other option is that the BGPSEC speaker discards anything in the AS_PATH attribute and reconstructs the AS_PATH from the data in the BGPSEC_Path_Signatures attribute. I believe that there are no interoperability problems if the choice between these two options is left up to the BGPSEC speaker. b) BGP performs loop detection on the AS_PATH attribute only \/after\/ verifying the BGPSEC_Path_Signature is valid, in which case there is a \/potential\/ for another type of DoS, because there will always be a limited amount of crypto verifications\/sec that can be performed. There's also the concern that this will slow down propagation of reachability information, because it first needs to be crypto-verified before it's used\/propagated. Note, this is unlikely to be a problem during \"steady-state\", but is more likely to appear during some amount of churn in BGP due to link and\/or router failures, for example. Yes, this is true -- there's always DoS by feeding garbage to your neighbor, BGPSEC or not, but crypto lets you waste more CPU. DoS on a BGP router is mentioned briefly at the end of 4.1 -- would you like more text?"}
{"_id":"doc-en-sidr-v-j5z8-VaZEwtpDDi4vSgEB6E9E","title":"","text":"Re: [sidr] stub AS and proxy signing\nBrian, I hope you agree with me and Sandy that your questions (in the thread re: draft-ietf-sidr-usecases-03) were really about proxy signing for the stub origin AS, and not about use cases for “prefix-origin validation”. That is why I have started this different thread (with changed subject line). The author team (and contributors) of draft-ietf-sidr-bgpsec-protocol document discussed stub ASs and proxy signing by transit provider (upstream AS) at length, and those discussions are documented in: http:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-01 Please see sections 6.5 and 6.6. Also, please see Section 6 (Considerations for Edge Sites) in the bgpsec-ops document http:\/\/tools.ietf.org\/html\/draft-ymbk-bgpsec-ops-01 “Thus a smallish edge router may hold only its own signing key(s) and sign it's announcement but not receive signed announcements and therefore not need to deal with the majority of the RPKI.” Sharing the stub’s private key with the upstream transit provider is considered a bad practice. Instead, the stub can simply only sign its prefix(es) to the upstream AS and receive only unsigned updates from that upstream AS. This requires minimal SW upgrade, and no HW upgrade in stub ASs. I hope this helps address your questions. Sriram From: Brian Dickson [brian.peter.dickson at gmail.com] Sent: Friday, March 30, 2012 8:55 AM To: Murphy, Sandra Cc: Christopher Morrow; Sriram, Kotikalapudi; Chris Morrow; sidr at ietf.org list Subject: Re: [sidr] I-D Action: draft-ietf-sidr-usecases-03.txt Sandy, The use case example I included, is an origin validation use case. The problem is the inability to have \"origination\" (signed injection into BGPSEC) done by proxy, at all or especially by more than one party. The particular situation leading to the need for this, would be a stub AS whose router vendor does not support BGPSEC, or whose router hardware or code base is not included in BGPSEC support by their router vendor. (Doing a forklift upgrade to do BGPSEC is generally seen as #FAIL by operators.) This is likely to be a fairly common situation _among stub AS_ and, given the current requirement for origin injection for BGPSEC, addressing this _may_ impact the use cases document, for _origin validation_. I'm just saying... Brian"}
{"_id":"doc-en-sidr-l4rC7fbrM-lBGRPbVqFot4eW-p0","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-algs-01.txt\nChris, I think this draft should probably go in a cluster. There are normative references to draft-sidr-bgpsec-pki-profiles and draft-ietf-sidr-bgpsec-protocol. However, you could WGLC this draft because unless you're planning on changing the alg (ECDSA) there's really no dependencies on the other drafts. In other words, if you change bgpsec or the cert profile to add\/remove fields them really doesn't affect this draft. It could then just wait on the protocol to go forward in a sensible cluster. There's two tweaks I'd do before a WGLC and barring any other changes: 1. s3: r\/The RSA key pairs\/The key pairs I'd do this because RSA might not be the alg used in the RPKI later. It's helping to future proof this draft. 2. s11.1: Update references to [ID.sidr-res-cert-profile] and [ID.sidr-rpki-algs] to the appropriate RFC #s. Why don't I go ahead and post a new version to fix these two points and then you & Sandy can decide whether to start the WGLC button. spt On 3\/28\/12 2:23 PM, Christopher Morrow wrote: Sean, This document seems settled, should we WGLC this in the near future? -chris <cochair> A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGP Algorithms, Key Formats,& Signature Formats Author(s) : Sean Turner Filename : draft-ietf-sidr-bgpsec-algs-01.txt Pages : 7 Date : 2011-12-05 This document specifies the algorithms, algorithms' parameters, asymmetric key formats, asymmetric key size and signature format used in BGPSEC (Border Gateway Protocol Security). This document updates the Profile for Algorithms and Key Sizes for use in the Resource Public Key Infrastructure (draft-ietf-sidr-rpki-algs). A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-algs-01.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-algs-01.txt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-O9t87de9lTn8LY-edKYgeT_1vU0","title":"","text":"Re: [sidr] Signed vs unsgned and bgp best path decision\nWhen compared to what is today I don't think folks are mandated by any RFC to make a choice between two attributes which carry the same metric to decide which one should win on a per AS basis. they are not, and in the future the 'mandate' is I believe a 'SHOULD', not a 'MUST' so not really a 'mandate', but a 'suggestion', eh? It seems that the intent of the effort here is really just to provide an informational blob to the operators which they can use as they see fit... much like other optional transitive attributes today. Ok that sounds very reasonable indeed. progress! However number of folks have stated that bgpsec protocol proposal calls for replacing AS-PATH and AS4_PATH attributes with BGPSEC_Path_Sig attribute. In particular this text from \/draft-ietf-sidr-bgpsec-protocol-02 sort of suggests that: The other option is that the BGPSEC speaker 'other option' discards anything in the AS_PATH attribute and reconstructs the I believe this means: \"You could just ignore AS_PATH and reconstruct the content there from ...\" (or that's how I read the clipping) AS_PATH from the data in the BGPSEC_Path_Signatures attribute. I believe that there are no interoperability problems if the choice between these two options is left up to the BGPSEC speaker. probably in this last sentence they mean \"bgpsec listener\" (since this is on the receiver, not the sender?) Also it says in the same section 5: One option the 'option' BGPSEC speaker checks the AS_PATH attribute against the information in the BGPSEC_Path_Signatures attribute and returns \"Not Good\" if the two do not match. That means that if AS_PATH for example contains AS_SET that someone doing BGP multipath (across non identical paths) has correctly inserted into AS_PATH or as mentioned before did replace-as the update will be dropped as BGPSEC just can not handle those .... sure. 'option' I don't think if there were an AS_SET in the update coming from the BGPSEC speaking peer there would be sig parts to worry about (since the inclusion of AS_SET means you can't secure the path...So, I suppose if this condition exists the path is invalid by default? and likely spoof\/bad\/malicious?) Meta question: Can optional attribute result in such drastic actions (nothing to do with operator's choice of local behavior) against mandatory attribute(s) ? I think you created a situation which is actually in violation of the standard... or which would be seen as a malicious update and which should be dropped, so I'm not sure your meta-question follows properly here? -chris"}
{"_id":"doc-en-sidr-cMbXOrcu2O8p8BTZvCaWsHC7Kbo","title":"","text":"Re: [sidr] Signed vs unsgned and bgp best path decision\nWhen compared to what is today I don't think folks are mandated by any RFC to make a choice between two attributes which carry the same metric to decide which one should win on a per AS basis. they are not, and in the future the 'mandate' is I believe a 'SHOULD', not a 'MUST' so not really a 'mandate', but a 'suggestion', eh? It seems that the intent of the effort here is really just to provide an informational blob to the operators which they can use as they see fit... much like other optional transitive attributes today. Ok that sounds very reasonable indeed. However number of folks have stated that bgpsec protocol proposal calls for replacing AS-PATH and AS4_PATH attributes with BGPSEC_Path_Sig attribute. In particular this text from \/draft-ietf-sidr-bgpsec-protocol-02 sort of suggests that: The other option is that the BGPSEC speaker discards anything in the AS_PATH attribute and reconstructs the AS_PATH from the data in the BGPSEC_Path_Signatures attribute. I believe that there are no interoperability problems if the choice between these two options is left up to the BGPSEC speaker. Also it says in the same section 5: One option the BGPSEC speaker checks the AS_PATH attribute against the information in the BGPSEC_Path_Signatures attribute and returns \"Not Good\" if the two do not match. That means that if AS_PATH for example contains AS_SET that someone doing BGP multipath (across non identical paths) has correctly inserted into AS_PATH or as mentioned before did replace-as the update will be dropped as BGPSEC just can not handle those .... Meta question: Can optional attribute result in such drastic actions (nothing to do with operator's choice of local behavior) against mandatory attribute(s) ? Best, R."}
{"_id":"doc-en-sidr-e3KNNTzunuqFQQsfS3NbkT8bfZw","title":"","text":"Re: [sidr] route leaks message to IDR\nSorry, my bad. I somehow thought you were talking about two different PATH elements in the same update. That assumption made your questions sound bizarre. I am sure my misunderstanding made my answers sound equally bizarre. So, yes if they are different updates for the same prefix received from different peers ... Then of course this will happen all the time. As for if you somehow prefer the signed path over the unsigned path, in the end that is a local decision. I think there is\/will be strong wording that one SHOULD choose the signed and valid path because at the moment there is no explicit way of distinguishing that a path should have been signed, and as a result, there is a simple downgrade attack to strip the PATHSIG, if one is not strictly preferring signed over unsigned paths. One could think of fixing this, by having AS's push and object in the RPKI that says \"I am signing my paths\", then it would be possible to detect the simple downgrade attack. I guess one might think of AS_CERTS as such a signal, but that is a bit problematic WRT timing issues. The right way to do it would be some other explicit object. Anyway, to answer your question below, one SHOULD choose the second path, but I doubt the specs will ever say you MUST choose the second path. dougm -- Doug Montgomery ­ Mgr. Internet & Scalable Systems Research \/ ITL \/ NIST On 3\/21\/12 7:11 PM, \"Robert Raszuk\" <robert@raszuk.net> wrote: Maybe there is misunderstanding ... Chris example was stating: 1) first path gets evaluated, is it 'good' (next-hop reachable, not discarded by prefix-list\/etc) 2) second path gets evaluated, is it 'good' (same as above + origin-validate + path-validation) One path comes without signature the other one with signature .. AS PATHs they traverse is disjoined at some point. Are you saying this can not happen ? Many thx, R. What happens in your example if singed comes with PATH_SIG listing 4 ASes (pCount=1 of each) and real AS_PATH is length of 3 ? so, pcount I'm not a fan of.... but, you're suggesting a path that's invalid? or impossible? Worse .. in my example both paths are valid, crystal clear and pass all validations one can apply. If you are talking about BGPSEC as currently proposed, this can't happen. The definition of validity of a PATH_SIG is that valid signatures exactly correspond to AS_PATH data. See: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5.1 Once again, given the encoding of AS_PATH directly in PATH_SIG attribute, the exact scenario is moot (a BGPSEC update will never contain both AS_PATH and PATH_SIG attributes), but the spirit is the same, the validation algorithm will return \"Invalid\" Dougm"}
{"_id":"doc-en-sidr-Bbchux4CGjvh-vxbfirip6i3j0I","title":"","text":"Re: [sidr] route leaks message to IDR\nMaybe there is misunderstanding ... Chris example was stating: 1) first path gets evaluated, is it 'good' (next-hop reachable, not discarded by prefix-list\/etc) 2) second path gets evaluated, is it 'good' (same as above + origin-validate + path-validation) One path comes without signature the other one with signature .. AS PATHs they traverse is disjoined at some point. Are you saying this can not happen ? Many thx, R. What happens in your example if singed comes with PATH_SIG listing 4 ASes (pCount=1 of each) and real AS_PATH is length of 3 ? so, pcount I'm not a fan of.... but, you're suggesting a path that's invalid? or impossible? Worse .. in my example both paths are valid, crystal clear and pass all validations one can apply. If you are talking about BGPSEC as currently proposed, this can't happen. The definition of validity of a PATH_SIG is that valid signatures exactly correspond to AS_PATH data. See: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5.1 Once again, given the encoding of AS_PATH directly in PATH_SIG attribute, the exact scenario is moot (a BGPSEC update will never contain both AS_PATH and PATH_SIG attributes), but the spirit is the same, the validation algorithm will return \"Invalid\" Dougm"}
{"_id":"doc-en-sidr-tjRXDhLBYYuQNR60Eep9cag4iy0","title":"","text":"Re: [sidr] route leaks message to IDR\nWhat happens in your example if singed comes with PATH_SIG listing 4 ASes (pCount=1 of each) and real AS_PATH is length of 3 ? so, pcount I'm not a fan of.... but, you're suggesting a path that's invalid? or impossible? Worse .. in my example both paths are valid, crystal clear and pass all validations one can apply. If you are talking about BGPSEC as currently proposed, this can't happen. The definition of validity of a PATH_SIG is that valid signatures exactly correspond to AS_PATH data. See: http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-02#section-5.1 Once again, given the encoding of AS_PATH directly in PATH_SIG attribute, the exact scenario is moot (a BGPSEC update will never contain both AS_PATH and PATH_SIG attributes), but the spirit is the same, the validation algorithm will return \"Invalid\" Dougm"}
{"_id":"doc-en-sidr-SQcOKZGKy88GdMX1i3qYiQn5-Ts","title":"","text":"Re: [sidr] agenda for virtual meeting Mar 24\nWas the WG consulted on scheduling this virtual meeting and I missed the message? The first message I see on the matter is the announcement of the meeting on 3\/7. I don't know about anyone else, but I'm traveling to Paris the day it's scheduled (actually ON the plane during the meeting), and based on a couple of messages in response to the general announcement (on ietf@ietf), I'm not the only one. My travel arrangements have been made for significantly more than 3 weeks, as are most people's when planning a trip to IETF. Virtual meetings don't need as much advance notice due to the fact that no one needs to travel to *attend* but scheduling conflicts do exist. As far as I can tell, there was no attempt to determine the appropriateness of the date for this or the previous Interim with the WG prior to setting the date. I know of several folks who found out about it during NANOG and would have liked to attend, but couldn't rearrange their travel plans at the last minute. In the future, I respectfully ask the chairs to solicit opinions on potential scheduling of interim meetings PRIOR to setting the date. I have no problem with there being a self-selecting core group of folks that make up a design team, but when they are working directly with the chairs to schedule supposedly official WG interim meetings without involving the WG until the dates are already set, we have a problem. For that matter, I believe that this interim\/virtual meeting should be rescheduled once an appropriate date can be determined based on consensus of the *entire* WG. Put up a doodle poll with some potential dates, publish it along with the goal of the meeting to sidr@ietf.org and let those interested in attending choose. Thanks, Wes -----Original Message----- From: sidr-bounces@ietf.org [mailto:sidr-bounces@ietf.org] On Behalf Of Murphy, Sandra Sent: Saturday, March 17, 2012 10:49 PM To: sidr@ietf.org Cc: iesg-secretary@ietf.org Subject: [sidr] agenda for virtual meeting Mar 24 Here is the agenda for the sidr virtual meeting on Sat 24 Mar 2012. UTC 0800-1030. Protocol spec In depth protocol review, doc structure, forward path, etc. draft-ietf-sidr-bgpsec-protocol-02 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol UTC 1030-1230 Break UTC 1230-1330 draft-ietf-sidr-origin-ops-15 draft-ietf-sidr-bgpsec-reqs-03 draft-ietf-sidr-bgpsec-ops-04 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-origin-ops http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-reqs http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops (if there is time, discussion of draft-ymbk-bgpsec-rtr-rekeying-00 http:\/\/tools.ietf.org\/html\/draft-ymbk-bgpsec-rtr-rekeying draft-rogaglia-sidr-bgpsec-rollover-00 http:\/\/tools.ietf.org\/html\/draft-rogaglia-sidr-bgpsec-rollover-00) UTC 1330-1430 Alternate architectures RPKI delivery and scaling UTC 1430-1600 pfx-validate recent discussions on the sidr list. draft-ietf-sidr-pfx-validate-04 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-pfx-validate --Sandy, speaking as working group co-chair _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-VYyzbrnjCVSrOQe7ZA_shlDll5M","title":"","text":"[sidr] agenda for virtual meeting Mar 24\nHere is the agenda for the sidr virtual meeting on Sat 24 Mar 2012. UTC 0800-1030. Protocol spec In depth protocol review, doc structure, forward path, etc. draft-ietf-sidr-bgpsec-protocol-02 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol UTC 1030-1230 Break UTC 1230-1330 draft-ietf-sidr-origin-ops-15 draft-ietf-sidr-bgpsec-reqs-03 draft-ietf-sidr-bgpsec-ops-04 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-origin-ops http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-reqs http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-ops (if there is time, discussion of draft-ymbk-bgpsec-rtr-rekeying-00 http:\/\/tools.ietf.org\/html\/draft-ymbk-bgpsec-rtr-rekeying draft-rogaglia-sidr-bgpsec-rollover-00 http:\/\/tools.ietf.org\/html\/draft-rogaglia-sidr-bgpsec-rollover-00) UTC 1330-1430 Alternate architectures RPKI delivery and scaling UTC 1430-1600 pfx-validate recent discussions on the sidr list. draft-ietf-sidr-pfx-validate-04 http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-pfx-validate --Sandy, speaking as working group co-chair"}
{"_id":"doc-en-sidr-8ahK533oCQYoEfMKB07HoPcz1Q0","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-02.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-02.txt Pages : 27 Date : 2012-03-12 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-02.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-02.txt"}
{"_id":"doc-en-sidr-lqIDlyPaJYK0NwmTVIlus8gg-u0","title":"","text":"[sidr] some sidr \"replaced by\" cleanup\nI'm about to request some cleanup of the draft \"replaced by\" relationships. If you see anything incorrect about the list below, please let me know. The tools page already records some of these \"replaced by\" records. However, the datatracker is authoritative and the datatracker has not caught some of what the tools site records. This draft Should be replaced by this draft draft-rgaglian-sidr-algorithm-agility draft-ietf-sidr-algorithm-agility draft-turner-sidr-bgpsec-algs draft-ietf-sidr-bgpsec-algs draft-ymbk-bgpsec-ops draft-ietf-sidr-bgpsec-ops draft-lepinski-bgpsec-overview draft-ietf-sidr-bgpsec-overview draft-turner-sidr-bgpsec-pki-profiles draft-ietf-sidr-bgpsec-pki-profiles draft-lepinski-bgpsec-protocol draft-ietf-sidr-bgpsec-protocol draft-ymbk-bgpsec-reqs draft-ietf-sidr-bgpsec-reqs draft-kent-bgpsec-threats draft-ietf-sidr-bgpsec-threats draft-manderson-iana-objects draft-ietf-sidr-iana-objects --Sandy, speaking as wg chair"}
{"_id":"doc-en-sidr-l2BjHFzwZpoFC9xR_F9PXisqTD8","title":"","text":"Re: [sidr] Question about draft-ietf-sidr-pfx-validate-03\nCorrect, yes, I understand. My point is, that because of the inter-relatedness of the various SIDR documents, and because presumably the bgpsec-protocol document is not set in stone, the issues raised in other documents (in SIDR) can be considered as creating requirements to the protocol document. As in, by making changes to the protocol (and necessarily the protocol draft), the issues elsewhere can be designed away and made moot. It is taking a holistic approach to the set of SIDR documents rather than documenting around an existing pre-standards bgpsec implementation. I humbly suggest that the authors of the other documents take a closer look at things I suggest, and perhaps voice them as concerns in the -protocol discussion, as relates to the overall design and in particular their own documents. Some see the glass as half-full, some as half-empty. I see the glass as too big. :-) Brian On Sun, Nov 13, 2011 at 3:12 AM, John Scudder <jgs@juniper.net> wrote: Brian, Danny is talking about pfx-validate, which is not the same as BGPSEC. --John On Nov 13, 2011, at 1:48 AM, Brian Dickson wrote: I think the current design of BGPsec as memorialized (love that word) in the draft-ietf-sidr-bgpsec-protocol would need to be tweaked to handle this. I also believe that the result of the proposed tweak, will be a cleaner design which is easier to implement and verify, as well as not incurring significant operational cost in terms of signatures. Local origination SHOULD occur within an AS on a permanent basis, and only the announcements from the actual originating router need to have unique signatures, regardless of whether they are iBGP or eBGP. (Crypto geeks might suggest adding a random \"nonce\" to make the signature a little harder to crack, since very little on the signature material will change over time - but that is another discussion.) Here is the tweak: Sequence of Octets to be Signed +---------------------------------------+ | Expire Time (8 octets) | +---------------------------------------+ | Origin AS Number (4 octets) | +---------------------------------------+ | Algorithm Suite Identifier (1 octet) | +---------------------------------------+ | NLRI Length (1 octet) | +---------------------------------------+ | NLRI Prefix (variable) | +---------------------------------------+ The \"Target AS\" and \"pCount\" need to be added, meaning the minimum number of signatures changes to \"one origin\" and \"one propagation\" signature. For iBGP within the originating AS, the signature would be \"Target AS == origin AS\", and \"pCount == 0\". For eBGP, it would be what you expect, \"Target AS == neighbor\", \"pCount > 0\". I think that's all that is needed, and the rest of the validation logic in the -protocol doc remain good, the -ops-reqs doc allows validation for local AS, and pfx-validate also works. Any detail or logic errors in the above can be attributed to not enough caffeine... The gist of the above should be solid enough, though. Brian My read of the current draft suggests that if there's a route generated by the local AS in BGP it could never have a \"Valid\" state, and by definition would either posses a \"Not found\" or \"Invalid\" state -- even though the local AS may well have a \"ROA\" and reside in the mapping table as well(!). I do not believe the current text is Section 5 is sufficient to address this case, specifically with either this: \"Considering invalid routes for BGP decision process is a pure local policy matter and should be done with utmost care.\" or this: \"In some cases (particularly when the selection algorithm is influenced by the adjustment of a route property that is not propagated into IBGP) it could be necessary for routing correctness to propagate the validation state to the IBGP peer. This can be accomplished on the sending side by setting a community or extended community based on the validation state, and on the receiving side by matching the (extended) community and setting the validation state.\" I could think of a number of way to address this, but for there to exist the possibility that an internally generated prefix (for which a ROA may well exists) could NEVER have a \"Valid\" state needs to be corrected. Also, S 4: s\/to rest of the network\/to the rest of the network\/ Thanks, -danny _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-3-hZlDyTU-SOqGaHbl_O7zCK8S0","title":"","text":"Re: [sidr] Question about draft-ietf-sidr-pfx-validate-03\nBrian, Danny is talking about pfx-validate, which is not the same as BGPSEC. --John On Nov 13, 2011, at 1:48 AM, Brian Dickson wrote: I think the current design of BGPsec as memorialized (love that word) in the draft-ietf-sidr-bgpsec-protocol would need to be tweaked to handle this. I also believe that the result of the proposed tweak, will be a cleaner design which is easier to implement and verify, as well as not incurring significant operational cost in terms of signatures. Local origination SHOULD occur within an AS on a permanent basis, and only the announcements from the actual originating router need to have unique signatures, regardless of whether they are iBGP or eBGP. (Crypto geeks might suggest adding a random \"nonce\" to make the signature a little harder to crack, since very little on the signature material will change over time - but that is another discussion.) Here is the tweak: Sequence of Octets to be Signed +---------------------------------------+ | Expire Time (8 octets) | +---------------------------------------+ | Origin AS Number (4 octets) | +---------------------------------------+ | Algorithm Suite Identifier (1 octet) | +---------------------------------------+ | NLRI Length (1 octet) | +---------------------------------------+ | NLRI Prefix (variable) | +---------------------------------------+ The \"Target AS\" and \"pCount\" need to be added, meaning the minimum number of signatures changes to \"one origin\" and \"one propagation\" signature. For iBGP within the originating AS, the signature would be \"Target AS == origin AS\", and \"pCount == 0\". For eBGP, it would be what you expect, \"Target AS == neighbor\", \"pCount > 0\". I think that's all that is needed, and the rest of the validation logic in the -protocol doc remain good, the -ops-reqs doc allows validation for local AS, and pfx-validate also works. Any detail or logic errors in the above can be attributed to not enough caffeine... The gist of the above should be solid enough, though. Brian My read of the current draft suggests that if there's a route generated by the local AS in BGP it could never have a \"Valid\" state, and by definition would either posses a \"Not found\" or \"Invalid\" state -- even though the local AS may well have a \"ROA\" and reside in the mapping table as well(!). I do not believe the current text is Section 5 is sufficient to address this case, specifically with either this: \"Considering invalid routes for BGP decision process is a pure local policy matter and should be done with utmost care.\" or this: \"In some cases (particularly when the selection algorithm is influenced by the adjustment of a route property that is not propagated into IBGP) it could be necessary for routing correctness to propagate the validation state to the IBGP peer. This can be accomplished on the sending side by setting a community or extended community based on the validation state, and on the receiving side by matching the (extended) community and setting the validation state.\" I could think of a number of way to address this, but for there to exist the possibility that an internally generated prefix (for which a ROA may well exists) could NEVER have a \"Valid\" state needs to be corrected. Also, S 4: s\/to rest of the network\/to the rest of the network\/ Thanks, -danny _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-49rLf1BMJN2gvqii2TgNS32HaCE","title":"","text":"Re: [sidr] Question about draft-ietf-sidr-pfx-validate-03\nI think the current design of BGPsec as memorialized (love that word) in the draft-ietf-sidr-bgpsec-protocol would need to be tweaked to handle this. I also believe that the result of the proposed tweak, will be a cleaner design which is easier to implement and verify, as well as not incurring significant operational cost in terms of signatures. Local origination SHOULD occur within an AS on a permanent basis, and only the announcements from the actual originating router need to have unique signatures, regardless of whether they are iBGP or eBGP. (Crypto geeks might suggest adding a random \"nonce\" to make the signature a little harder to crack, since very little on the signature material will change over time - but that is another discussion.) Here is the tweak: Sequence of Octets to be Signed +---------------------------------------+ | Expire Time (8 octets) | +---------------------------------------+ | Origin AS Number (4 octets) | +---------------------------------------+ | Algorithm Suite Identifier (1 octet) | +---------------------------------------+ | NLRI Length (1 octet) | +---------------------------------------+ | NLRI Prefix (variable) | +---------------------------------------+ The \"Target AS\" and \"pCount\" need to be added, meaning the minimum number of signatures changes to \"one origin\" and \"one propagation\" signature. For iBGP within the originating AS, the signature would be \"Target AS == origin AS\", and \"pCount == 0\". For eBGP, it would be what you expect, \"Target AS == neighbor\", \"pCount > 0\". I think that's all that is needed, and the rest of the validation logic in the -protocol doc remain good, the -ops-reqs doc allows validation for local AS, and pfx-validate also works. Any detail or logic errors in the above can be attributed to not enough caffeine... The gist of the above should be solid enough, though. Brian My read of the current draft suggests that if there's a route generated by the local AS in BGP it could never have a \"Valid\" state, and by definition would either posses a \"Not found\" or \"Invalid\" state -- even though the local AS may well have a \"ROA\" and reside in the mapping table as well(!). I do not believe the current text is Section 5 is sufficient to address this case, specifically with either this: \"Considering invalid routes for BGP decision process is a pure local policy matter and should be done with utmost care.\" or this: \"In some cases (particularly when the selection algorithm is influenced by the adjustment of a route property that is not propagated into IBGP) it could be necessary for routing correctness to propagate the validation state to the IBGP peer. This can be accomplished on the sending side by setting a community or extended community based on the validation state, and on the receiving side by matching the (extended) community and setting the validation state.\" I could think of a number of way to address this, but for there to exist the possibility that an internally generated prefix (for which a ROA may well exists) could NEVER have a \"Valid\" state needs to be corrected. Also, S 4: s\/to rest of the network\/to the rest of the network\/ Thanks, -danny _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-aW8frLKR9ZIH094iNjdbLwjlcqA","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nMatt Lepinski The -01 version of the draft contains a mechanism (a field called pCount) which attempts to address this issue by having route servers create BGPSEC signatures without increasing the effective length of the AS- PATH attribute. [WEG] where you explain the pCount field in both section 3 and 4.1, you never explicitly state anything about the route-server use case. In those sections, you only discuss the case where this is used to eliminate the need for duplicate signatures in the case of AS-path prepending. I think that section 3's explanation of the field definitely needs a reference to 4.1 and 4.2, and since 4.2 contains a backward reference to 4.1 explaining pCount>1, 4.1 should probably have a corresponding reference to 4.2 for pCount=0. It may also be appropriate to explicitly state in 4.1 that when a node sets the pCount to a value greater than 1, that value MUST correspond to the number of instances of the AS-path being represented in BGP's standard AS\/AS4_path attribute. Some other general comments- as I noted in my review of the requirements document, I think that it's appropriate to note in this document an explicit requirement for 4-byte ASN support, including any discussion of how to handle 4-byte ASNs, as well as recommend explicit handling for occurrences of AS23456 in the path (eg, because we should be acting on the 4-byte ASN, we should never see the transition ASN in the path, and therefore those updates should always be seen as invalid). 4.2 - AS_SETs are deprecated. You should update your discussion accordingly, with a reference to whatever RFC draft-ietf-idr-deprecate-as-sets-06 became (I'm writing this offline, so I don't have the ability to find the number). 5.1 - Is the algorithm intended to be processed strictly in the order listed? Specifically, both in terms of the items preceded with \"first, second, third, finally...\" and within the multi-step subsection covering determining if updates are properly formed, it is unclear whether this is simply an arbitrary grammatical list grouping for ease of reading, or if it is an explicitly defined order. I would prefer that it either explicitly states that it requires the order listed (with justification\/rationale as appropriate) or to explicitly note that the order is left to the implementation so that optimizations can be made based on the specific implementation. It may also be worth noting the places where there is no dependency between validation steps so that they can be processed in parallel on separate threads (such as when optimizing for multi-core applications). Also, shouldn't there be a reference to the origin validation documents instead of an explanation of how to do origin validation? Regarding confederations - what if one or more of the confeds is a private ASN? This is maybe a bit more straightforward if you're in the situation where AS1 learns the route originated from a private ASN in confederation, as it could simply originate\/sign the route to its ebgp peers directly. It's more complicated (I think...) if the confed ASes are in the middle of the path (that is, the private ASN learns the route from a downstream ASN and then propagates it to the upstream confed peer) because there's not really a way to drop signatures from the middle of the path, yet the private ASNs are going to be stripped out of the BGP update messages as it leaves the confederation. Perhaps this is another case where the pCount should be 0? Is there any other special handling for confed? Alternatively, we may have to explicitly prohibit this setup similar to the way that we did with AS_Set. Wes George This E-mail and any of its attachments may contain Time Warner Cable proprietary information, which is privileged, confidential, or subject to copyright belonging to Time Warner Cable. This E-mail is intended solely for the use of the individual or entity to which it is addressed. If you are not the intended recipient of this E-mail, you are hereby notified that any dissemination, distribution, copying, or action taken in relation to the contents of and attachments to this E-mail is strictly prohibited and may be unlawful. If you have received this E-mail in error, please notify the sender immediately and permanently delete the original and any copy of this E-mail and any printout."}
{"_id":"doc-en-sidr-2DDrw13VNPbPLxuQVvv39LQ109Y","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nI believe the concerns regarding \"AS-path cheating\" to attract traffic, by using pCount=0, could be addressed with some special handling. draft-ietf-sidr-bgpsec-ops-01 suggests a knob If it is known that a BGPsec neighbor is not a transparent route server, and the router provides a knob to disallow a received pCount (prepend count, zero for transparent route servers) of zero, that knob SHOULD be applied. randy"}
{"_id":"doc-en-sidr-wUqxaE0ASYuOp8biMMx1evg2EF0","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nI've read the draft, and find it to be very high quality and very clear. The one comment I have regarding pCount, is in regards to processing received pCount=0 announcements. I believe the concerns regarding \"AS-path cheating\" to attract traffic, by using pCount=0, could be addressed with some special handling. Basically, when receiving pCount=0 at the top of the stack (most recent addition, by one's peer), checking the next-hop to ensure it satisfies \"three-routing\" requirements, i.e. that the next hop be something other than the neighbor's IP address, is sufficient. The only other suggestion is related to the number of signature blocks. I agree that support for two is needed at a minimum. I am not entirely sure that restricting it to two is necessary, but haven't thought through the scenarios here. Perhaps \"one or more\" rather than \"one or two\"? Has there been any thought to use of a cryptographically signed \"Expire Time\" (which can be sent and updated as a keep-alive\/add-time-to-the-meter mechanism), and then having the blocks refer to the Expire Time by reference (and have the reference internally by pointer, originally matching a cryptographic hash on the first received timer, whose pointed-to value gets updated)? This reduces the \"beacon\" issue to updating a single value, and limits the playback to the interval during which the original Expire Time exists. Newer updates would refer to the latest cryptographic hash of the last sent Expire Time (update). It becomes a chaining exercise in a state-ful environment... Brian On Tue, Nov 1, 2011 at 12:59 PM, Matt Lepinski <mlepinski@bbn.com> wrote: I have updated the BGPSEC protocol specification. At the SIDR meeting in Quebec, there was significant discussion about how BGPSEC could provide security of the AS-PATH attribute while still accommodating the needs of route servers that participate in BGP, but do not wish to increase the length of the AS-PATH attribute. The -01 version of the draft contains a mechanism (a field called pCount) which attempts to address this issue by having route servers create BGPSEC signatures without increasing the effective length of the AS-PATH attribute. I would greatly appreciate comments on this mechanism and whether it adequately addresses the issues raised at the last SIDR meeting and subsequently discussed on the list. There was has also been significant discussion on the SIDR list of the \"Expire TIme\" field in BGPSEC and the associated \"Beacon-ing\" (that is, periodic re-advertisement of a prefix with a new signature and a new Expire Time) as a mechanism to address replay attacks (as well as attacks where a malicious peer fails to propagate the withdrawal of a route). My understanding is that the consensus of the working group was that the current Expire Time mechanism is reasonable as long as re-advertisement is only required at the origin AS (and not at intermediate ASes). The current -01 version of the draft attempts to reflect that consensus. Finally, there are a number of small editorial changes that I believe will improve the clarity of the draft. Thanks again to everyone who has reviewed the document, feedback on how the text could be made more easily understandable is especially welcome. - Matt Lepinski A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-01.txt Pages : 28 Date : 2011-10-31 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-YVlLA9ArL4Q32U3vBOm7d-3pcuc","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nAt the SIDR meeting in Quebec, there was significant discussion about how BGPSEC could provide security of the AS-PATH attribute while still accommodating the needs of route servers that participate in BGP, but do not wish to increase the length of the AS-PATH attribute. The -01 version of the draft contains a mechanism (a field called pCount) which attempts to address this issue by having route servers create BGPSEC signatures without increasing the effective length of the AS-PATH attribute. I would greatly appreciate comments on this mechanism and whether it adequately addresses the issues raised at the last SIDR meeting and subsequently discussed on the list. If we do this we're disclosing routing topology information that is NOT disclosed today (i.e., an otherwise transparent route server in the BGP path). IIRC, not disclosing new information was an explicit requirement? There was has also been significant discussion on the SIDR list of the \"Expire TIme\" field in BGPSEC and the associated \"Beacon-ing\" (that is, periodic re-advertisement of a prefix with a new signature and a new Expire Time) as a mechanism to address replay attacks (as well as attacks where a malicious peer fails to propagate the withdrawal of a route). My understanding is that the consensus of the working group was that the current Expire Time mechanism is reasonable as long as re-advertisement is only required at the origin AS (and not at intermediate ASes). The current -01 version of the draft attempts to reflect that consensus. Can you provide a pointer to where this was discussed AND consensus was reached in the WG, I don't recall seeing any consensus and I'm still very concerned about adding periodic updates and considerable churn to an otherwise stateful system in order to minimize exposure windows to multiple hours (or more). Furthermore, given the systemic and architectural implications of such a mechanism, I would like to see an explicit consensus call on this item from the chairs. I also think this is something that should be consulted with the IDR WG, as periodic updates (\"beacons\") are a considerable step away from the stateful BGP we know today -- and when coupled with single NLRI-only UPDATES an order of magnitude or larger that require cryptographic validation of many component elements, it makes me uneasy. -danny"}
{"_id":"doc-en-sidr-1x_HVevibLTgBQMutbEgOo56tKU","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nI have updated the BGPSEC protocol specification. At the SIDR meeting in Quebec, there was significant discussion about how BGPSEC could provide security of the AS-PATH attribute while still accommodating the needs of route servers that participate in BGP, but do not wish to increase the length of the AS-PATH attribute. The -01 version of the draft contains a mechanism (a field called pCount) which attempts to address this issue by having route servers create BGPSEC signatures without increasing the effective length of the AS-PATH attribute. I would greatly appreciate comments on this mechanism and whether it adequately addresses the issues raised at the last SIDR meeting and subsequently discussed on the list. There was has also been significant discussion on the SIDR list of the \"Expire TIme\" field in BGPSEC and the associated \"Beacon-ing\" (that is, periodic re-advertisement of a prefix with a new signature and a new Expire Time) as a mechanism to address replay attacks (as well as attacks where a malicious peer fails to propagate the withdrawal of a route). My understanding is that the consensus of the working group was that the current Expire Time mechanism is reasonable as long as re-advertisement is only required at the origin AS (and not at intermediate ASes). The current -01 version of the draft attempts to reflect that consensus. Finally, there are a number of small editorial changes that I believe will improve the clarity of the draft. Thanks again to everyone who has reviewed the document, feedback on how the text could be made more easily understandable is especially welcome. - Matt Lepinski A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-01.txt Pages : 28 Date : 2011-10-31 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-txapywGP4Fz4kYWmgygQpDm4S3U","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-01.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-01.txt Pages : 28 Date : 2011-10-31 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-01.txt"}
{"_id":"doc-en-sidr-2J_IAkpbyVtzb-NZUeCBanmo3Gs","title":"","text":"Re: [sidr] BGPSec scaling (was RE: beacons and bgpsec)\nSorry, I accidentally hit Send (instead of Save) halfway through in the previous email. Here is the complete email. Jakob, Three key specific questions one would ask about a model are: Q1. Does it model the underlying physical system accurately. In this instance, would it correctly compute the RIB size, given a number of routes (i.e., total # prefix-paths) in the RIB? Q2: Is it well rooted in the historical measurement data for its projections into the future? Q3: Are additional assumptions made for projecting into the future reasonable? In this instance, are the assumptions regarding the BGPSEC take rate reasonable? Answers (IMHO): For Q1: Yes. There is no guess work involved here. I feel we've accurately factored in the update overheads of BGPSEC based on draft-ietf-sidr-bgpsec-protocol-00. For Q2: We used up to date historical measurement data from http:\/\/www.potaroo.net\/ispcol\/2009-03\/bgp2008.html (also Geoff's 2009 predictions in that paper came out nearly accurate through the next two years into 2010 and 2011.) We also used current measurements (as of March 2011) from a large Tier 1 ISP regarding the total # routes they observed in the PE routers and in Route Reflectors. We used the observed growth rates for IPv4\/IPv6 from the past several years to project into the future. (Needless to say, predicting the future is never a hard science.) We have provided the excel speadsheet so anyone can inject their world view regarding growth rates and see what happens. http:\/\/www.antd.nist.gov\/~ksriram\/BGPSEC_RIB.xls For Q3: This is the hardest part of the modeling -- very tricky and no one can speak to it with certainty. We did overlay a BGPSEC take rate model (slides 5 and 6) http:\/\/www.ietf.org\/proceedings\/81\/slides\/sidr-2.pdf This was broadly based on historical view of take rates of new technologies in general. (It is usually a Normal distribution curve.) This was felt to be OK within the BGPSEC design team discussions. Once again, anyone curious can play with the speadsheet to input their assumptions\/knowledge regarding their projected take rates for BGPSEC. So at the minimum, if you just wish to find out the RIB size corresponding to a given number of routes (i.e., total # prefix-paths), the model would give you that accurately. You are further at liberty to input into the speadsheet any assumptions regarding the growth rates and take-rates per your view of the world. I hope this helps some. Sriram Do you trust this? http:\/\/www.ietf.org\/proceedings\/81\/slides\/sidr-2.pdf -- Jakob Heitz."}
{"_id":"doc-en-sidr-0_5pDsJ63wcCX7xhu3ms76skcBw","title":"","text":"Re: [sidr] BGPSec scaling (was RE: beacons and bgpsec)\nJakob, Three key specific questions one would ask about a model are: Q1. Does it model the underlying physical system accurately. In this instance, would it correctly compute the RIB size, given a number of routes (i.e., total # prefix-paths) in the RIB? Q2: Is it well rooted in the historical measurement data for projecting into the future? Q3: Are additional assumptions made for projecting into the future reasonable? In this instance, are the assumptions regarding the BGPSEC take rate reasonable? Answers (IMHO): For Q1: Yes. There is no guess work involved here. I feel we've accurately factored in the update overheads of BGPSEC based on draft-ietf-sidr-bgpsec-protocol-00. For Q2: We used up to date historical measurement data from Do you trust this? http:\/\/www.ietf.org\/proceedings\/81\/slides\/sidr-2.pdf -- Jakob Heitz. _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-OtmJTg8NwKBLph2lt7mYltJnQQw","title":"","text":"Re: [sidr] BGPSec scaling (was RE:  beacons and bgpsec)\n-- snip -- If we reprioritise BGPSec, we could make it work. Sugestion: during bringup, send routes without the BGPSec attribute. I think there is a significant risk that this would cause unnecessary Internet wide churn. I would propose and alternative approach. To send the routes with whatever attributes sender decides to send then with and do it only once. Up-on reception if indeed inline CPU processing is an issue on given platform store the BGPSec related attributes without any processing then when CPU get's idle .. verify them. Hoping that only small fraction of all routes could be considered invalid you may later withdraw them. Of course this only attempts to fix inbound processing issue. You can not do the same when signing the routes outbound. Jakob: Robert: The protocol permits the ideas you are proposing -- see Section 4.2. http:\/\/tools.ietf.org\/html\/draft-ietf-sidr-bgpsec-protocol-00#section-4.2 The key wording there is: .... it is RECOMMENDED that if the BGPSEC speaker chooses to propagate the route that it generate an update message containing the BGPSEC_Path_Signatures attribute. However, a BGPSEC speaker MAY propagate a route advertisement by generating a (non-BGPSEC) update message that does not contain the BGPSEC_Path_Signatures attribute. Also, the optimizations you mention are included\/discussed in Section 5.4 of the draft-sriram-bgpsec-design-choices document: 5.4. Temporary Suspension of Attestations and Validations http:\/\/tools.ietf.org\/html\/draft-sriram-bgpsec-design-choices-00#section-5.4 Robert seems to be asserting that the router must always sign and propagate the update (if it selected a signed update for best path). However, the current protocol specification allows for dropping BGPSEC_Path_Signatures attribute (potentially for cases when the route-processor is in overload state). Sriram"}
{"_id":"doc-en-sidr-c_lQcQDMieQ1awP-lJNPC9CKNRc","title":"","text":"Re: [sidr] Fwd: New Version Notification\n for\tdraft-ietf-sidr-algorithm-agility-03.txt\nThe intention was to focus on the use case for the proposed changes (BGPSEC certs). what is a \"BGPSEC cert?\" What Mark and I are currently proposing in draft-turner-sidr-bgpsec-pki-profiles is that a BGPSEC certificate is a special purpose Resource Certificate (and hence issued by an RPKI CA) that always contains: - A non-critical \"BGPSEC\" Extended Key Usage (defined in the draft) - An Autonomous System (AS) Identifier Delegation extension (from 3779) and never contains: - the Subject Information Access (SIA) extension - the IP Address Delegation extension With the BGPSEC EKU, RPs will easily be able to distinguish a BGPSEC certificate from the Resource Certificates defined with draft-ietf-sidr-res-certs and even from those defined in draft-ietf-csi-send-cert. The EKU is pretty much the big clue to RPs for two things 1) this certificate is only used by BGPSEC speakers and 2) that the validation procedures defined in draft-ietf-sidr-res-certs won't work on BGPSEC certificates. The procedures in draft-turner-sidr-bgpsec-pki-profiles need to be used.* Note that including EKUs in \"routers or other devices\" is allowed by draft-ietf-sidr-res-certs. The AS Identifier Delegation extension is always included because BGPSEC is only about AS-Paths. The IP Address Delegation extension just isn't needed so it's left out. The SIA is omitted because it isn't needed. The objects signed by the BGPSEC speaker (i.e., the BGPSEC update message defined in draft-ietf-sidr-bgpsec-protocol) are not included in a repository - the objects are exchanged as part of the BGPSEC protocol. * The difference in path processing is about checking for the presence of the EKU and AS Identifier Delegation extensions and the absence of the SIA and IP Address Delegation extensions. spt PS Technically, the EKU is defined in draft-turner-bpgsec-pki-profiles. It's just an object identifier (OID) that Mark and I would get out of the PKIX Arc, which is where all the IETF EKU OIDs come from. We obviously haven't requested the OID yet so it's still \"TBD\". If the WG decides to adopt this approach, then we'll go through the appropriate procedures to request an OID and include it in the draft."}
{"_id":"doc-en-sidr-B06LGGE8Wn-zlB15TDWYOgvjcoY","title":"","text":"Re: [sidr] draft-sriram-bgpsec-design-choices-00 -- IXP and Route\n Server\nThis is what \"6.6 Proxy Signing\" in draft-sriram-bgpsec-design-choices suggests, is it not ? Or does that blow the trust model to hell, also ? it does indeed. that is why 6.6 was rejected. Ah. There I was, reading a draft of 5-Jul-2011 and thinking I was up to date :-( sriram's document represents the design team's thought processes, and therefore includes things which were rejected in the design. the bgpsec protocol documents are, i think, still are draft-ietf-sidr-bgpsec-overview-00.txt draft-ietf-sidr-bgpsec-protocol-00.txt OK. If the RS ASN is in the path, then nobody needs to depend on the integrity of the RS (however trustworthy one may expect them to be). bingo! I look forward to the ASN count mechanism appearing in the draft(s), and support for Route Servers making its way into the Requirements. i am still selling my hack to the design team. randy"}
{"_id":"doc-en-sidr--ivA2mYYgmwKeJ-Uyq0ewsn8_t0","title":"","text":"Re: [sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-00.txt\nThis is the first working group version of the BGPSEC protocol document. There are no significant technical changes since from the prior individual version. However, there were a number of clarifications\/corrections to the text based on working group feedback. - Matt Lepinski A New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-00.txt Pages : 25 Date : 2011-06-11 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-00.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-00.txt _______________________________________________ sidr mailing list sidr@ietf.org https:\/\/www.ietf.org\/mailman\/listinfo\/sidr"}
{"_id":"doc-en-sidr-TM4hFnjdHaoZMjkFWe7hamBvtss","title":"","text":"[sidr] I-D Action: draft-ietf-sidr-bgpsec-protocol-00.txt\nA New Internet-Draft is available from the on-line Internet-Drafts directories. This draft is a work item of the Secure Inter-Domain Routing Working Group of the IETF. Title : BGPSEC Protocol Specification Author(s) : Matthew Lepinski Filename : draft-ietf-sidr-bgpsec-protocol-00.txt Pages : 25 Date : 2011-06-11 This document describes BGPSEC, an extension to the Border Gateway Protocol (BGP) that provides security for the AS-PATH attribute in BGP update messages. BGPSEC is implemented via a new optional non- transitive BGP path attribute that carries a digital signature produced by each autonomous system on the AS-PATH. A URL for this Internet-Draft is: http:\/\/www.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-00.txt Internet-Drafts are also available by anonymous FTP at: ftp:\/\/ftp.ietf.org\/internet-drafts\/ This Internet-Draft can be retrieved at: ftp:\/\/ftp.ietf.org\/internet-drafts\/draft-ietf-sidr-bgpsec-protocol-00.txt"}
